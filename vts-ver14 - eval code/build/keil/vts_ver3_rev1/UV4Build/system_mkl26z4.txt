; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\system_mkl26z4.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\system_mkl26z4.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -I..\..\..\..\inc -I"D:\RecoveredHP\mridul.eecs@gmail.com\vts-ver14 - testing code\build\keil\vts_ver3_rev1\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0-Beta4\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.11.0\Device\Include -D__UVISION_VERSION=518 -D_RTE_ -DMKL26Z128xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\system_mkl26z4.crf ..\..\..\src\cpu\CMSIS\Source\system_MKL26Z4.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;126    
;;;127    void SystemInit (void) {
000000  2000              MOVS     r0,#0
;;;128    #if (DISABLE_WDOG)
;;;129      /* Disable the WDOG module */
;;;130      /* SIM_COPC: COPT=0,COPCLKS=0,COPW=0 */
;;;131      SIM->COPC = (uint32_t)0x00u;
000002  4976              LDR      r1,|L1.476|
000004  6008              STR      r0,[r1,#0]
;;;132    #endif /* (DISABLE_WDOG) */
;;;133    #if (CLOCK_SETUP == 0)
;;;134      /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=2,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;135      SIM->CLKDIV1 = (uint32_t)0x00020000UL; /* Update system prescalers */
;;;136      /* Switch to FEI Mode */
;;;137      /* MCG->C1: CLKS=0,FRDIV=0,IREFS=1,IRCLKEN=1,IREFSTEN=0 */
;;;138      MCG->C1 = (uint8_t)0x06U;
;;;139      /* MCG_C2: LOCRE0=0,RANGE0=0,HGO0=0,EREFS0=0,LP=0,IRCS=0 */
;;;140      MCG->C2 &= (uint8_t)~(uint8_t)0xBFU;
;;;141      /* MCG->C4: DMX32=0,DRST_DRS=1 */
;;;142      MCG->C4 = (uint8_t)((MCG->C4 & (uint8_t)~(uint8_t)0xC0U) | (uint8_t)0x20U);
;;;143      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
;;;144      OSC0->CR = (uint8_t)0x80U;
;;;145      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;146      MCG->C5 = (uint8_t)0x00U;
;;;147      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;148      MCG->C6 = (uint8_t)0x00U;
;;;149      while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
;;;150      }
;;;151      while((MCG->S & 0x0CU) != 0x00U) {    /* Wait until output of the FLL is selected */
;;;152      }
;;;153    #elif (CLOCK_SETUP == 1)
;;;154      /* SIM->SCGC5: PORTA=1 */
;;;155                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
000006  4876              LDR      r0,|L1.480|
000008  6b80              LDR      r0,[r0,#0x38]
00000a  1549              ASRS     r1,r1,#21
00000c  4308              ORRS     r0,r0,r1
00000e  4974              LDR      r1,|L1.480|
000010  6388              STR      r0,[r1,#0x38]
;;;156      /* SIM->CLKDIV1: OUTDIV1=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;157      SIM->CLKDIV1 = (uint32_t)0x10000000UL; /* Update system prescalers */
000012  2001              MOVS     r0,#1
000014  0700              LSLS     r0,r0,#28
000016  4972              LDR      r1,|L1.480|
000018  3140              ADDS     r1,r1,#0x40
00001a  6048              STR      r0,[r1,#4]
;;;158      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;159      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
00001c  4871              LDR      r0,|L1.484|
00001e  6880              LDR      r0,[r0,#8]
000020  4971              LDR      r1,|L1.488|
000022  4008              ANDS     r0,r0,r1
000024  496f              LDR      r1,|L1.484|
000026  6088              STR      r0,[r1,#8]
;;;160      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;161      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
000028  4608              MOV      r0,r1
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  496e              LDR      r1,|L1.488|
00002e  4008              ANDS     r0,r0,r1
000030  496c              LDR      r1,|L1.484|
000032  60c8              STR      r0,[r1,#0xc]
;;;162      /* Switch to FBE Mode */
;;;163      /* MCG_C2: LOCRE0=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;164               MCG->C2 = (uint8_t)((MCG->C2 & (uint8_t)~(uint8_t)0x9BU) | (uint8_t)0x24U);
000034  486d              LDR      r0,|L1.492|
000036  7840              LDRB     r0,[r0,#1]
000038  2164              MOVS     r1,#0x64
00003a  4008              ANDS     r0,r0,r1
00003c  2124              MOVS     r1,#0x24
00003e  4308              ORRS     r0,r0,r1
000040  496a              LDR      r1,|L1.492|
000042  7048              STRB     r0,[r1,#1]
;;;165      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=0 */
;;;166      OSC0->CR = (uint8_t)0x80U;
000044  2080              MOVS     r0,#0x80
000046  496a              LDR      r1,|L1.496|
000048  7008              STRB     r0,[r1,#0]
;;;167      /* MCG_C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;168    
;;;169      MCG->C1 = (uint8_t)0x9AU;
00004a  209a              MOVS     r0,#0x9a
00004c  4967              LDR      r1,|L1.492|
00004e  7008              STRB     r0,[r1,#0]
;;;170      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;171      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
000050  4608              MOV      r0,r1
000052  78c0              LDRB     r0,[r0,#3]
000054  06c0              LSLS     r0,r0,#27
000056  0ec0              LSRS     r0,r0,#27
000058  70c8              STRB     r0,[r1,#3]
;;;172      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=1 */
;;;173      MCG->C5 = (uint8_t)0x03U;
00005a  2003              MOVS     r0,#3
00005c  7108              STRB     r0,[r1,#4]
;;;174      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;175      MCG->C6 = (uint8_t)0x00U;
00005e  2000              MOVS     r0,#0
000060  7148              STRB     r0,[r1,#5]
;;;176      //while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */}
;;;177     // while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */}
;;;178      /* Switch to PBE Mode */
;;;179      /* MCG->C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
;;;180      MCG->C6 = (uint8_t)0x40U;
000062  2040              MOVS     r0,#0x40
000064  7148              STRB     r0,[r1,#5]
;;;181    
;;;182    while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
000066  bf00              NOP      
                  |L1.104|
000068  4860              LDR      r0,|L1.492|
00006a  7980              LDRB     r0,[r0,#6]
00006c  210c              MOVS     r1,#0xc
00006e  4008              ANDS     r0,r0,r1
000070  2808              CMP      r0,#8
000072  d1f9              BNE      |L1.104|
;;;183      }
;;;184      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
000074  bf00              NOP      
                  |L1.118|
000076  485d              LDR      r0,|L1.492|
000078  7980              LDRB     r0,[r0,#6]
00007a  2140              MOVS     r1,#0x40
00007c  4008              ANDS     r0,r0,r1
00007e  2800              CMP      r0,#0
000080  d0f9              BEQ      |L1.118|
;;;185      }
;;;186      /* Switch to PEE Mode */
;;;187      /* MCG->C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;188      MCG->C1 = (uint8_t)0x1AU;
000082  201a              MOVS     r0,#0x1a
000084  4959              LDR      r1,|L1.492|
000086  7008              STRB     r0,[r1,#0]
;;;189      while((MCG->S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */
000088  bf00              NOP      
                  |L1.138|
00008a  4858              LDR      r0,|L1.492|
00008c  7980              LDRB     r0,[r0,#6]
00008e  210c              MOVS     r1,#0xc
000090  4008              ANDS     r0,r0,r1
000092  280c              CMP      r0,#0xc
000094  d1f9              BNE      |L1.138|
;;;190      }
;;;191    #elif (CLOCK_SETUP == 2)
;;;192      /* SIM->SCGC5: PORTA=1 */
;;;193      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
;;;194      /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;195      SIM->CLKDIV1 = (uint32_t)0x00000000UL; /* Update system prescalers */
;;;196      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;197      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
;;;198      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;199      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
;;;200      /* Switch to FBE Mode */
;;;201      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;202      MCG->C2 = (uint8_t)0x24U;
;;;203      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=0 */
;;;204      OSC0->CR = (uint8_t)0x80U;
;;;205      /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;206      MCG->C1 = (uint8_t)0x9AU;
;;;207      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;208      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
;;;209      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;210      MCG->C5 = (uint8_t)0x00U;
;;;211      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;212      MCG->C6 = (uint8_t)0x00U;
;;;213      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
;;;214      }
;;;215      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;216      }
;;;217      /* Switch to BLPE Mode */
;;;218      /* MCG_C2: LOCRE0=0,RANGE0=2,HGO0=0,EREFS0=1,LP=1,IRCS=0 */
;;;219      MCG->C2 = (uint8_t)((MCG->C2 & (uint8_t)~(uint8_t)0x99U) | (uint8_t)0x26U);
;;;220      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;221      }
;;;222    #elif (CLOCK_SETUP == 3)
;;;223    	// CLOCK_SETUP == 3 yields the default startup configuration
;;;224    #elif (CLOCK_SETUP == 4)
;;;225    	
;;;226    	// Use this configuration for USB operation!!
;;;227    	
;;;228    	/* SIM->SCGC5: PORTA=1 */
;;;229      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
;;;230      /* SIM->CLKDIV1: OUTDIV1=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;231      SIM->CLKDIV1 = (uint32_t)0x10010000UL; /* Update system prescalers */
;;;232      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;233      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
;;;234      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;235      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
;;;236      /* Switch to FBE Mode */
;;;237      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=1 */
;;;238      OSC0->CR = (uint8_t)0x89U;
;;;239      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;240      MCG->C2 = (uint8_t)0x24U;
;;;241      /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;242      MCG->C1 = (uint8_t)0x9AU;
;;;243      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;244      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
;;;245      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=1 */
;;;246      MCG->C5 = (uint8_t)0x03U;
;;;247      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;248      MCG->C6 = (uint8_t)0x18U;
;;;249      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
;;;250      }
;;;251      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;252      }
;;;253      /* Switch to PBE Mode */
;;;254      /* MCG->C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
;;;255      MCG->C6 = (uint8_t)0x58U;
;;;256      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;257      }
;;;258      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
;;;259      }
;;;260      /* Switch to PEE Mode */
;;;261      /* MCG->C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;262      MCG->C1 = (uint8_t)0x1AU;
;;;263      while((MCG->S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */
;;;264      }
;;;265      SystemCoreClock = DEFAULT_SYSTEM_CLOCK;
;;;266    #endif /* (CLOCK_SETUP == 4) */
;;;267    }
000096  4770              BX       lr
;;;268    
                          ENDP

                  SystemCoreClockUpdate PROC
;;;272    
;;;273    void SystemCoreClockUpdate (void) {
000098  b570              PUSH     {r4-r6,lr}
;;;274      uint32_t MCGOUTClock;                                                        /* Variable to store output clock frequency of the MCG module */
;;;275      uint8_t Divider;
;;;276    
;;;277      if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x0u) {
00009a  4854              LDR      r0,|L1.492|
00009c  7800              LDRB     r0,[r0,#0]
00009e  21c0              MOVS     r1,#0xc0
0000a0  4008              ANDS     r0,r0,r1
0000a2  2800              CMP      r0,#0
0000a4  d168              BNE      |L1.376|
;;;278        /* Output of FLL or PLL is selected */
;;;279        if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u) {
0000a6  4851              LDR      r0,|L1.492|
0000a8  7940              LDRB     r0,[r0,#5]
0000aa  2140              MOVS     r1,#0x40
0000ac  4008              ANDS     r0,r0,r1
0000ae  2800              CMP      r0,#0
0000b0  d14e              BNE      |L1.336|
;;;280          /* FLL is selected */
;;;281          if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u) {
0000b2  484e              LDR      r0,|L1.492|
0000b4  7800              LDRB     r0,[r0,#0]
0000b6  2104              MOVS     r1,#4
0000b8  4008              ANDS     r0,r0,r1
0000ba  2800              CMP      r0,#0
0000bc  d115              BNE      |L1.234|
;;;282            /* External reference clock is selected */
;;;283            MCGOUTClock = CPU_XTAL_CLK_HZ;                                       /* System oscillator drives MCG clock */
0000be  4c4d              LDR      r4,|L1.500|
;;;284            Divider = (uint8_t)(1u << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
0000c0  484a              LDR      r0,|L1.492|
0000c2  7800              LDRB     r0,[r0,#0]
0000c4  2138              MOVS     r1,#0x38
0000c6  4008              ANDS     r0,r0,r1
0000c8  08c1              LSRS     r1,r0,#3
0000ca  2001              MOVS     r0,#1
0000cc  4088              LSLS     r0,r0,r1
0000ce  b2c5              UXTB     r5,r0
;;;285            MCGOUTClock = (MCGOUTClock / Divider);  /* Calculate the divided FLL reference clock */
0000d0  4629              MOV      r1,r5
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       __aeabi_uidivmod
0000d8  4604              MOV      r4,r0
;;;286            if ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) {
0000da  4844              LDR      r0,|L1.492|
0000dc  7840              LDRB     r0,[r0,#1]
0000de  2130              MOVS     r1,#0x30
0000e0  4008              ANDS     r0,r0,r1
0000e2  2800              CMP      r0,#0
0000e4  d003              BEQ      |L1.238|
;;;287              MCGOUTClock /= 32u;                                                  /* If high range is enabled, additional 32 divider is active */
0000e6  0964              LSRS     r4,r4,#5
0000e8  e001              B        |L1.238|
                  |L1.234|
;;;288            } /* ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) */
;;;289          } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;290            MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                     /* The slow internal reference clock is selected */
0000ea  2401              MOVS     r4,#1
0000ec  03e4              LSLS     r4,r4,#15
                  |L1.238|
;;;291          } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;292          /* Select correct multiplier to calculate the MCG output clock  */
;;;293          switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
0000ee  483f              LDR      r0,|L1.492|
0000f0  78c0              LDRB     r0,[r0,#3]
0000f2  21e0              MOVS     r1,#0xe0
0000f4  4008              ANDS     r0,r0,r1
0000f6  06c1              LSLS     r1,r0,#27
0000f8  0ec9              LSRS     r1,r1,#27
0000fa  2900              CMP      r1,#0
0000fc  d126              BNE      |L1.332|
0000fe  1140              ASRS     r0,r0,#5
000100  0003              MOVS     r3,r0
000102  f7fffffe          BL       __ARM_common_switch8
000106  0805              DCB      0x08,0x05
000108  090d1115          DCB      0x09,0x0d,0x11,0x15
00010c  191d2023          DCB      0x19,0x1d,0x20,0x23
;;;294            case 0x0u:
;;;295              MCGOUTClock *= 640u;
000110  2005              MOVS     r0,#5
000112  01c0              LSLS     r0,r0,#7
000114  4344              MULS     r4,r0,r4
;;;296              break;
000116  e01a              B        |L1.334|
;;;297            case 0x20u:
;;;298              MCGOUTClock *= 1280u;
000118  2005              MOVS     r0,#5
00011a  0200              LSLS     r0,r0,#8
00011c  4344              MULS     r4,r0,r4
;;;299              break;
00011e  e016              B        |L1.334|
;;;300            case 0x40u:
;;;301              MCGOUTClock *= 1920u;
000120  200f              MOVS     r0,#0xf
000122  01c0              LSLS     r0,r0,#7
000124  4344              MULS     r4,r0,r4
;;;302              break;
000126  e012              B        |L1.334|
;;;303            case 0x60u:
;;;304              MCGOUTClock *= 2560u;
000128  2005              MOVS     r0,#5
00012a  0240              LSLS     r0,r0,#9
00012c  4344              MULS     r4,r0,r4
;;;305              break;
00012e  e00e              B        |L1.334|
;;;306            case 0x80u:
;;;307              MCGOUTClock *= 732u;
000130  20b7              MOVS     r0,#0xb7
000132  0080              LSLS     r0,r0,#2
000134  4344              MULS     r4,r0,r4
;;;308              break;
000136  e00a              B        |L1.334|
;;;309            case 0xA0u:
;;;310              MCGOUTClock *= 1464u;
000138  20b7              MOVS     r0,#0xb7
00013a  00c0              LSLS     r0,r0,#3
00013c  4344              MULS     r4,r0,r4
;;;311              break;
00013e  e006              B        |L1.334|
;;;312            case 0xC0u:
;;;313              MCGOUTClock *= 2197u;
000140  482d              LDR      r0,|L1.504|
000142  4344              MULS     r4,r0,r4
;;;314              break;
000144  e003              B        |L1.334|
;;;315            case 0xE0u:
;;;316              MCGOUTClock *= 2929u;
000146  482d              LDR      r0,|L1.508|
000148  4344              MULS     r4,r0,r4
;;;317              break;
00014a  e000              B        |L1.334|
                  |L1.332|
;;;318            default:
;;;319              break;
00014c  bf00              NOP      
                  |L1.334|
00014e  e038              B        |L1.450|
                  |L1.336|
;;;320          }
;;;321        } else { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;322          /* PLL is selected */
;;;323          Divider = (1u + (MCG->C5 & MCG_C5_PRDIV0_MASK));
000150  4826              LDR      r0,|L1.492|
000152  7900              LDRB     r0,[r0,#4]
000154  06c0              LSLS     r0,r0,#27
000156  0ec0              LSRS     r0,r0,#27
000158  1c45              ADDS     r5,r0,#1
;;;324          MCGOUTClock = (uint32_t)(CPU_XTAL_CLK_HZ / Divider);                     /* Calculate the PLL reference clock */
00015a  4629              MOV      r1,r5
00015c  4825              LDR      r0,|L1.500|
00015e  f7fffffe          BL       __aeabi_uidivmod
000162  4604              MOV      r4,r0
;;;325          Divider = ((MCG->C6 & MCG_C6_VDIV0_MASK) + 24u);
000164  4821              LDR      r0,|L1.492|
000166  7940              LDRB     r0,[r0,#5]
000168  06c0              LSLS     r0,r0,#27
00016a  0ec0              LSRS     r0,r0,#27
00016c  4605              MOV      r5,r0
00016e  3518              ADDS     r5,r5,#0x18
;;;326          MCGOUTClock *= Divider;                       /* Calculate the MCG output clock */
000170  4620              MOV      r0,r4
000172  4368              MULS     r0,r5,r0
000174  4604              MOV      r4,r0
000176  e024              B        |L1.450|
                  |L1.376|
;;;327        } /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;328      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40u) {
000178  481c              LDR      r0,|L1.492|
00017a  7800              LDRB     r0,[r0,#0]
00017c  21c0              MOVS     r1,#0xc0
00017e  4008              ANDS     r0,r0,r1
000180  2840              CMP      r0,#0x40
000182  d115              BNE      |L1.432|
;;;329        /* Internal reference clock is selected */
;;;330        if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u) {
000184  4819              LDR      r0,|L1.492|
000186  7840              LDRB     r0,[r0,#1]
000188  07c0              LSLS     r0,r0,#31
00018a  0fc0              LSRS     r0,r0,#31
00018c  2800              CMP      r0,#0
00018e  d102              BNE      |L1.406|
;;;331          MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                       /* Slow internal reference clock selected */
000190  2401              MOVS     r4,#1
000192  03e4              LSLS     r4,r4,#15
000194  e015              B        |L1.450|
                  |L1.406|
;;;332        } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;333          MCGOUTClock = CPU_INT_FAST_CLK_HZ / (1 << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));  /* Fast internal reference clock selected */
000196  4815              LDR      r0,|L1.492|
000198  7a00              LDRB     r0,[r0,#8]
00019a  220e              MOVS     r2,#0xe
00019c  4010              ANDS     r0,r0,r2
00019e  0842              LSRS     r2,r0,#1
0001a0  2001              MOVS     r0,#1
0001a2  4090              LSLS     r0,r0,r2
0001a4  4601              MOV      r1,r0
0001a6  4816              LDR      r0,|L1.512|
0001a8  f7fffffe          BL       __aeabi_uidivmod
0001ac  4604              MOV      r4,r0
0001ae  e008              B        |L1.450|
                  |L1.432|
;;;334        } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;335      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u) {
0001b0  480e              LDR      r0,|L1.492|
0001b2  7800              LDRB     r0,[r0,#0]
0001b4  21c0              MOVS     r1,#0xc0
0001b6  4008              ANDS     r0,r0,r1
0001b8  2880              CMP      r0,#0x80
0001ba  d101              BNE      |L1.448|
;;;336        /* External reference clock is selected */
;;;337        MCGOUTClock = CPU_XTAL_CLK_HZ;                                           /* System oscillator drives MCG clock */
0001bc  4c0d              LDR      r4,|L1.500|
0001be  e000              B        |L1.450|
                  |L1.448|
;;;338      } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;339        /* Reserved value */
;;;340        return;
;;;341      } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;342      SystemCoreClock = (MCGOUTClock / (1u + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
;;;343    }
0001c0  bd70              POP      {r4-r6,pc}
                  |L1.450|
0001c2  4807              LDR      r0,|L1.480|
0001c4  3040              ADDS     r0,r0,#0x40           ;342
0001c6  6840              LDR      r0,[r0,#4]            ;342
0001c8  0f00              LSRS     r0,r0,#28             ;342
0001ca  1c41              ADDS     r1,r0,#1              ;342
0001cc  4620              MOV      r0,r4                 ;342
0001ce  f7fffffe          BL       __aeabi_uidivmod
0001d2  490c              LDR      r1,|L1.516|
0001d4  6008              STR      r0,[r1,#0]            ;342  ; SystemCoreClock
0001d6  bf00              NOP      
0001d8  e7f2              B        |L1.448|
                          ENDP

0001da  0000              DCW      0x0000
                  |L1.476|
                          DCD      0x40048100
                  |L1.480|
                          DCD      0x40048000
                  |L1.484|
                          DCD      0x40049040
                  |L1.488|
                          DCD      0xfefff8ff
                  |L1.492|
                          DCD      0x40064000
                  |L1.496|
                          DCD      0x40065000
                  |L1.500|
                          DCD      0x007a1200
                  |L1.504|
                          DCD      0x00000895
                  |L1.508|
                          DCD      0x00000b71
                  |L1.512|
                          DCD      0x003d0900
                  |L1.516|
                          DCD      SystemCoreClock

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x02dc6c00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L16.24|
                  |L16.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L16.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L16.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\cpu\\CMSIS\\Source\\system_MKL26Z4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL26Z4_c_5d646a67____REV16|
#line 383 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.0-Beta4\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_system_MKL26Z4_c_5d646a67____REV16| PROC
#line 384

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL26Z4_c_5d646a67____REVSH|
#line 397
|__asm___16_system_MKL26Z4_c_5d646a67____REVSH| PROC
#line 398

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
