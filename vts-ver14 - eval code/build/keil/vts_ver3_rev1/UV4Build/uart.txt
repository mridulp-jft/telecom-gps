; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\uart.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\uart.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -I..\..\..\..\inc -I"D:\RecoveredHP\mridul.eecs@gmail.com\vts-ver14 - testing code\build\keil\vts_ver3_rev1\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0-Beta4\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.11.0\Device\Include -D__UVISION_VERSION=518 -D_RTE_ -DMKL26Z128xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\uart.crf ..\..\..\src\drivers\uart\uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;31      */
;;;32     void uart_init (UART_MemMapPtr uartch, int sysclk, int baud)
000000  b5f8              PUSH     {r3-r7,lr}
;;;33     {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;34         register uint16 sbr;
;;;35         uint8 temp;
;;;36      
;;;37           if (uartch == UART1_BASE_PTR)
000008  48b5              LDR      r0,|L1.736|
00000a  4284              CMP      r4,r0
00000c  d106              BNE      |L1.28|
;;;38             SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
00000e  48b5              LDR      r0,|L1.740|
000010  6b40              LDR      r0,[r0,#0x34]
000012  14e1              ASRS     r1,r4,#19
000014  4308              ORRS     r0,r0,r1
000016  49b3              LDR      r1,|L1.740|
000018  6348              STR      r0,[r1,#0x34]
00001a  e006              B        |L1.42|
                  |L1.28|
;;;39           else
;;;40         	SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
00001c  48b1              LDR      r0,|L1.740|
00001e  6b40              LDR      r0,[r0,#0x34]
000020  2101              MOVS     r1,#1
000022  0309              LSLS     r1,r1,#12
000024  4308              ORRS     r0,r0,r1
000026  49af              LDR      r1,|L1.740|
000028  6348              STR      r0,[r1,#0x34]
                  |L1.42|
;;;41           /* Make sure that the transmitter and receiver are disabled while we 
;;;42            * change settings.
;;;43            */
;;;44     			
;;;45     				NVIC_SetPriority(UART1_IRQn, 1);
00002a  2101              MOVS     r1,#1
00002c  200d              MOVS     r0,#0xd
00002e  f7fffffe          BL       NVIC_SetPriority
;;;46     
;;;47     			
;;;48           UART_C2_REG(uartch) &= ~(UART_C2_TE_MASK
000032  78e0              LDRB     r0,[r4,#3]
000034  210c              MOVS     r1,#0xc
000036  4388              BICS     r0,r0,r1
000038  70e0              STRB     r0,[r4,#3]
;;;49     				| UART_C2_RE_MASK );
;;;50     			
;;;51     				      /* Configure the uart for 8-bit mode, no parity */
;;;52           UART_C1_REG(uartch) = 0;	/* We need all default settings, so entire register is cleared */
00003a  2000              MOVS     r0,#0
00003c  70a0              STRB     r0,[r4,#2]
;;;53         
;;;54           /* Calculate baud settings */
;;;55           sbr = (uint16)((sysclk*1000)/(baud * 16));
00003e  0139              LSLS     r1,r7,#4
000040  227d              MOVS     r2,#0x7d
000042  00d2              LSLS     r2,r2,#3
000044  4372              MULS     r2,r6,r2
000046  4610              MOV      r0,r2
000048  f7fffffe          BL       __aeabi_idivmod
00004c  b285              UXTH     r5,r0
;;;56     	//		sbr = sy/baud(OSR+1);
;;;57     			//sbr = 
;;;58             
;;;59           /* Save off the current value of the uartx_BDH except for the SBR field */
;;;60           temp = UART_BDH_REG(uartch) & ~(UART_BDH_SBR(0x1F));
00004e  7820              LDRB     r0,[r4,#0]
000050  0941              LSRS     r1,r0,#5
000052  0149              LSLS     r1,r1,#5
000054  9100              STR      r1,[sp,#0]
;;;61         
;;;62           UART_BDH_REG(uartch) = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
000056  201f              MOVS     r0,#0x1f
000058  0200              LSLS     r0,r0,#8
00005a  4028              ANDS     r0,r0,r5
00005c  1200              ASRS     r0,r0,#8
00005e  9900              LDR      r1,[sp,#0]
000060  4308              ORRS     r0,r0,r1
000062  7020              STRB     r0,[r4,#0]
;;;63           UART_BDL_REG(uartch) = (uint8)(sbr & UART_BDL_SBR_MASK);
000064  7065              STRB     r5,[r4,#1]
;;;64     			
;;;65     			
;;;66     			UART_C2_REG(uartch) |= UART_C2_RIE_MASK;			//newly added
000066  78e0              LDRB     r0,[r4,#3]
000068  2120              MOVS     r1,#0x20
00006a  4308              ORRS     r0,r0,r1
00006c  70e0              STRB     r0,[r4,#3]
;;;67     			
;;;68     
;;;69     		
;;;70     			enable_irq(13);	
00006e  200d              MOVS     r0,#0xd
000070  2800              CMP      r0,#0
000072  db05              BLT      |L1.128|
000074  06c2              LSLS     r2,r0,#27
000076  0ed2              LSRS     r2,r2,#27
000078  2101              MOVS     r1,#1
00007a  4091              LSLS     r1,r1,r2
00007c  4a9a              LDR      r2,|L1.744|
00007e  6011              STR      r1,[r2,#0]
                  |L1.128|
000080  bf00              NOP      
;;;71     
;;;72     			EnableInterrupts;		//newly added
000082  b662              CPSIE    i
;;;73          		
;;;74     
;;;75     
;;;76     
;;;77     
;;;78           /* Enable receiver and transmitter */
;;;79           UART_C2_REG(uartch) |= (UART_C2_TE_MASK
000084  78e0              LDRB     r0,[r4,#3]
000086  210c              MOVS     r1,#0xc
000088  4308              ORRS     r0,r0,r1
00008a  70e0              STRB     r0,[r4,#3]
;;;80     	    		  | UART_C2_RE_MASK );
;;;81     		
;;;82     
;;;83     
;;;84     }
00008c  bdf8              POP      {r3-r7,pc}
;;;85     
                          ENDP

                  UART1_IRQHandler PROC
;;;86     void UART1_IRQHandler(void)
00008e  4897              LDR      r0,|L1.748|
;;;87     {int32 counter=19999;
;;;88     
;;;89     		//	do
;;;90     				{
;;;91     			if( (UART_S1_REG(UART1_BASE_PTR) & UART_S1_RDRF_MASK))	
000090  4993              LDR      r1,|L1.736|
000092  7909              LDRB     r1,[r1,#4]
000094  2220              MOVS     r2,#0x20
000096  4011              ANDS     r1,r1,r2
000098  2900              CMP      r1,#0
00009a  d00a              BEQ      |L1.178|
;;;92     			{uart_string_gsm[k2]=UART_D_REG(UART1_BASE_PTR);k2++;
00009c  4990              LDR      r1,|L1.736|
00009e  79c9              LDRB     r1,[r1,#7]
0000a0  4a93              LDR      r2,|L1.752|
0000a2  4b94              LDR      r3,|L1.756|
0000a4  681b              LDR      r3,[r3,#0]  ; k2
0000a6  54d1              STRB     r1,[r2,r3]
0000a8  4992              LDR      r1,|L1.756|
0000aa  6809              LDR      r1,[r1,#0]  ; k2
0000ac  1c49              ADDS     r1,r1,#1
0000ae  4a91              LDR      r2,|L1.756|
0000b0  6011              STR      r1,[r2,#0]  ; k2
                  |L1.178|
;;;93     			//	counter=19999;
;;;94     		//	if(k2>4990)k2=0;
;;;95     			}
;;;96     //				else{counter--;
;;;97     //						}
;;;98     			}//`while((UART_S1_REG(UART1_BASE_PTR) & UART_S1_RDRF_MASK)  || (counter>1));
;;;99     			
;;;100    			
;;;101    }
0000b2  4770              BX       lr
;;;102    
                          ENDP

                  UART2_IRQHandler PROC
;;;103    void UART2_IRQHandler(void)
0000b4  4770              BX       lr
;;;104    {
;;;105    //k=0;l=999999;
;;;106    //			do{
;;;107    //			if( uart_getchar_present (UART2_BASE_PTR))	
;;;108    //			{uart_string_gps[k]=UART_D_REG(UART2_BASE_PTR);k++;l=9999;if(k>298){k=0;}}
;;;109    //				else{
;;;110    //							l--;if(l==10){}
;;;111    //						}
;;;112    //			}while(!((strstr(uart_string_gps, "OK\r\n"))
;;;113    //							||(strstr(uart_string_gps, "ERROR\r\n"))  || (l<=0)
;;;114    //				        	||(strstr(uart_string_gps, "ERROR:"))
;;;115    //							));
;;;116    //printf("uart_string_gps -> %s",uart_string_gps);
;;;117    }
;;;118    
                          ENDP

                  uart_getchar PROC
;;;131     */
;;;132    char uart_getchar (UART_MemMapPtr channel)
0000b6  4601              MOV      r1,r0
;;;133    {int timeouttt=199;
0000b8  22c7              MOVS     r2,#0xc7
;;;134          /* Wait until character has been received */
;;;135          while (!((UART_S1_REG(channel) & UART_S1_RDRF_MASK)    ));//{timeouttt--;}
0000ba  bf00              NOP      
                  |L1.188|
0000bc  7908              LDRB     r0,[r1,#4]
0000be  2320              MOVS     r3,#0x20
0000c0  4018              ANDS     r0,r0,r3
0000c2  2800              CMP      r0,#0
0000c4  d0fa              BEQ      |L1.188|
;;;136     //   ||   (timeouttt < 1 ) 
;;;137          /* Return the 8-bit data from the receiver */
;;;138          return UART_D_REG(channel);
0000c6  79c8              LDRB     r0,[r1,#7]
;;;139    }
0000c8  4770              BX       lr
;;;140    /********************************************************************/
                          ENDP

                  uart_putchar PROC
;;;147     */ 
;;;148    void uart_putchar (UART_MemMapPtr channel, char ch)
0000ca  b510              PUSH     {r4,lr}
;;;149    {int to=19999;
0000cc  4a87              LDR      r2,|L1.748|
;;;150          /* Wait until space is available in the FIFO */
;;;151          while(!((UART_S1_REG(channel) & UART_S1_TDRE_MASK)    ||  ( to <= 1 ))){to--;}
0000ce  e000              B        |L1.210|
                  |L1.208|
0000d0  1e52              SUBS     r2,r2,#1
                  |L1.210|
0000d2  7903              LDRB     r3,[r0,#4]
0000d4  2480              MOVS     r4,#0x80
0000d6  4023              ANDS     r3,r3,r4
0000d8  2b00              CMP      r3,#0
0000da  d101              BNE      |L1.224|
0000dc  2a01              CMP      r2,#1
0000de  dcf7              BGT      |L1.208|
                  |L1.224|
;;;152        
;;;153          /* Send the character */
;;;154          UART_D_REG(channel) = (uint8)ch;
0000e0  71c1              STRB     r1,[r0,#7]
;;;155        
;;;156     }
0000e2  bd10              POP      {r4,pc}
;;;157    /********************************************************************/
                          ENDP

                  uart_getchar_present PROC
;;;167     */
;;;168    int uart_getchar_present (UART_MemMapPtr channel)
0000e4  4601              MOV      r1,r0
;;;169    {
;;;170        return (UART_S1_REG(channel) & UART_S1_RDRF_MASK);
0000e6  7908              LDRB     r0,[r1,#4]
0000e8  2220              MOVS     r2,#0x20
0000ea  4010              ANDS     r0,r0,r2
;;;171    }
0000ec  4770              BX       lr
;;;172    /********************************************************************/
                          ENDP

                  uart0_init PROC
;;;190     */
;;;191    void uart0_init (UART0_MemMapPtr uartch, int sysclk, int baud)
0000ee  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;192    {
0000f0  b086              SUB      sp,sp,#0x18
;;;193        uint8 i;
;;;194        uint32 calculated_baud = 0;
0000f2  bf00              NOP      
;;;195        uint32 baud_diff = 0;
0000f4  2000              MOVS     r0,#0
0000f6  9005              STR      r0,[sp,#0x14]
;;;196        uint32 osr_val = 0;
0000f8  9004              STR      r0,[sp,#0x10]
;;;197        uint32 sbr_val, uart0clk;
;;;198        uint32 baud_rate;
;;;199        uint32 reg_temp = 0;
0000fa  2500              MOVS     r5,#0
;;;200        uint32 temp = 0;
0000fc  9001              STR      r0,[sp,#4]
;;;201        
;;;202        SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
0000fe  4879              LDR      r0,|L1.740|
000100  6b40              LDR      r0,[r0,#0x34]
000102  2101              MOVS     r1,#1
000104  0289              LSLS     r1,r1,#10
000106  4308              ORRS     r0,r0,r1
000108  4976              LDR      r1,|L1.740|
00010a  6348              STR      r0,[r1,#0x34]
;;;203        
;;;204        // Disable UART0 before changing registers
;;;205        UART0_C2 &= ~(UART0_C2_TE_MASK | UART0_C2_RE_MASK);
00010c  487a              LDR      r0,|L1.760|
00010e  78c0              LDRB     r0,[r0,#3]
000110  210c              MOVS     r1,#0xc
000112  4388              BICS     r0,r0,r1
000114  4978              LDR      r1,|L1.760|
000116  70c8              STRB     r0,[r1,#3]
;;;206      
;;;207        // Verify that a valid clock value has been passed to the function 
;;;208        if ((sysclk > 50000) || (sysclk < 32))
000118  4978              LDR      r1,|L1.764|
00011a  9807              LDR      r0,[sp,#0x1c]
00011c  4288              CMP      r0,r1
00011e  dc02              BGT      |L1.294|
000120  9807              LDR      r0,[sp,#0x1c]
000122  2820              CMP      r0,#0x20
000124  da0c              BGE      |L1.320|
                  |L1.294|
;;;209        {
;;;210            sysclk = 0;
000126  bf00              NOP      
;;;211            reg_temp = SIM_SOPT2;
000128  486e              LDR      r0,|L1.740|
00012a  6845              LDR      r5,[r0,#4]
;;;212            reg_temp &= ~SIM_SOPT2_UART0SRC_MASK;
00012c  2103              MOVS     r1,#3
00012e  0689              LSLS     r1,r1,#26
000130  4628              MOV      r0,r5
000132  4388              BICS     r0,r0,r1
000134  4605              MOV      r5,r0
;;;213            reg_temp |= SIM_SOPT2_UART0SRC(0);
000136  bf00              NOP      
;;;214            SIM_SOPT2 = reg_temp;
000138  486a              LDR      r0,|L1.740|
00013a  6045              STR      r5,[r0,#4]
;;;215    			
;;;216    			  // Enter inifinite loop because the 
;;;217    			  // the desired system clock value is 
;;;218    			  // invalid!!
;;;219    			  while(1)
00013c  bf00              NOP      
                  |L1.318|
00013e  e7fe              B        |L1.318|
                  |L1.320|
;;;220    				{}
;;;221        }
;;;222        
;;;223        // Verify that a valid value has been passed to TERM_PORT_NUM and update
;;;224        // uart0_clk_hz accordingly.  Write 0 to TERM_PORT_NUM if an invalid 
;;;225        // value has been passed.  
;;;226        if (TERM_PORT_NUM != 0)
;;;227        {
;;;228            reg_temp = SIM_SOPT2;
;;;229            reg_temp &= ~SIM_SOPT2_UART0SRC_MASK;
;;;230            reg_temp |= SIM_SOPT2_UART0SRC(0);
;;;231            SIM_SOPT2 = reg_temp;
;;;232    			
;;;233    			  // Enter inifinite loop because the 
;;;234    			  // the desired terminal port number 
;;;235    			  // invalid!!
;;;236    			  while(1)
;;;237    				{}
;;;238        }
;;;239        
;;;240        
;;;241        
;;;242        // Initialize baud rate
;;;243        baud_rate = baud;
000140  9c08              LDR      r4,[sp,#0x20]
;;;244        
;;;245        // Change units to Hz
;;;246        uart0clk = sysclk * 1000;
000142  217d              MOVS     r1,#0x7d
000144  00c9              LSLS     r1,r1,#3
000146  9807              LDR      r0,[sp,#0x1c]
000148  4348              MULS     r0,r1,r0
00014a  9002              STR      r0,[sp,#8]
;;;247        // Calculate the first baud rate using the lowest OSR value possible.  
;;;248        i = 4;
00014c  2604              MOVS     r6,#4
;;;249        sbr_val = (uint32)(uart0clk/(baud_rate * i));
00014e  4620              MOV      r0,r4
000150  4370              MULS     r0,r6,r0
000152  4601              MOV      r1,r0
000154  9802              LDR      r0,[sp,#8]
000156  f7fffffe          BL       __aeabi_uidivmod
00015a  9003              STR      r0,[sp,#0xc]
;;;250        calculated_baud = (uart0clk / (i * sbr_val));
00015c  9803              LDR      r0,[sp,#0xc]
00015e  4370              MULS     r0,r6,r0
000160  4601              MOV      r1,r0
000162  9802              LDR      r0,[sp,#8]
000164  f7fffffe          BL       __aeabi_uidivmod
000168  4607              MOV      r7,r0
;;;251            
;;;252        if (calculated_baud > baud_rate)
00016a  42a7              CMP      r7,r4
00016c  d902              BLS      |L1.372|
;;;253            baud_diff = calculated_baud - baud_rate;
00016e  1b38              SUBS     r0,r7,r4
000170  9005              STR      r0,[sp,#0x14]
000172  e001              B        |L1.376|
                  |L1.372|
;;;254        else
;;;255            baud_diff = baud_rate - calculated_baud;
000174  1be0              SUBS     r0,r4,r7
000176  9005              STR      r0,[sp,#0x14]
                  |L1.376|
;;;256        
;;;257        osr_val = i;
000178  9604              STR      r6,[sp,#0x10]
;;;258            
;;;259        // Select the best OSR value
;;;260        for (i = 5; i <= 32; i++)
00017a  2605              MOVS     r6,#5
00017c  e01d              B        |L1.442|
                  |L1.382|
;;;261        {
;;;262            sbr_val = (uint32)(uart0clk/(baud_rate * i));
00017e  4620              MOV      r0,r4
000180  4370              MULS     r0,r6,r0
000182  4601              MOV      r1,r0
000184  9802              LDR      r0,[sp,#8]
000186  f7fffffe          BL       __aeabi_uidivmod
00018a  9003              STR      r0,[sp,#0xc]
;;;263            calculated_baud = (uart0clk / (i * sbr_val));
00018c  9803              LDR      r0,[sp,#0xc]
00018e  4370              MULS     r0,r6,r0
000190  4601              MOV      r1,r0
000192  9802              LDR      r0,[sp,#8]
000194  f7fffffe          BL       __aeabi_uidivmod
000198  4607              MOV      r7,r0
;;;264            
;;;265            if (calculated_baud > baud_rate)
00019a  42a7              CMP      r7,r4
00019c  d902              BLS      |L1.420|
;;;266                temp = calculated_baud - baud_rate;
00019e  1b38              SUBS     r0,r7,r4
0001a0  9001              STR      r0,[sp,#4]
0001a2  e001              B        |L1.424|
                  |L1.420|
;;;267            else
;;;268                temp = baud_rate - calculated_baud;
0001a4  1be0              SUBS     r0,r4,r7
0001a6  9001              STR      r0,[sp,#4]
                  |L1.424|
;;;269            
;;;270            if (temp <= baud_diff)
0001a8  9905              LDR      r1,[sp,#0x14]
0001aa  9801              LDR      r0,[sp,#4]
0001ac  4288              CMP      r0,r1
0001ae  d802              BHI      |L1.438|
;;;271            {
;;;272                baud_diff = temp;
0001b0  9801              LDR      r0,[sp,#4]
0001b2  9005              STR      r0,[sp,#0x14]
;;;273                osr_val = i; 
0001b4  9604              STR      r6,[sp,#0x10]
                  |L1.438|
0001b6  1c70              ADDS     r0,r6,#1              ;260
0001b8  b2c6              UXTB     r6,r0                 ;260
                  |L1.442|
0001ba  2e20              CMP      r6,#0x20              ;260
0001bc  dddf              BLE      |L1.382|
;;;274            }
;;;275        }
;;;276        
;;;277        if (baud_diff < ((baud_rate / 100) * 3))
0001be  2164              MOVS     r1,#0x64
0001c0  4620              MOV      r0,r4
0001c2  f7fffffe          BL       __aeabi_uidivmod
0001c6  0041              LSLS     r1,r0,#1
0001c8  1841              ADDS     r1,r0,r1
0001ca  9805              LDR      r0,[sp,#0x14]
0001cc  4281              CMP      r1,r0
0001ce  d935              BLS      |L1.572|
;;;278        {
;;;279            // If the OSR is between 4x and 8x then both
;;;280            // edge sampling MUST be turned on.  
;;;281            if ((osr_val >3) && (osr_val < 9))
0001d0  9804              LDR      r0,[sp,#0x10]
0001d2  2803              CMP      r0,#3
0001d4  d908              BLS      |L1.488|
0001d6  9804              LDR      r0,[sp,#0x10]
0001d8  2809              CMP      r0,#9
0001da  d205              BCS      |L1.488|
;;;282                UART0_C5|= UART0_C5_BOTHEDGE_MASK;
0001dc  4846              LDR      r0,|L1.760|
0001de  7ac0              LDRB     r0,[r0,#0xb]
0001e0  2102              MOVS     r1,#2
0001e2  4308              ORRS     r0,r0,r1
0001e4  4944              LDR      r1,|L1.760|
0001e6  72c8              STRB     r0,[r1,#0xb]
                  |L1.488|
;;;283            
;;;284            // Setup OSR value 
;;;285            reg_temp = UART0_C4;
0001e8  4843              LDR      r0,|L1.760|
0001ea  7a85              LDRB     r5,[r0,#0xa]
;;;286            reg_temp &= ~UART0_C4_OSR_MASK;
0001ec  096d              LSRS     r5,r5,#5
0001ee  016d              LSLS     r5,r5,#5
;;;287            reg_temp |= UART0_C4_OSR(osr_val-1);
0001f0  9804              LDR      r0,[sp,#0x10]
0001f2  1e40              SUBS     r0,r0,#1
0001f4  06c0              LSLS     r0,r0,#27
0001f6  0ec0              LSRS     r0,r0,#27
0001f8  4305              ORRS     r5,r5,r0
;;;288        
;;;289            // Write reg_temp to C4 register
;;;290            UART0_C4 = reg_temp;
0001fa  483f              LDR      r0,|L1.760|
0001fc  7285              STRB     r5,[r0,#0xa]
;;;291            
;;;292            reg_temp = (reg_temp & UART0_C4_OSR_MASK) + 1;
0001fe  06e8              LSLS     r0,r5,#27
000200  0ec0              LSRS     r0,r0,#27
000202  1c45              ADDS     r5,r0,#1
;;;293            sbr_val = (uint32)((uart0clk)/(baud_rate * (reg_temp)));
000204  4620              MOV      r0,r4
000206  4368              MULS     r0,r5,r0
000208  4601              MOV      r1,r0
00020a  9802              LDR      r0,[sp,#8]
00020c  f7fffffe          BL       __aeabi_uidivmod
000210  9003              STR      r0,[sp,#0xc]
;;;294            
;;;295             /* Save off the current value of the uartx_BDH except for the SBR field */
;;;296            reg_temp = UART0_BDH & ~(UART0_BDH_SBR(0x1F));
000212  4839              LDR      r0,|L1.760|
000214  7800              LDRB     r0,[r0,#0]
000216  0945              LSRS     r5,r0,#5
000218  016d              LSLS     r5,r5,#5
;;;297       
;;;298            UART0_BDH = reg_temp |  UART0_BDH_SBR(((sbr_val & 0x1F00) >> 8));
00021a  211f              MOVS     r1,#0x1f
00021c  0209              LSLS     r1,r1,#8
00021e  9803              LDR      r0,[sp,#0xc]
000220  4008              ANDS     r0,r0,r1
000222  0a00              LSRS     r0,r0,#8
000224  4328              ORRS     r0,r0,r5
000226  4934              LDR      r1,|L1.760|
000228  7008              STRB     r0,[r1,#0]
;;;299            UART0_BDL = (uint8)(sbr_val & UART0_BDL_SBR_MASK);
00022a  9803              LDR      r0,[sp,#0xc]
00022c  7048              STRB     r0,[r1,#1]
;;;300            
;;;301            /* Enable receiver and transmitter */
;;;302            UART0_C2 |= (UART0_C2_TE_MASK
00022e  4608              MOV      r0,r1
000230  78c0              LDRB     r0,[r0,#3]
000232  210c              MOVS     r1,#0xc
000234  4308              ORRS     r0,r0,r1
000236  4930              LDR      r1,|L1.760|
000238  70c8              STRB     r0,[r1,#3]
00023a  e001              B        |L1.576|
                  |L1.572|
;;;303                        | UART0_C2_RE_MASK );
;;;304        }
;;;305        else
;;;306        {
;;;307            // Unacceptable baud rate difference
;;;308            // More than 3% difference!!
;;;309            // Enter infinite loop!
;;;310            while(1)
00023c  bf00              NOP      
                  |L1.574|
00023e  e7fe              B        |L1.574|
                  |L1.576|
;;;311    	{}
;;;312        }					
;;;313        
;;;314    }
000240  b009              ADD      sp,sp,#0x24
000242  bdf0              POP      {r4-r7,pc}
;;;315    /********************************************************************/
                          ENDP

                  uart0_getchar PROC
;;;324     */
;;;325    char uart0_getchar (UART0_MemMapPtr channel)
000244  4601              MOV      r1,r0
;;;326    {
;;;327          /* Wait until character has been received */
;;;328          while (!(UART0_S1_REG(channel) & UART0_S1_RDRF_MASK));
000246  bf00              NOP      
                  |L1.584|
000248  7908              LDRB     r0,[r1,#4]
00024a  2220              MOVS     r2,#0x20
00024c  4010              ANDS     r0,r0,r2
00024e  2800              CMP      r0,#0
000250  d0fa              BEQ      |L1.584|
;;;329        
;;;330          /* Return the 8-bit data from the receiver */
;;;331          return UART0_D_REG(channel);
000252  79c8              LDRB     r0,[r1,#7]
;;;332    }
000254  4770              BX       lr
;;;333    /********************************************************************/
                          ENDP

                  uart0_putchar PROC
;;;340     */ 
;;;341    void uart0_putchar (UART0_MemMapPtr channel, char ch)
000256  bf00              NOP      
                  |L1.600|
;;;342    {
;;;343          /* Wait until space is available in the FIFO */
;;;344          while(!(UART0_S1_REG(channel) & UART0_S1_TDRE_MASK));
000258  7902              LDRB     r2,[r0,#4]
00025a  2380              MOVS     r3,#0x80
00025c  401a              ANDS     r2,r2,r3
00025e  2a00              CMP      r2,#0
000260  d0fa              BEQ      |L1.600|
;;;345        
;;;346          /* Send the character */
;;;347          UART0_D_REG(channel) = (uint8)ch;
000262  71c1              STRB     r1,[r0,#7]
;;;348        
;;;349     }
000264  4770              BX       lr
;;;350    /********************************************************************/
                          ENDP

                  uart0_getchar_present PROC
;;;360     */
;;;361    int uart0_getchar_present (UART0_MemMapPtr channel)
000266  4601              MOV      r1,r0
;;;362    {
;;;363        return (UART0_S1_REG(channel) & UART0_S1_RDRF_MASK);
000268  7908              LDRB     r0,[r1,#4]
00026a  2220              MOVS     r2,#0x20
00026c  4010              ANDS     r0,r0,r2
;;;364    }
00026e  4770              BX       lr
;;;365    /********************************************************************/
                          ENDP

                  NVIC_SetPriority PROC
;;;864     */
;;;865    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000270  b510              PUSH     {r4,lr}
;;;866    {
;;;867      if ((int32_t)(IRQn) >= 0)
000272  2800              CMP      r0,#0
000274  db19              BLT      |L1.682|
;;;868      {
;;;869        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
000276  4a1c              LDR      r2,|L1.744|
000278  2303              MOVS     r3,#3
00027a  021b              LSLS     r3,r3,#8
00027c  18d2              ADDS     r2,r2,r3
00027e  0883              LSRS     r3,r0,#2
000280  009b              LSLS     r3,r3,#2
000282  58d2              LDR      r2,[r2,r3]
000284  0783              LSLS     r3,r0,#30
000286  0edc              LSRS     r4,r3,#27
000288  23ff              MOVS     r3,#0xff
00028a  40a3              LSLS     r3,r3,r4
00028c  439a              BICS     r2,r2,r3
00028e  078b              LSLS     r3,r1,#30
000290  0e1b              LSRS     r3,r3,#24
000292  0784              LSLS     r4,r0,#30
000294  0ee4              LSRS     r4,r4,#27
000296  40a3              LSLS     r3,r3,r4
000298  431a              ORRS     r2,r2,r3
00029a  4b13              LDR      r3,|L1.744|
00029c  2403              MOVS     r4,#3
00029e  0224              LSLS     r4,r4,#8
0002a0  191b              ADDS     r3,r3,r4
0002a2  0884              LSRS     r4,r0,#2
0002a4  00a4              LSLS     r4,r4,#2
0002a6  511a              STR      r2,[r3,r4]
0002a8  e018              B        |L1.732|
                  |L1.682|
;;;870           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;871      }
;;;872      else
;;;873      {
;;;874        SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
0002aa  4a15              LDR      r2,|L1.768|
0002ac  0703              LSLS     r3,r0,#28
0002ae  0f1b              LSRS     r3,r3,#28
0002b0  3b08              SUBS     r3,r3,#8
0002b2  089b              LSRS     r3,r3,#2
0002b4  009b              LSLS     r3,r3,#2
0002b6  58d2              LDR      r2,[r2,r3]
0002b8  0783              LSLS     r3,r0,#30
0002ba  0edc              LSRS     r4,r3,#27
0002bc  23ff              MOVS     r3,#0xff
0002be  40a3              LSLS     r3,r3,r4
0002c0  439a              BICS     r2,r2,r3
0002c2  078b              LSLS     r3,r1,#30
0002c4  0e1b              LSRS     r3,r3,#24
0002c6  0784              LSLS     r4,r0,#30
0002c8  0ee4              LSRS     r4,r4,#27
0002ca  40a3              LSLS     r3,r3,r4
0002cc  431a              ORRS     r2,r2,r3
0002ce  4b0c              LDR      r3,|L1.768|
0002d0  0704              LSLS     r4,r0,#28
0002d2  0f24              LSRS     r4,r4,#28
0002d4  3c08              SUBS     r4,r4,#8
0002d6  08a4              LSRS     r4,r4,#2
0002d8  00a4              LSLS     r4,r4,#2
0002da  511a              STR      r2,[r3,r4]
                  |L1.732|
;;;875           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;876      }
;;;877    }
0002dc  bd10              POP      {r4,pc}
;;;878    
                          ENDP

0002de  0000              DCW      0x0000
                  |L1.736|
                          DCD      0x4006b000
                  |L1.740|
                          DCD      0x40048000
                  |L1.744|
                          DCD      0xe000e100
                  |L1.748|
                          DCD      0x00004e1f
                  |L1.752|
                          DCD      uart_string_gsm
                  |L1.756|
                          DCD      ||k2||
                  |L1.760|
                          DCD      0x4006a000
                  |L1.764|
                          DCD      0x0000c350
                  |L1.768|
                          DCD      0xe000ed1c

                          AREA ||.data||, DATA, ALIGN=2

                  test
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\drivers\\uart\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f64bdfb6____REV16|
#line 383 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.0-Beta4\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f64bdfb6____REV16| PROC
#line 384

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f64bdfb6____REVSH|
#line 397
|__asm___6_uart_c_f64bdfb6____REVSH| PROC
#line 398

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
