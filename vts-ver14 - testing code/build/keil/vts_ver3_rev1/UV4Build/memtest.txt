; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\memtest.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\memtest.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -I..\..\..\..\inc -I"E:\bitbuck\gps-trackr\Software\vts-ver14 - testing code\build\keil\vts_ver3_rev1\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0-Beta4\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.11.0\Device\Include -D__UVISION_VERSION=518 -D_RTE_ -DMKL26Z128xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\memtest.crf ..\..\..\src\common\memtest.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  memTestDataBus PROC
;;;36     datum
;;;37     memTestDataBus(volatile datum * address)
000000  4602              MOV      r2,r0
;;;38     {
;;;39         datum pattern;
;;;40     
;;;41     
;;;42         /*
;;;43          * Perform a walking 1's test at the given address.
;;;44          */
;;;45         for (pattern = 1; pattern != 0; pattern <<= 1)
000002  2101              MOVS     r1,#1
000004  e006              B        |L1.20|
                  |L1.6|
;;;46         {
;;;47             /*
;;;48              * Write the test pattern.
;;;49              */
;;;50             *address = pattern;
000006  6011              STR      r1,[r2,#0]
;;;51     
;;;52             /*
;;;53              * Read it back (immediately is okay for this test).
;;;54              */
;;;55             if (*address != pattern) 
000008  6810              LDR      r0,[r2,#0]
00000a  4288              CMP      r0,r1
00000c  d001              BEQ      |L1.18|
;;;56             {
;;;57                 return (pattern);
00000e  4608              MOV      r0,r1
                  |L1.16|
;;;58             }
;;;59         }
;;;60     
;;;61         return (0);
;;;62     
;;;63     }   /* memTestDataBus() */
000010  4770              BX       lr
                  |L1.18|
000012  0049              LSLS     r1,r1,#1              ;45
                  |L1.20|
000014  2900              CMP      r1,#0                 ;45
000016  d1f6              BNE      |L1.6|
000018  2000              MOVS     r0,#0                 ;61
00001a  e7f9              B        |L1.16|
;;;64     
                          ENDP

                  memTestAddressBus PROC
;;;91     datum * 
;;;92     memTestAddressBus(volatile datum * baseAddress, unsigned long nBytes)
00001c  b5f0              PUSH     {r4-r7,lr}
;;;93     {
00001e  4602              MOV      r2,r0
000020  460f              MOV      r7,r1
;;;94         unsigned long addressMask = (nBytes/sizeof(datum) - 1);
000022  08b8              LSRS     r0,r7,#2
000024  1e45              SUBS     r5,r0,#1
;;;95         unsigned long offset;
;;;96         unsigned long testOffset;
;;;97     
;;;98         datum pattern     = (datum) 0xAAAAAAAA;
000026  4c38              LDR      r4,|L1.264|
;;;99         datum antipattern = (datum) 0x55555555;
000028  0866              LSRS     r6,r4,#1
;;;100    
;;;101    
;;;102        /*
;;;103         * Write the default pattern at each of the power-of-two offsets.
;;;104         */
;;;105        for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
00002a  2101              MOVS     r1,#1
00002c  e002              B        |L1.52|
                  |L1.46|
;;;106        {
;;;107            baseAddress[offset] = pattern;
00002e  0088              LSLS     r0,r1,#2
000030  5014              STR      r4,[r2,r0]
000032  0049              LSLS     r1,r1,#1              ;105
                  |L1.52|
000034  4608              MOV      r0,r1                 ;105
000036  4028              ANDS     r0,r0,r5              ;105
000038  2800              CMP      r0,#0                 ;105
00003a  d1f8              BNE      |L1.46|
;;;108        }
;;;109    
;;;110        /* 
;;;111         * Check for address bits stuck high.
;;;112         */
;;;113        testOffset = 0;
00003c  2300              MOVS     r3,#0
;;;114        baseAddress[testOffset] = antipattern;
00003e  0098              LSLS     r0,r3,#2
000040  5016              STR      r6,[r2,r0]
;;;115    
;;;116        for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
000042  2101              MOVS     r1,#1
000044  e007              B        |L1.86|
                  |L1.70|
;;;117        {
;;;118            if (baseAddress[offset] != pattern)
000046  0088              LSLS     r0,r1,#2
000048  5810              LDR      r0,[r2,r0]
00004a  42a0              CMP      r0,r4
00004c  d002              BEQ      |L1.84|
;;;119            {
;;;120                return ((datum *) &baseAddress[offset]);
00004e  0088              LSLS     r0,r1,#2
000050  1880              ADDS     r0,r0,r2
                  |L1.82|
;;;121            }
;;;122        }
;;;123    
;;;124        baseAddress[testOffset] = pattern;
;;;125    
;;;126        /*
;;;127         * Check for address bits stuck low or shorted.
;;;128         */
;;;129        for (testOffset = 1; (testOffset & addressMask) != 0; testOffset <<= 1)
;;;130        {
;;;131            baseAddress[testOffset] = antipattern;
;;;132    
;;;133    		if (baseAddress[0] != pattern)
;;;134    		{
;;;135    			return ((datum *) &baseAddress[testOffset]);
;;;136    		}
;;;137    
;;;138            for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
;;;139            {
;;;140                if ((baseAddress[offset] != pattern) && (offset != testOffset))
;;;141                {
;;;142                    return ((datum *) &baseAddress[testOffset]);
;;;143                }
;;;144            }
;;;145    
;;;146            baseAddress[testOffset] = pattern;
;;;147        }
;;;148    
;;;149        return (NULL);
;;;150    
;;;151    }   /* memTestAddressBus() */
000052  bdf0              POP      {r4-r7,pc}
                  |L1.84|
000054  0049              LSLS     r1,r1,#1              ;116
                  |L1.86|
000056  4608              MOV      r0,r1                 ;116
000058  4028              ANDS     r0,r0,r5              ;116
00005a  2800              CMP      r0,#0                 ;116
00005c  d1f3              BNE      |L1.70|
00005e  0098              LSLS     r0,r3,#2              ;124
000060  5014              STR      r4,[r2,r0]            ;124
000062  2301              MOVS     r3,#1                 ;129
000064  e01a              B        |L1.156|
                  |L1.102|
000066  0098              LSLS     r0,r3,#2              ;131
000068  5016              STR      r6,[r2,r0]            ;131
00006a  6810              LDR      r0,[r2,#0]            ;133
00006c  42a0              CMP      r0,r4                 ;133
00006e  d002              BEQ      |L1.118|
000070  0098              LSLS     r0,r3,#2              ;135
000072  1880              ADDS     r0,r0,r2              ;135
000074  e7ed              B        |L1.82|
                  |L1.118|
000076  2101              MOVS     r1,#1                 ;138
000078  e009              B        |L1.142|
                  |L1.122|
00007a  0088              LSLS     r0,r1,#2              ;140
00007c  5810              LDR      r0,[r2,r0]            ;140
00007e  42a0              CMP      r0,r4                 ;140
000080  d004              BEQ      |L1.140|
000082  4299              CMP      r1,r3                 ;140
000084  d002              BEQ      |L1.140|
000086  0098              LSLS     r0,r3,#2              ;142
000088  1880              ADDS     r0,r0,r2              ;142
00008a  e7e2              B        |L1.82|
                  |L1.140|
00008c  0049              LSLS     r1,r1,#1              ;138
                  |L1.142|
00008e  4608              MOV      r0,r1                 ;138
000090  4028              ANDS     r0,r0,r5              ;138
000092  2800              CMP      r0,#0                 ;138
000094  d1f1              BNE      |L1.122|
000096  0098              LSLS     r0,r3,#2              ;146
000098  5014              STR      r4,[r2,r0]            ;146
00009a  005b              LSLS     r3,r3,#1              ;129
                  |L1.156|
00009c  4618              MOV      r0,r3                 ;129
00009e  4028              ANDS     r0,r0,r5              ;129
0000a0  2800              CMP      r0,#0                 ;129
0000a2  d1e0              BNE      |L1.102|
0000a4  bf00              NOP                            ;149
0000a6  e7d4              B        |L1.82|
;;;152    
                          ENDP

                  memTestDevice PROC
;;;175    datum * 
;;;176    memTestDevice(volatile datum * baseAddress, unsigned long nBytes)	
0000a8  b570              PUSH     {r4-r6,lr}
;;;177    {
0000aa  4602              MOV      r2,r0
0000ac  460e              MOV      r6,r1
;;;178        unsigned long offset;
;;;179        unsigned long nWords = nBytes / sizeof(datum);
0000ae  08b4              LSRS     r4,r6,#2
;;;180    
;;;181        datum pattern;
;;;182        datum antipattern;
;;;183    
;;;184    
;;;185        /*
;;;186         * Fill memory with a known pattern.
;;;187         */
;;;188        for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
0000b0  2301              MOVS     r3,#1
0000b2  2100              MOVS     r1,#0
0000b4  e003              B        |L1.190|
                  |L1.182|
;;;189        {
;;;190            baseAddress[offset] = pattern;
0000b6  0088              LSLS     r0,r1,#2
0000b8  5013              STR      r3,[r2,r0]
0000ba  1c5b              ADDS     r3,r3,#1              ;188
0000bc  1c49              ADDS     r1,r1,#1              ;188
                  |L1.190|
0000be  42a1              CMP      r1,r4                 ;188
0000c0  d3f9              BCC      |L1.182|
;;;191        }
;;;192    
;;;193        /*
;;;194         * Check each location and invert it for the second pass.
;;;195         */
;;;196        for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
0000c2  2301              MOVS     r3,#1
0000c4  2100              MOVS     r1,#0
0000c6  e00b              B        |L1.224|
                  |L1.200|
;;;197        {
;;;198            if (baseAddress[offset] != pattern)
0000c8  0088              LSLS     r0,r1,#2
0000ca  5810              LDR      r0,[r2,r0]
0000cc  4298              CMP      r0,r3
0000ce  d002              BEQ      |L1.214|
;;;199            {
;;;200                return ((datum *) &baseAddress[offset]);
0000d0  0088              LSLS     r0,r1,#2
0000d2  1880              ADDS     r0,r0,r2
                  |L1.212|
;;;201            }
;;;202    
;;;203            antipattern = ~pattern;
;;;204            baseAddress[offset] = antipattern;
;;;205        }
;;;206    
;;;207        /*
;;;208         * Check each location for the inverted pattern and zero it.
;;;209         */
;;;210        for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
;;;211        {
;;;212            antipattern = ~pattern;
;;;213            if (baseAddress[offset] != antipattern)
;;;214            {
;;;215                return ((datum *) &baseAddress[offset]);
;;;216            }
;;;217        }
;;;218    
;;;219        return (NULL);
;;;220    
;;;221    }   /* memTestDevice() */
0000d4  bd70              POP      {r4-r6,pc}
                  |L1.214|
0000d6  43dd              MVNS     r5,r3                 ;203
0000d8  0088              LSLS     r0,r1,#2              ;204
0000da  5015              STR      r5,[r2,r0]            ;204
0000dc  1c5b              ADDS     r3,r3,#1              ;196
0000de  1c49              ADDS     r1,r1,#1              ;196
                  |L1.224|
0000e0  42a1              CMP      r1,r4                 ;196
0000e2  d3f1              BCC      |L1.200|
0000e4  2301              MOVS     r3,#1                 ;210
0000e6  2100              MOVS     r1,#0                 ;210
0000e8  e009              B        |L1.254|
                  |L1.234|
0000ea  43dd              MVNS     r5,r3                 ;212
0000ec  0088              LSLS     r0,r1,#2              ;213
0000ee  5810              LDR      r0,[r2,r0]            ;213
0000f0  42a8              CMP      r0,r5                 ;213
0000f2  d002              BEQ      |L1.250|
0000f4  0088              LSLS     r0,r1,#2              ;215
0000f6  1880              ADDS     r0,r0,r2              ;215
0000f8  e7ec              B        |L1.212|
                  |L1.250|
0000fa  1c5b              ADDS     r3,r3,#1              ;210
0000fc  1c49              ADDS     r1,r1,#1              ;210
                  |L1.254|
0000fe  42a1              CMP      r1,r4                 ;210
000100  d3f3              BCC      |L1.234|
000102  2000              MOVS     r0,#0                 ;219
000104  e7e6              B        |L1.212|
                          ENDP

000106  0000              DCW      0x0000
                  |L1.264|
                          DCD      0xaaaaaaaa
