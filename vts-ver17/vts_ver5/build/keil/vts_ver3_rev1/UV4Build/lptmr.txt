; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\lptmr.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\lptmr.d --cpu=Cortex-M0+ --apcs=interwork -O0 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -IC:\Keil_v5\ARM\RV31\Inc -IC:\Users\Mridul\Desktop\vts_ver5\build\keil\vts_ver3_rev1\RTE -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.5.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__RTX -D__MICROLIB -DMKL26Z128xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\lptmr.crf ..\..\..\src\drivers\lptmr\lptmr.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  time_delay_ms PROC
;;;30      */
;;;31     void time_delay_ms(unsigned int count_val)
000000  4924              LDR      r1,|L1.148|
;;;32     {
;;;33       /* Make sure the clock to the LPTMR is enabled */
;;;34       SIM_SCGC5|=SIM_SCGC5_LPTMR_MASK;
000002  6b89              LDR      r1,[r1,#0x38]
000004  2201              MOVS     r2,#1
000006  4311              ORRS     r1,r1,r2
000008  4a22              LDR      r2,|L1.148|
00000a  6391              STR      r1,[r2,#0x38]
;;;35     
;;;36       /* Reset LPTMR settings */
;;;37       LPTMR0_CSR=0;
00000c  2100              MOVS     r1,#0
00000e  4a22              LDR      r2,|L1.152|
000010  6011              STR      r1,[r2,#0]
;;;38     
;;;39       /* Set the compare value to the number of ms to delay */
;;;40       LPTMR0_CMR = count_val;
000012  4611              MOV      r1,r2
000014  6088              STR      r0,[r1,#8]
;;;41     
;;;42       /* Set up LPTMR to use 1kHz LPO with no prescaler as its clock source */
;;;43       LPTMR0_PSR = LPTMR_PSR_PCS(1)|LPTMR_PSR_PBYP_MASK;
000016  2105              MOVS     r1,#5
000018  6051              STR      r1,[r2,#4]
;;;44     
;;;45       /* Start the timer */
;;;46       LPTMR0_CSR |= LPTMR_CSR_TEN_MASK;
00001a  4611              MOV      r1,r2
00001c  6809              LDR      r1,[r1,#0]
00001e  2201              MOVS     r2,#1
000020  4311              ORRS     r1,r1,r2
000022  4a1d              LDR      r2,|L1.152|
000024  6011              STR      r1,[r2,#0]
;;;47     
;;;48       /* Wait for counter to reach compare value */
;;;49       while (!(LPTMR0_CSR & LPTMR_CSR_TCF_MASK));
000026  bf00              NOP      
                  |L1.40|
000028  491b              LDR      r1,|L1.152|
00002a  6809              LDR      r1,[r1,#0]
00002c  2280              MOVS     r2,#0x80
00002e  4011              ANDS     r1,r1,r2
000030  2900              CMP      r1,#0
000032  d0f9              BEQ      |L1.40|
;;;50     
;;;51       /* Disable counter and Clear Timer Compare Flag */
;;;52       LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK;
000034  4918              LDR      r1,|L1.152|
000036  6809              LDR      r1,[r1,#0]
000038  0849              LSRS     r1,r1,#1
00003a  0049              LSLS     r1,r1,#1
00003c  4a16              LDR      r2,|L1.152|
00003e  6011              STR      r1,[r2,#0]
;;;53     
;;;54       return;
;;;55     }
000040  4770              BX       lr
;;;56     
                          ENDP

                  lptmr_init PROC
;;;63     *******************************************************************************/
;;;64     void lptmr_init(int count, int clock_source)
000042  b510              PUSH     {r4,lr}
;;;65     {
000044  4602              MOV      r2,r0
;;;66     	clock_source = 1;
000046  2101              MOVS     r1,#1
;;;67         SIM_SCGC5 |= SIM_SCGC5_LPTMR_MASK;
000048  4812              LDR      r0,|L1.148|
00004a  6b80              LDR      r0,[r0,#0x38]
00004c  2301              MOVS     r3,#1
00004e  4318              ORRS     r0,r0,r3
000050  4b10              LDR      r3,|L1.148|
000052  6398              STR      r0,[r3,#0x38]
;;;68         // disable LPTMR
;;;69         LPTMR0_CSR &= ~LPTMR_CSR_TEN_MASK; 
000054  4810              LDR      r0,|L1.152|
000056  6800              LDR      r0,[r0,#0]
000058  4388              BICS     r0,r0,r1
00005a  4b0f              LDR      r3,|L1.152|
00005c  6018              STR      r0,[r3,#0]
;;;70         // select LPO for RTC and LPTMR
;;;71         LPTMR0_PSR = ( LPTMR_PSR_PRESCALE(0) // 0000 is div 2
00005e  2004              MOVS     r0,#4
000060  4308              ORRS     r0,r0,r1
000062  6058              STR      r0,[r3,#4]
;;;72                      | LPTMR_PSR_PBYP_MASK  // clock feeds directly to LPT
;;;73                      | LPTMR_PSR_PCS(clock_source)) ; // use the choice of clock
;;;74                   
;;;75         LPTMR0_CMR = LPTMR_CMR_COMPARE(count);  //Set compare value
000064  b290              UXTH     r0,r2
000066  6098              STR      r0,[r3,#8]
;;;76     	// clear flag
;;;77     	  LPTMR0_CSR |=  LPTMR_CSR_TCF_MASK; 
000068  4618              MOV      r0,r3
00006a  6800              LDR      r0,[r0,#0]
00006c  2380              MOVS     r3,#0x80
00006e  4318              ORRS     r0,r0,r3
000070  4b09              LDR      r3,|L1.152|
000072  6018              STR      r0,[r3,#0]
;;;78     	
;;;79         LPTMR0_CSR =(  LPTMR_CSR_TCF_MASK   // Clear any pending interrupt
000074  20c0              MOVS     r0,#0xc0
000076  6018              STR      r0,[r3,#0]
;;;80                      | LPTMR_CSR_TIE_MASK   // LPT interrupt enabled
;;;81                      );
;;;82     	
;;;83         LPTMR0_CSR |= LPTMR_CSR_TEN_MASK;   //Turn on LPT and start counting
000078  4618              MOV      r0,r3
00007a  6800              LDR      r0,[r0,#0]
00007c  2301              MOVS     r3,#1
00007e  4318              ORRS     r0,r0,r3
000080  4b05              LDR      r3,|L1.152|
000082  6018              STR      r0,[r3,#0]
;;;84         
;;;85     		enable_irq(LPTimer_IRQn);
000084  201c              MOVS     r0,#0x1c
000086  2301              MOVS     r3,#1
000088  4083              LSLS     r3,r3,r0
00008a  4c04              LDR      r4,|L1.156|
00008c  6023              STR      r3,[r4,#0]
00008e  bf00              NOP      
;;;86     	
;;;87     	
;;;88     //    enable_irq(INT_LPTimer - 16);
;;;89     }
000090  bd10              POP      {r4,pc}
;;;90     
                          ENDP

000092  0000              DCW      0x0000
                  |L1.148|
                          DCD      0x40048000
                  |L1.152|
                          DCD      0x40040000
                  |L1.156|
                          DCD      0xe000e100

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\drivers\\lptmr\\lptmr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_lptmr_c_ff64738d____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_lptmr_c_ff64738d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_lptmr_c_ff64738d____REVSH|
#line 144
|__asm___7_lptmr_c_ff64738d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
