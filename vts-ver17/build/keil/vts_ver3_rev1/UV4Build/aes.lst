L 1 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\library\aes.c"
N/*
N *  FIPS-197 compliant AES implementation
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N/*
N *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.
N *
N *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf
N *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
N */
N
N#if !defined(MBEDTLS_CONFIG_FILE)
X#if !0L
N#include "mbedtls/config.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls/config.h" 1
N/**
N * \file config.h
N *
N * \brief Configuration options (set of defines)
N *
N *  This set of compile-time options may be used to enable
N *  or disable features selectively, and reduce the global
N *  memory footprint.
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N#ifdef _RTE_
N#include "mbedTLS_config.h"
L 1 ".\RTE\Security\mbedTLS_config.h" 1
N/*
N *  Configuration template
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N/*
N * This set of compile-time options may be used to enable
N * or disable features selectively, and reduce the global
N * memory footprint.
N */
N#ifndef MBEDTLS_CONFIG_H
N#define MBEDTLS_CONFIG_H
N
N/* System support */
N//#define MBEDTLS_HAVE_ASM
N//#define MBEDTLS_HAVE_TIME
N//#define MBEDTLS_HAVE_TIME_DATE
N//#define MBEDTLS_PLATFORM_MEMORY
N//#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
N
N/* mbed TLS feature support */
N//#define MBEDTLS_AES_ROM_TABLES
N//#define MBEDTLS_CAMELLIA_SMALL_MEMORY
N//#define MBEDTLS_CIPHER_MODE_CBC
N//#define MBEDTLS_CIPHER_MODE_CFB
N//#define MBEDTLS_CIPHER_MODE_CTR
N//#define MBEDTLS_CIPHER_PADDING_PKCS7
N//#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
N//#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
N//#define MBEDTLS_CIPHER_PADDING_ZEROS
N//#define MBEDTLS_REMOVE_ARC4_CIPHERSUITES
N//#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
N//#define MBEDTLS_ECP_DP_BP256R1_ENABLED
N//#define MBEDTLS_ECP_DP_BP384R1_ENABLED
N//#define MBEDTLS_ECP_DP_BP512R1_ENABLED
N//#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
N//#define MBEDTLS_ECP_NIST_OPTIM
N//#define MBEDTLS_ECDSA_DETERMINISTIC
N//#define MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
N//#define MBEDTLS_PK_PARSE_EC_EXTENDED
N//#define MBEDTLS_ERROR_STRERROR_DUMMY
N//#define MBEDTLS_GENPRIME
N//#define MBEDTLS_FS_IO
N//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
N//#define MBEDTLS_NO_PLATFORM_ENTROPY
N//#define MBEDTLS_ENTROPY_FORCE_SHA256
N//#define MBEDTLS_MEMORY_DEBUG
N//#define MBEDTLS_MEMORY_BACKTRACE
N//#define MBEDTLS_PK_RSA_ALT_SUPPORT
N//#define MBEDTLS_PKCS1_V15
N//#define MBEDTLS_PKCS1_V21
N//#define MBEDTLS_RSA_NO_CRT
N//#define MBEDTLS_SELF_TEST
N//#define MBEDTLS_SHA256_SMALLER
N//#define MBEDTLS_SSL_AEAD_RANDOM_IV
N//#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
N//#define MBEDTLS_SSL_DEBUG_ALL
N//#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
N//#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
N//#define MBEDTLS_SSL_FALLBACK_SCSV
N//#define MBEDTLS_SSL_HW_RECORD_ACCEL
N//#define MBEDTLS_SSL_CBC_RECORD_SPLITTING
N//#define MBEDTLS_SSL_RENEGOTIATION
N//#define MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
N//#define MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE
N//#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
N//#define MBEDTLS_SSL_PROTO_SSL3
N//#define MBEDTLS_SSL_PROTO_TLS1
N//#define MBEDTLS_SSL_PROTO_TLS1_1
N//#define MBEDTLS_SSL_PROTO_TLS1_2
N//#define MBEDTLS_SSL_PROTO_DTLS
N//#define MBEDTLS_SSL_ALPN
N//#define MBEDTLS_SSL_DTLS_ANTI_REPLAY
N//#define MBEDTLS_SSL_DTLS_HELLO_VERIFY
N//#define MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
N//#define MBEDTLS_SSL_DTLS_BADMAC_LIMIT
N//#define MBEDTLS_SSL_SESSION_TICKETS
N//#define MBEDTLS_SSL_EXPORT_KEYS
N//#define MBEDTLS_SSL_SERVER_NAME_INDICATION
N//#define MBEDTLS_SSL_TRUNCATED_HMAC
N//#define MBEDTLS_VERSION_FEATURES
N//#define MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3
N//#define MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
N//#define MBEDTLS_X509_CHECK_KEY_USAGE
N//#define MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
N//#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
N
N/* mbed TLS modules */
N//#define MBEDTLS_AES_C
N//#define MBEDTLS_ARC4_C
N//#define MBEDTLS_ASN1_PARSE_C
N//#define MBEDTLS_ASN1_WRITE_C
N//#define MBEDTLS_BASE64_C
N//#define MBEDTLS_BIGNUM_C
N//#define MBEDTLS_BLOWFISH_C
N//#define MBEDTLS_CAMELLIA_C
N//#define MBEDTLS_CCM_C
N//#define MBEDTLS_CERTS_C
N//#define MBEDTLS_CIPHER_C
N//#define MBEDTLS_CTR_DRBG_C
N//#define MBEDTLS_DEBUG_C
N//#define MBEDTLS_DES_C
N//#define MBEDTLS_DHM_C
N//#define MBEDTLS_ECDH_C
N//#define MBEDTLS_ECDSA_C
N//#define MBEDTLS_ECJPAKE_C
N//#define MBEDTLS_ECP_C
N//#define MBEDTLS_ENTROPY_C
N//#define MBEDTLS_ERROR_C
N//#define MBEDTLS_GCM_C
N//#define MBEDTLS_HAVEGE_C
N//#define MBEDTLS_HMAC_DRBG_C
N//#define MBEDTLS_MD_C
N//#define MBEDTLS_MD2_C
N//#define MBEDTLS_MD4_C
N//#define MBEDTLS_MD5_C
N//#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
N//#define MBEDTLS_NET_C
N//#define MBEDTLS_OID_C
N//#define MBEDTLS_PEM_PARSE_C
N//#define MBEDTLS_PEM_WRITE_C
N//#define MBEDTLS_PK_C
N//#define MBEDTLS_PK_PARSE_C
N//#define MBEDTLS_PK_WRITE_C
N//#define MBEDTLS_PKCS5_C
N//#define MBEDTLS_PKCS11_C
N//#define MBEDTLS_PKCS12_C
N//#define MBEDTLS_PLATFORM_C
N//#define MBEDTLS_RIPEMD160_C
N//#define MBEDTLS_RSA_C
N//#define MBEDTLS_SHA1_C
N//#define MBEDTLS_SHA256_C
N//#define MBEDTLS_SHA512_C
N//#define MBEDTLS_SSL_CACHE_C
N//#define MBEDTLS_SSL_COOKIE_C
N//#define MBEDTLS_SSL_TICKET_C
N//#define MBEDTLS_SSL_CLI_C
N//#define MBEDTLS_SSL_SRV_C
N//#define MBEDTLS_SSL_TLS_C
N//#define MBEDTLS_THREADING_C
N//#define MBEDTLS_TIMING_C
N//#define MBEDTLS_VERSION_C
N//#define MBEDTLS_X509_USE_C
N//#define MBEDTLS_X509_CRT_PARSE_C
N//#define MBEDTLS_X509_CRL_PARSE_C
N//#define MBEDTLS_X509_CSR_PARSE_C
N//#define MBEDTLS_X509_CREATE_C
N//#define MBEDTLS_X509_CRT_WRITE_C
N//#define MBEDTLS_X509_CSR_WRITE_C
N//#define MBEDTLS_XTEA_C
N
N#include "check_config.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls\check_config.h" 1
N/**
N * \file check_config.h
N *
N * \brief Consistency checks for configuration options
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N/*
N * It is recommended to include this file from your config.h
N * in order to catch dependency issues early.
N */
N
N#ifndef MBEDTLS_CHECK_CONFIG_H
N#define MBEDTLS_CHECK_CONFIG_H
N
N/*
N * We assume CHAR_BIT is 8 in many places. In practice, this is true on our
N * target platforms, so not an issue, but let's just be extra sure.
N */
N#include <limits.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5060002
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
S  #define CHAR_MIN (-128)
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 127
S      /* maximum value for an object of type char */
N#else
N  #define CHAR_MIN 0
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 255
N      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MIN  (~0x7fffffffffffffffL)
N#else
N  #define LONG_MIN  (~0x7fffffffL)
N#endif
N    /* minimum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MAX  0x7fffffffffffffffL
N#else
N  #define LONG_MAX  0x7fffffffL
N#endif
N    /* maximum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define ULONG_MAX 0xffffffffffffffffUL
N#else
N  #define ULONG_MAX 0xffffffffUL
N#endif
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 37 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls\check_config.h" 2
N#if CHAR_BIT != 8
X#if 8 != 8
S#error "mbed TLS requires a platform with 8-bit chars"
N#endif
N
N#if defined(_WIN32)
X#if 0L
S#if !defined(MBEDTLS_PLATFORM_C)
S#error "MBEDTLS_PLATFORM_C is required on Windows"
S#endif
S
S/* Fix the config here. Not convenient to put an #ifdef _WIN32 in config.h as
S * it would confuse config.pl. */
S#if !defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) && \
S    !defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO)
X#if !defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) &&     !defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO)
S#define MBEDTLS_PLATFORM_SNPRINTF_ALT
S#endif
N#endif /* _WIN32 */
N
N#if defined(TARGET_LIKE_MBED) && \
N    ( defined(MBEDTLS_NET_C) || defined(MBEDTLS_TIMING_C) )
X#if 0L &&     ( 0L || 0L )
S#error "The NET and TIMING modules are not available for mbed OS - please use the network and timing functions provided by mbed OS"
N#endif
N
N#if defined(MBEDTLS_DEPRECATED_WARNING) && \
N    !defined(__GNUC__) && !defined(__clang__)
X#if 0L &&     !0L && !0L
S#error "MBEDTLS_DEPRECATED_WARNING only works with GCC and Clang"
N#endif
N
N#if defined(MBEDTLS_HAVE_TIME_DATE) && !defined(MBEDTLS_HAVE_TIME)
X#if 0L && !0L
S#error "MBEDTLS_HAVE_TIME_DATE without MBEDTLS_HAVE_TIME does not make sense"
N#endif
N
N#if defined(MBEDTLS_AESNI_C) && !defined(MBEDTLS_HAVE_ASM)
X#if 0L && !0L
S#error "MBEDTLS_AESNI_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_CTR_DRBG_C) && !defined(MBEDTLS_AES_C)
X#if 0L && !0L
S#error "MBEDTLS_CTR_DRBG_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_DHM_C) && !defined(MBEDTLS_BIGNUM_C)
X#if 0L && !0L
S#error "MBEDTLS_DHM_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECDH_C) && !defined(MBEDTLS_ECP_C)
X#if 0L && !0L
S#error "MBEDTLS_ECDH_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECDSA_C) &&            \
N    ( !defined(MBEDTLS_ECP_C) ||           \
N      !defined(MBEDTLS_ASN1_PARSE_C) ||    \
N      !defined(MBEDTLS_ASN1_WRITE_C) )
X#if 0L &&                ( !0L ||                 !0L ||          !0L )
S#error "MBEDTLS_ECDSA_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECJPAKE_C) &&           \
N    ( !defined(MBEDTLS_ECP_C) || !defined(MBEDTLS_MD_C) )
X#if 0L &&               ( !0L || !0L )
S#error "MBEDTLS_ECJPAKE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECDSA_DETERMINISTIC) && !defined(MBEDTLS_HMAC_DRBG_C)
X#if 0L && !0L
S#error "MBEDTLS_ECDSA_DETERMINISTIC defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECP_C) && ( !defined(MBEDTLS_BIGNUM_C) || (   \
N    !defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)   &&                  \
N    !defined(MBEDTLS_ECP_DP_BP384R1_ENABLED)   &&                  \
N    !defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)   &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED) ) )
X#if 0L && ( !0L || (       !0L &&                      !0L &&                      !0L &&                      !0L &&                      !0L &&                      !0L   &&                      !0L   &&                      !0L   &&                      !0L &&                      !0L &&                      !0L ) )
S#error "MBEDTLS_ECP_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ENTROPY_C) && (!defined(MBEDTLS_SHA512_C) &&      \
N                                    !defined(MBEDTLS_SHA256_C))
X#if 0L && (!0L &&                                          !0L)
S#error "MBEDTLS_ENTROPY_C defined, but not all prerequisites"
N#endif
N#if defined(MBEDTLS_ENTROPY_C) && defined(MBEDTLS_SHA512_C) &&         \
N    defined(MBEDTLS_CTR_DRBG_ENTROPY_LEN) && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 64)
X#if 0L && 0L &&             0L && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 64)
S#error "MBEDTLS_CTR_DRBG_ENTROPY_LEN value too high"
N#endif
N#if defined(MBEDTLS_ENTROPY_C) &&                                            \
N    ( !defined(MBEDTLS_SHA512_C) || defined(MBEDTLS_ENTROPY_FORCE_SHA256) ) \
N    && defined(MBEDTLS_CTR_DRBG_ENTROPY_LEN) && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 32)
X#if 0L &&                                                ( !0L || 0L )     && 0L && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 32)
S#error "MBEDTLS_CTR_DRBG_ENTROPY_LEN value too high"
N#endif
N#if defined(MBEDTLS_ENTROPY_C) && \
N    defined(MBEDTLS_ENTROPY_FORCE_SHA256) && !defined(MBEDTLS_SHA256_C)
X#if 0L &&     0L && !0L
S#error "MBEDTLS_ENTROPY_FORCE_SHA256 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_GCM_C) && (                                        \
N        !defined(MBEDTLS_AES_C) && !defined(MBEDTLS_CAMELLIA_C) )
X#if 0L && (                                                !0L && !0L )
S#error "MBEDTLS_GCM_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_HAVEGE_C) && !defined(MBEDTLS_TIMING_C)
X#if 0L && !0L
S#error "MBEDTLS_HAVEGE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_HMAC_DRBG_C) && !defined(MBEDTLS_MD_C)
X#if 0L && !0L
S#error "MBEDTLS_HMAC_DRBG_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) )
X#if 0L &&                     ( !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) )
X#if 0L &&                     ( !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED) && !defined(MBEDTLS_DHM_C)
X#if 0L && !0L
S#error "MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) &&                     \
N    !defined(MBEDTLS_ECDH_C)
X#if 0L &&                         !0L
S#error "MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) &&                   \
N    ( !defined(MBEDTLS_DHM_C) || !defined(MBEDTLS_RSA_C) ||           \
N      !defined(MBEDTLS_X509_CRT_PARSE_C) || !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                       ( !0L || !0L ||                 !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_RSA_C) ||          \
N      !defined(MBEDTLS_X509_CRT_PARSE_C) || !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                     ( !0L || !0L ||                !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_ECDSA_C) ||          \
N      !defined(MBEDTLS_X509_CRT_PARSE_C) )
X#if 0L &&                     ( !0L || !0L ||                !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED) &&                   \
N    ( !defined(MBEDTLS_RSA_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) || \
N      !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                       ( !0L || !0L ||       !0L )
S#error "MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) &&                       \
N    ( !defined(MBEDTLS_RSA_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) || \
N      !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                           ( !0L || !0L ||       !0L )
S#error "MBEDTLS_KEY_EXCHANGE_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED) &&                    \
N    ( !defined(MBEDTLS_ECJPAKE_C) || !defined(MBEDTLS_SHA256_C) ||      \
N      !defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) )
X#if 0L &&                        ( !0L || !0L ||            !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_MEMORY_BUFFER_ALLOC_C) &&                          \
N    ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
X#if 0L &&                              ( !0L || !0L )
S#error "MBEDTLS_MEMORY_BUFFER_ALLOC_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PADLOCK_C) && !defined(MBEDTLS_HAVE_ASM)
X#if 0L && !0L
S#error "MBEDTLS_PADLOCK_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PEM_PARSE_C) && !defined(MBEDTLS_BASE64_C)
X#if 0L && !0L
S#error "MBEDTLS_PEM_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PEM_WRITE_C) && !defined(MBEDTLS_BASE64_C)
X#if 0L && !0L
S#error "MBEDTLS_PEM_WRITE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PK_C) && \
N    ( !defined(MBEDTLS_RSA_C) && !defined(MBEDTLS_ECP_C) )
X#if 0L &&     ( !0L && !0L )
S#error "MBEDTLS_PK_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PK_PARSE_C) && !defined(MBEDTLS_PK_C)
X#if 0L && !0L
S#error "MBEDTLS_PK_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PK_WRITE_C) && !defined(MBEDTLS_PK_C)
X#if 0L && !0L
S#error "MBEDTLS_PK_WRITE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PKCS11_C) && !defined(MBEDTLS_PK_C)
X#if 0L && !0L
S#error "MBEDTLS_PKCS11_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_EXIT_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_EXIT_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_EXIT_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_EXIT_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_EXIT_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_EXIT) ||\
N        defined(MBEDTLS_PLATFORM_EXIT_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_EXIT_MACRO and MBEDTLS_PLATFORM_STD_EXIT/MBEDTLS_PLATFORM_EXIT_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FPRINTF_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_FPRINTF_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FPRINTF_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_FPRINTF_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FPRINTF_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_FPRINTF) ||\
N        defined(MBEDTLS_PLATFORM_FPRINTF_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_FPRINTF_MACRO and MBEDTLS_PLATFORM_STD_FPRINTF/MBEDTLS_PLATFORM_FPRINTF_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FREE_MACRO) &&\
N    ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
X#if 0L &&    ( !0L || !0L )
S#error "MBEDTLS_PLATFORM_FREE_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FREE_MACRO) &&\
N    defined(MBEDTLS_PLATFORM_STD_FREE)
X#if 0L &&    0L
S#error "MBEDTLS_PLATFORM_FREE_MACRO and MBEDTLS_PLATFORM_STD_FREE cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FREE_MACRO) && !defined(MBEDTLS_PLATFORM_CALLOC_MACRO)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_CALLOC_MACRO must be defined if MBEDTLS_PLATFORM_FREE_MACRO is"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_CALLOC_MACRO) &&\
N    ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
X#if 0L &&    ( !0L || !0L )
S#error "MBEDTLS_PLATFORM_CALLOC_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_CALLOC_MACRO) &&\
N    defined(MBEDTLS_PLATFORM_STD_CALLOC)
X#if 0L &&    0L
S#error "MBEDTLS_PLATFORM_CALLOC_MACRO and MBEDTLS_PLATFORM_STD_CALLOC cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_CALLOC_MACRO) && !defined(MBEDTLS_PLATFORM_FREE_MACRO)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_FREE_MACRO must be defined if MBEDTLS_PLATFORM_CALLOC_MACRO is"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_MEMORY) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_MEMORY defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_PRINTF_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_PRINTF_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_PRINTF_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_PRINTF_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_PRINTF_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_PRINTF) ||\
N        defined(MBEDTLS_PLATFORM_PRINTF_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_PRINTF_MACRO and MBEDTLS_PLATFORM_STD_PRINTF/MBEDTLS_PLATFORM_PRINTF_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_SNPRINTF_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_SNPRINTF_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_SNPRINTF) ||\
N        defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_SNPRINTF_MACRO and MBEDTLS_PLATFORM_STD_SNPRINTF/MBEDTLS_PLATFORM_SNPRINTF_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_MEM_HDR) &&\
N    !defined(MBEDTLS_PLATFORM_NO_STD_FUNCTIONS)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_MEM_HDR defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_CALLOC) && !defined(MBEDTLS_PLATFORM_MEMORY)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_STD_CALLOC defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_CALLOC) && !defined(MBEDTLS_PLATFORM_MEMORY)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_STD_CALLOC defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_FREE) && !defined(MBEDTLS_PLATFORM_MEMORY)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_STD_FREE defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_EXIT) &&\
N    !defined(MBEDTLS_PLATFORM_EXIT_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_EXIT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_FPRINTF) &&\
N    !defined(MBEDTLS_PLATFORM_FPRINTF_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_FPRINTF defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_PRINTF) &&\
N    !defined(MBEDTLS_PLATFORM_PRINTF_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_PRINTF defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_SNPRINTF) &&\
N    !defined(MBEDTLS_PLATFORM_SNPRINTF_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_SNPRINTF defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_RSA_C) && ( !defined(MBEDTLS_BIGNUM_C) ||         \
N    !defined(MBEDTLS_OID_C) )
X#if 0L && ( !0L ||             !0L )
S#error "MBEDTLS_RSA_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT) &&                        \
N    ( !defined(MBEDTLS_RSA_C) || !defined(MBEDTLS_PKCS1_V21) )
X#if 0L &&                            ( !0L || !0L )
S#error "MBEDTLS_X509_RSASSA_PSS_SUPPORT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_SSL3) && ( !defined(MBEDTLS_MD5_C) ||     \
N    !defined(MBEDTLS_SHA1_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_PROTO_SSL3 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_TLS1) && ( !defined(MBEDTLS_MD5_C) ||     \
N    !defined(MBEDTLS_SHA1_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_PROTO_TLS1 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_TLS1_1) && ( !defined(MBEDTLS_MD5_C) ||     \
N    !defined(MBEDTLS_SHA1_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_PROTO_TLS1_1 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && ( !defined(MBEDTLS_SHA1_C) &&     \
N    !defined(MBEDTLS_SHA256_C) && !defined(MBEDTLS_SHA512_C) )
X#if 0L && ( !0L &&         !0L && !0L )
S#error "MBEDTLS_SSL_PROTO_TLS1_2 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_DTLS)     && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1)  && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if 0L     &&     !0L  &&     !0L
S#error "MBEDTLS_SSL_PROTO_DTLS defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_CLI_C) && !defined(MBEDTLS_SSL_TLS_C)
X#if 0L && !0L
S#error "MBEDTLS_SSL_CLI_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && ( !defined(MBEDTLS_CIPHER_C) ||     \
N    !defined(MBEDTLS_MD_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_TLS_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_SRV_C) && !defined(MBEDTLS_SSL_TLS_C)
X#if 0L && !0L
S#error "MBEDTLS_SSL_SRV_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (!defined(MBEDTLS_SSL_PROTO_SSL3) && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1) && !defined(MBEDTLS_SSL_PROTO_TLS1_1) && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2))
X#if 0L && (!0L &&     !0L && !0L &&     !0L)
S#error "MBEDTLS_SSL_TLS_C defined, but no protocols are active"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (defined(MBEDTLS_SSL_PROTO_SSL3) && \
N    defined(MBEDTLS_SSL_PROTO_TLS1_1) && !defined(MBEDTLS_SSL_PROTO_TLS1))
X#if 0L && (0L &&     0L && !0L)
S#error "Illegal protocol selection"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (defined(MBEDTLS_SSL_PROTO_TLS1) && \
N    defined(MBEDTLS_SSL_PROTO_TLS1_2) && !defined(MBEDTLS_SSL_PROTO_TLS1_1))
X#if 0L && (0L &&     0L && !0L)
S#error "Illegal protocol selection"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (defined(MBEDTLS_SSL_PROTO_SSL3) && \
N    defined(MBEDTLS_SSL_PROTO_TLS1_2) && (!defined(MBEDTLS_SSL_PROTO_TLS1) || \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1)))
X#if 0L && (0L &&     0L && (!0L ||     !0L))
S#error "Illegal protocol selection"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && !defined(MBEDTLS_SSL_PROTO_DTLS)
X#if 0L && !0L
S#error "MBEDTLS_SSL_DTLS_HELLO_VERIFY  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && \
N    !defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
X#if 0L &&     !0L
S#error "MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY) &&                              \
N    ( !defined(MBEDTLS_SSL_TLS_C) || !defined(MBEDTLS_SSL_PROTO_DTLS) )
X#if 0L &&                                  ( !0L || !0L )
S#error "MBEDTLS_SSL_DTLS_ANTI_REPLAY  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT) &&                              \
N    ( !defined(MBEDTLS_SSL_TLS_C) || !defined(MBEDTLS_SSL_PROTO_DTLS) )
X#if 0L &&                                  ( !0L || !0L )
S#error "MBEDTLS_SSL_DTLS_BADMAC_LIMIT  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC) &&   \
N    !defined(MBEDTLS_SSL_PROTO_TLS1)   &&      \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1) &&      \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if 0L &&       !0L   &&          !0L &&          !0L
S#error "MBEDTLS_SSL_ENCRYPT_THEN_MAC defined, but not all prerequsites"
N#endif
N
N#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET) && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1)   &&          \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1) &&          \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if 0L &&     !0L   &&              !0L &&              !0L
S#error "MBEDTLS_SSL_EXTENDED_MASTER_SECRET defined, but not all prerequsites"
N#endif
N
N#if defined(MBEDTLS_SSL_TICKET_C) && !defined(MBEDTLS_CIPHER_C)
X#if 0L && !0L
S#error "MBEDTLS_SSL_TICKET_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING) && \
N    !defined(MBEDTLS_SSL_PROTO_SSL3) && !defined(MBEDTLS_SSL_PROTO_TLS1)
X#if 0L &&     !0L && !0L
S#error "MBEDTLS_SSL_CBC_RECORD_SPLITTING defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION) && \
N        !defined(MBEDTLS_X509_CRT_PARSE_C)
X#if 0L &&         !0L
S#error "MBEDTLS_SSL_SERVER_NAME_INDICATION defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_THREADING_PTHREAD)
X#if 0L
S#if !defined(MBEDTLS_THREADING_C) || defined(MBEDTLS_THREADING_IMPL)
S#error "MBEDTLS_THREADING_PTHREAD defined, but not all prerequisites"
S#endif
S#define MBEDTLS_THREADING_IMPL
N#endif
N
N#if defined(MBEDTLS_THREADING_ALT)
X#if 0L
S#if !defined(MBEDTLS_THREADING_C) || defined(MBEDTLS_THREADING_IMPL)
S#error "MBEDTLS_THREADING_ALT defined, but not all prerequisites"
S#endif
S#define MBEDTLS_THREADING_IMPL
N#endif
N
N#if defined(MBEDTLS_THREADING_C) && !defined(MBEDTLS_THREADING_IMPL)
X#if 0L && !0L
S#error "MBEDTLS_THREADING_C defined, single threading implementation required"
N#endif
N#undef MBEDTLS_THREADING_IMPL
N
N#if defined(MBEDTLS_VERSION_FEATURES) && !defined(MBEDTLS_VERSION_C)
X#if 0L && !0L
S#error "MBEDTLS_VERSION_FEATURES defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_USE_C) && ( !defined(MBEDTLS_BIGNUM_C) ||  \
N    !defined(MBEDTLS_OID_C) || !defined(MBEDTLS_ASN1_PARSE_C) ||      \
N    !defined(MBEDTLS_PK_PARSE_C) )
X#if 0L && ( !0L ||      !0L || !0L ||          !0L )
S#error "MBEDTLS_X509_USE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CREATE_C) && ( !defined(MBEDTLS_BIGNUM_C) ||  \
N    !defined(MBEDTLS_OID_C) || !defined(MBEDTLS_ASN1_WRITE_C) ||       \
N    !defined(MBEDTLS_PK_WRITE_C) )
X#if 0L && ( !0L ||      !0L || !0L ||           !0L )
S#error "MBEDTLS_X509_CREATE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CRT_PARSE_C) && ( !defined(MBEDTLS_X509_USE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CRT_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CRL_PARSE_C) && ( !defined(MBEDTLS_X509_USE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CRL_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CSR_PARSE_C) && ( !defined(MBEDTLS_X509_USE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CSR_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CRT_WRITE_C) && ( !defined(MBEDTLS_X509_CREATE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CRT_WRITE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CSR_WRITE_C) && ( !defined(MBEDTLS_X509_CREATE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CSR_WRITE_C defined, but not all prerequisites"
N#endif
N
N/*
N * Avoid warning from -pedantic. This is a convenient place for this
N * workaround since this is included by every single file before the
N * #if defined(MBEDTLS_xxx_C) that results in emtpy translation units.
N */
Ntypedef int mbedtls_iso_c_forbids_empty_translation_units;
N
N#endif /* MBEDTLS_CHECK_CONFIG_H */
L 186 ".\RTE\Security\mbedTLS_config.h" 2
N
N#endif /* MBEDTLS_CONFIG_H */
L 30 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls/config.h" 2
N#endif
N
N#ifndef MBEDTLS_CONFIG_H
S#define MBEDTLS_CONFIG_H
S
S#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
S#define _CRT_SECURE_NO_DEPRECATE 1
S#endif
S
S/**
S * \name SECTION: System support
S *
S * This section sets system specific settings.
S * \{
S */
S
S/**
S * \def MBEDTLS_HAVE_ASM
S *
S * The compiler has support for asm().
S *
S * Requires support for asm() in compiler.
S *
S * Used in:
S *      library/timing.c
S *      library/padlock.c
S *      include/mbedtls/bn_mul.h
S *
S * Comment to disable the use of assembly code.
S */
S#define MBEDTLS_HAVE_ASM
S
S/**
S * \def MBEDTLS_HAVE_SSE2
S *
S * CPU supports SSE2 instruction set.
S *
S * Uncomment if the CPU supports SSE2 (IA-32 specific).
S */
S//#define MBEDTLS_HAVE_SSE2
S
S/**
S * \def MBEDTLS_HAVE_TIME
S *
S * System has time.h and time().
S * The time does not need to be correct, only time differences are used,
S * by contrast with MBEDTLS_HAVE_TIME_DATE
S *
S * Comment if your system does not support time functions
S */
S#define MBEDTLS_HAVE_TIME
S
S/**
S * \def MBEDTLS_HAVE_TIME_DATE
S *
S * System has time.h and time(), gmtime() and the clock is correct.
S * The time needs to be correct (not necesarily very accurate, but at least
S * the date should be correct). This is used to verify the validity period of
S * X.509 certificates.
S *
S * Comment if your system does not have a correct clock.
S */
S#define MBEDTLS_HAVE_TIME_DATE
S
S/**
S * \def MBEDTLS_PLATFORM_MEMORY
S *
S * Enable the memory allocation layer.
S *
S * By default mbed TLS uses the system-provided calloc() and free().
S * This allows different allocators (self-implemented or provided) to be
S * provided to the platform abstraction layer.
S *
S * Enabling MBEDTLS_PLATFORM_MEMORY without the
S * MBEDTLS_PLATFORM_{FREE,CALLOC}_MACROs will provide
S * "mbedtls_platform_set_calloc_free()" allowing you to set an alternative calloc() and
S * free() function pointer at runtime.
S *
S * Enabling MBEDTLS_PLATFORM_MEMORY and specifying
S * MBEDTLS_PLATFORM_{CALLOC,FREE}_MACROs will allow you to specify the
S * alternate function at compile time.
S *
S * Requires: MBEDTLS_PLATFORM_C
S *
S * Enable this layer to allow use of alternative memory allocators.
S */
S//#define MBEDTLS_PLATFORM_MEMORY
S
S/**
S * \def MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
S *
S * Do not assign standard functions in the platform layer (e.g. calloc() to
S * MBEDTLS_PLATFORM_STD_CALLOC and printf() to MBEDTLS_PLATFORM_STD_PRINTF)
S *
S * This makes sure there are no linking errors on platforms that do not support
S * these functions. You will HAVE to provide alternatives, either at runtime
S * via the platform_set_xxx() functions or at compile time by setting
S * the MBEDTLS_PLATFORM_STD_XXX defines, or enabling a
S * MBEDTLS_PLATFORM_XXX_MACRO.
S *
S * Requires: MBEDTLS_PLATFORM_C
S *
S * Uncomment to prevent default assignment of standard functions in the
S * platform layer.
S */
S//#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
S
S/**
S * \def MBEDTLS_PLATFORM_EXIT_ALT
S *
S * MBEDTLS_PLATFORM_XXX_ALT: Uncomment a macro to let mbed TLS support the
S * function in the platform abstraction layer.
S *
S * Example: In case you uncomment MBEDTLS_PLATFORM_PRINTF_ALT, mbed TLS will
S * provide a function "mbedtls_platform_set_printf()" that allows you to set an
S * alternative printf function pointer.
S *
S * All these define require MBEDTLS_PLATFORM_C to be defined!
S *
S * \note MBEDTLS_PLATFORM_SNPRINTF_ALT is required on Windows;
S * it will be enabled automatically by check_config.h
S *
S * \warning MBEDTLS_PLATFORM_XXX_ALT cannot be defined at the same time as
S * MBEDTLS_PLATFORM_XXX_MACRO!
S *
S * Uncomment a macro to enable alternate implementation of specific base
S * platform function
S */
S//#define MBEDTLS_PLATFORM_EXIT_ALT
S//#define MBEDTLS_PLATFORM_FPRINTF_ALT
S//#define MBEDTLS_PLATFORM_PRINTF_ALT
S//#define MBEDTLS_PLATFORM_SNPRINTF_ALT
S
S/**
S * \def MBEDTLS_DEPRECATED_WARNING
S *
S * Mark deprecated functions so that they generate a warning if used.
S * Functions deprecated in one version will usually be removed in the next
S * version. You can enable this to help you prepare the transition to a new
S * major version by making sure your code is not using these functions.
S *
S * This only works with GCC and Clang. With other compilers, you may want to
S * use MBEDTLS_DEPRECATED_REMOVED
S *
S * Uncomment to get warnings on using deprecated functions.
S */
S//#define MBEDTLS_DEPRECATED_WARNING
S
S/**
S * \def MBEDTLS_DEPRECATED_REMOVED
S *
S * Remove deprecated functions so that they generate an error if used.
S * Functions deprecated in one version will usually be removed in the next
S * version. You can enable this to help you prepare the transition to a new
S * major version by making sure your code is not using these functions.
S *
S * Uncomment to get errors on using deprecated functions.
S */
S//#define MBEDTLS_DEPRECATED_REMOVED
S
S/* \} name SECTION: System support */
S
S/**
S * \name SECTION: mbed TLS feature support
S *
S * This section sets support for features that are or are not needed
S * within the modules that are enabled.
S * \{
S */
S
S/**
S * \def MBEDTLS_TIMING_ALT
S *
S * Uncomment to provide your own alternate implementation for mbedtls_timing_hardclock(),
S * mbedtls_timing_get_timer(), mbedtls_set_alarm(), mbedtls_set/get_delay()
S *
S * Only works if you have MBEDTLS_TIMING_C enabled.
S *
S * You will need to provide a header "timing_alt.h" and an implementation at
S * compile time.
S */
S//#define MBEDTLS_TIMING_ALT
S
S/**
S * \def MBEDTLS_AES_ALT
S *
S * MBEDTLS__MODULE_NAME__ALT: Uncomment a macro to let mbed TLS use your
S * alternate core implementation of a symmetric crypto or hash module (e.g.
S * platform specific assembly optimized implementations). Keep in mind that
S * the function prototypes should remain the same.
S *
S * This replaces the whole module. If you only want to replace one of the
S * functions, use one of the MBEDTLS__FUNCTION_NAME__ALT flags.
S *
S * Example: In case you uncomment MBEDTLS_AES_ALT, mbed TLS will no longer
S * provide the "struct mbedtls_aes_context" definition and omit the base function
S * declarations and implementations. "aes_alt.h" will be included from
S * "aes.h" to include the new function definitions.
S *
S * Uncomment a macro to enable alternate implementation of the corresponding
S * module.
S */
S//#define MBEDTLS_AES_ALT
S//#define MBEDTLS_ARC4_ALT
S//#define MBEDTLS_BLOWFISH_ALT
S//#define MBEDTLS_CAMELLIA_ALT
S//#define MBEDTLS_DES_ALT
S//#define MBEDTLS_XTEA_ALT
S//#define MBEDTLS_MD2_ALT
S//#define MBEDTLS_MD4_ALT
S//#define MBEDTLS_MD5_ALT
S//#define MBEDTLS_RIPEMD160_ALT
S//#define MBEDTLS_SHA1_ALT
S//#define MBEDTLS_SHA256_ALT
S//#define MBEDTLS_SHA512_ALT
S
S/**
S * \def MBEDTLS_MD2_PROCESS_ALT
S *
S * MBEDTLS__FUNCTION_NAME__ALT: Uncomment a macro to let mbed TLS use you
S * alternate core implementation of symmetric crypto or hash function. Keep in
S * mind that function prototypes should remain the same.
S *
S * This replaces only one function. The header file from mbed TLS is still
S * used, in contrast to the MBEDTLS__MODULE_NAME__ALT flags.
S *
S * Example: In case you uncomment MBEDTLS_SHA256_PROCESS_ALT, mbed TLS will
S * no longer provide the mbedtls_sha1_process() function, but it will still provide
S * the other function (using your mbedtls_sha1_process() function) and the definition
S * of mbedtls_sha1_context, so your implementation of mbedtls_sha1_process must be compatible
S * with this definition.
S *
S * Note: if you use the AES_xxx_ALT macros, then is is recommended to also set
S * MBEDTLS_AES_ROM_TABLES in order to help the linker garbage-collect the AES
S * tables.
S *
S * Uncomment a macro to enable alternate implementation of the corresponding
S * function.
S */
S//#define MBEDTLS_MD2_PROCESS_ALT
S//#define MBEDTLS_MD4_PROCESS_ALT
S//#define MBEDTLS_MD5_PROCESS_ALT
S//#define MBEDTLS_RIPEMD160_PROCESS_ALT
S//#define MBEDTLS_SHA1_PROCESS_ALT
S//#define MBEDTLS_SHA256_PROCESS_ALT
S//#define MBEDTLS_SHA512_PROCESS_ALT
S//#define MBEDTLS_DES_SETKEY_ALT
S//#define MBEDTLS_DES_CRYPT_ECB_ALT
S//#define MBEDTLS_DES3_CRYPT_ECB_ALT
S//#define MBEDTLS_AES_SETKEY_ENC_ALT
S//#define MBEDTLS_AES_SETKEY_DEC_ALT
S//#define MBEDTLS_AES_ENCRYPT_ALT
S//#define MBEDTLS_AES_DECRYPT_ALT
S
S/**
S * \def MBEDTLS_ENTROPY_HARDWARE_ALT
S *
S * Uncomment this macro to let mbed TLS use your own implementation of a
S * hardware entropy collector.
S *
S * Your function must be called \c mbedtls_hardware_poll(), have the same
S * prototype as declared in entropy_poll.h, and accept NULL as first argument.
S *
S * Uncomment to use your own hardware entropy collector.
S */
S//#define MBEDTLS_ENTROPY_HARDWARE_ALT
S
S/**
S * \def MBEDTLS_AES_ROM_TABLES
S *
S * Store the AES tables in ROM.
S *
S * Uncomment this macro to store the AES tables in ROM.
S */
S//#define MBEDTLS_AES_ROM_TABLES
S
S/**
S * \def MBEDTLS_CAMELLIA_SMALL_MEMORY
S *
S * Use less ROM for the Camellia implementation (saves about 768 bytes).
S *
S * Uncomment this macro to use less memory for Camellia.
S */
S//#define MBEDTLS_CAMELLIA_SMALL_MEMORY
S
S/**
S * \def MBEDTLS_CIPHER_MODE_CBC
S *
S * Enable Cipher Block Chaining mode (CBC) for symmetric ciphers.
S */
S#define MBEDTLS_CIPHER_MODE_CBC
S
S/**
S * \def MBEDTLS_CIPHER_MODE_CFB
S *
S * Enable Cipher Feedback mode (CFB) for symmetric ciphers.
S */
S#define MBEDTLS_CIPHER_MODE_CFB
S
S/**
S * \def MBEDTLS_CIPHER_MODE_CTR
S *
S * Enable Counter Block Cipher mode (CTR) for symmetric ciphers.
S */
S#define MBEDTLS_CIPHER_MODE_CTR
S
S/**
S * \def MBEDTLS_CIPHER_NULL_CIPHER
S *
S * Enable NULL cipher.
S * Warning: Only do so when you know what you are doing. This allows for
S * encryption or channels without any security!
S *
S * Requires MBEDTLS_ENABLE_WEAK_CIPHERSUITES as well to enable
S * the following ciphersuites:
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA
S *      MBEDTLS_TLS_RSA_WITH_NULL_SHA256
S *      MBEDTLS_TLS_RSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_RSA_WITH_NULL_MD5
S *      MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA
S *      MBEDTLS_TLS_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_PSK_WITH_NULL_SHA
S *
S * Uncomment this macro to enable the NULL cipher and ciphersuites
S */
S//#define MBEDTLS_CIPHER_NULL_CIPHER
S
S/**
S * \def MBEDTLS_CIPHER_PADDING_PKCS7
S *
S * MBEDTLS_CIPHER_PADDING_XXX: Uncomment or comment macros to add support for
S * specific padding modes in the cipher layer with cipher modes that support
S * padding (e.g. CBC)
S *
S * If you disable all padding modes, only full blocks can be used with CBC.
S *
S * Enable padding modes in the cipher layer.
S */
S#define MBEDTLS_CIPHER_PADDING_PKCS7
S#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
S#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
S#define MBEDTLS_CIPHER_PADDING_ZEROS
S
S/**
S * \def MBEDTLS_ENABLE_WEAK_CIPHERSUITES
S *
S * Enable weak ciphersuites in SSL / TLS.
S * Warning: Only do so when you know what you are doing. This allows for
S * channels with virtually no security at all!
S *
S * This enables the following ciphersuites:
S *      MBEDTLS_TLS_RSA_WITH_DES_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_DES_CBC_SHA
S *
S * Uncomment this macro to enable weak ciphersuites
S */
S//#define MBEDTLS_ENABLE_WEAK_CIPHERSUITES
S
S/**
S * \def MBEDTLS_REMOVE_ARC4_CIPHERSUITES
S *
S * Remove RC4 ciphersuites by default in SSL / TLS.
S * This flag removes the ciphersuites based on RC4 from the default list as
S * returned by mbedtls_ssl_list_ciphersuites(). However, it is still possible to
S * enable (some of) them with mbedtls_ssl_conf_ciphersuites() by including them
S * explicitly.
S *
S * Uncomment this macro to remove RC4 ciphersuites by default.
S */
S#define MBEDTLS_REMOVE_ARC4_CIPHERSUITES
S
S/**
S * \def MBEDTLS_ECP_DP_SECP192R1_ENABLED
S *
S * MBEDTLS_ECP_XXXX_ENABLED: Enables specific curves within the Elliptic Curve
S * module.  By default all supported curves are enabled.
S *
S * Comment macros to disable the curve and functions for it
S */
S#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
S#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
S#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
S#define MBEDTLS_ECP_DP_BP256R1_ENABLED
S#define MBEDTLS_ECP_DP_BP384R1_ENABLED
S#define MBEDTLS_ECP_DP_BP512R1_ENABLED
S#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
S
S/**
S * \def MBEDTLS_ECP_NIST_OPTIM
S *
S * Enable specific 'modulo p' routines for each NIST prime.
S * Depending on the prime and architecture, makes operations 4 to 8 times
S * faster on the corresponding curve.
S *
S * Comment this macro to disable NIST curves optimisation.
S */
S#define MBEDTLS_ECP_NIST_OPTIM
S
S/**
S * \def MBEDTLS_ECDSA_DETERMINISTIC
S *
S * Enable deterministic ECDSA (RFC 6979).
S * Standard ECDSA is "fragile" in the sense that lack of entropy when signing
S * may result in a compromise of the long-term signing key. This is avoided by
S * the deterministic variant.
S *
S * Requires: MBEDTLS_HMAC_DRBG_C
S *
S * Comment this macro to disable deterministic ECDSA.
S */
S#define MBEDTLS_ECDSA_DETERMINISTIC
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
S *
S * Enable the PSK based ciphersuite modes in SSL / TLS.
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
S *
S * Enable the DHE-PSK based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_DHM_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
S *
S * Enable the ECDHE-PSK based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
S *
S * Enable the RSA-PSK based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
S *
S * Enable the RSA-only based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_MD5
S */
S#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
S *
S * Enable the DHE-RSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_DHM_C, MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
S *
S * Enable the ECDHE-RSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
S *
S * Enable the ECDHE-ECDSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_ECDSA_C, MBEDTLS_X509_CRT_PARSE_C,
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
S *
S * Enable the ECDH-ECDSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
S *
S * Enable the ECDH-RSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
S *
S * Enable the ECJPAKE based ciphersuite modes in SSL / TLS.
S *
S * \warning This is currently experimental. EC J-PAKE support is based on the
S * Thread v1.0.0 specification; incompatible changes to the specification
S * might still happen. For this reason, this is disabled by default.
S *
S * Requires: MBEDTLS_ECJPAKE_C
S *           MBEDTLS_SHA256_C
S *           MBEDTLS_ECP_DP_SECP256R1_ENABLED
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECJPAKE_WITH_AES_128_CCM_8
S */
S//#define MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
S
S/**
S * \def MBEDTLS_PK_PARSE_EC_EXTENDED
S *
S * Enhance support for reading EC keys using variants of SEC1 not allowed by
S * RFC 5915 and RFC 5480.
S *
S * Currently this means parsing the SpecifiedECDomain choice of EC
S * parameters (only known groups are supported, not arbitrary domains, to
S * avoid validation issues).
S *
S * Disable if you only need to support RFC 5915 + 5480 key formats.
S */
S#define MBEDTLS_PK_PARSE_EC_EXTENDED
S
S/**
S * \def MBEDTLS_ERROR_STRERROR_DUMMY
S *
S * Enable a dummy error function to make use of mbedtls_strerror() in
S * third party libraries easier when MBEDTLS_ERROR_C is disabled
S * (no effect when MBEDTLS_ERROR_C is enabled).
S *
S * You can safely disable this if MBEDTLS_ERROR_C is enabled, or if you're
S * not using mbedtls_strerror() or error_strerror() in your application.
S *
S * Disable if you run into name conflicts and want to really remove the
S * mbedtls_strerror()
S */
S#define MBEDTLS_ERROR_STRERROR_DUMMY
S
S/**
S * \def MBEDTLS_GENPRIME
S *
S * Enable the prime-number generation code.
S *
S * Requires: MBEDTLS_BIGNUM_C
S */
S#define MBEDTLS_GENPRIME
S
S/**
S * \def MBEDTLS_FS_IO
S *
S * Enable functions that use the filesystem.
S */
S#define MBEDTLS_FS_IO
S
S/**
S * \def MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
S *
S * Do not add default entropy sources. These are the platform specific,
S * mbedtls_timing_hardclock and HAVEGE based poll functions.
S *
S * This is useful to have more control over the added entropy sources in an
S * application.
S *
S * Uncomment this macro to prevent loading of default entropy functions.
S */
S//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
S
S/**
S * \def MBEDTLS_NO_PLATFORM_ENTROPY
S *
S * Do not use built-in platform entropy functions.
S * This is useful if your platform does not support
S * standards like the /dev/urandom or Windows CryptoAPI.
S *
S * Uncomment this macro to disable the built-in platform entropy functions.
S */
S//#define MBEDTLS_NO_PLATFORM_ENTROPY
S
S/**
S * \def MBEDTLS_ENTROPY_FORCE_SHA256
S *
S * Force the entropy accumulator to use a SHA-256 accumulator instead of the
S * default SHA-512 based one (if both are available).
S *
S * Requires: MBEDTLS_SHA256_C
S *
S * On 32-bit systems SHA-256 can be much faster than SHA-512. Use this option
S * if you have performance concerns.
S *
S * This option is only useful if both MBEDTLS_SHA256_C and
S * MBEDTLS_SHA512_C are defined. Otherwise the available hash module is used.
S */
S//#define MBEDTLS_ENTROPY_FORCE_SHA256
S
S/**
S * \def MBEDTLS_MEMORY_DEBUG
S *
S * Enable debugging of buffer allocator memory issues. Automatically prints
S * (to stderr) all (fatal) messages on memory allocation issues. Enables
S * function for 'debug output' of allocated memory.
S *
S * Requires: MBEDTLS_MEMORY_BUFFER_ALLOC_C
S *
S * Uncomment this macro to let the buffer allocator print out error messages.
S */
S//#define MBEDTLS_MEMORY_DEBUG
S
S/**
S * \def MBEDTLS_MEMORY_BACKTRACE
S *
S * Include backtrace information with each allocated block.
S *
S * Requires: MBEDTLS_MEMORY_BUFFER_ALLOC_C
S *           GLIBC-compatible backtrace() an backtrace_symbols() support
S *
S * Uncomment this macro to include backtrace information
S */
S//#define MBEDTLS_MEMORY_BACKTRACE
S
S/**
S * \def MBEDTLS_PK_RSA_ALT_SUPPORT
S *
S * Support external private RSA keys (eg from a HSM) in the PK layer.
S *
S * Comment this macro to disable support for external private RSA keys.
S */
S#define MBEDTLS_PK_RSA_ALT_SUPPORT
S
S/**
S * \def MBEDTLS_PKCS1_V15
S *
S * Enable support for PKCS#1 v1.5 encoding.
S *
S * Requires: MBEDTLS_RSA_C
S *
S * This enables support for PKCS#1 v1.5 operations.
S */
S#define MBEDTLS_PKCS1_V15
S
S/**
S * \def MBEDTLS_PKCS1_V21
S *
S * Enable support for PKCS#1 v2.1 encoding.
S *
S * Requires: MBEDTLS_MD_C, MBEDTLS_RSA_C
S *
S * This enables support for RSAES-OAEP and RSASSA-PSS operations.
S */
S#define MBEDTLS_PKCS1_V21
S
S/**
S * \def MBEDTLS_RSA_NO_CRT
S *
S * Do not use the Chinese Remainder Theorem for the RSA private operation.
S *
S * Uncomment this macro to disable the use of CRT in RSA.
S *
S */
S//#define MBEDTLS_RSA_NO_CRT
S
S/**
S * \def MBEDTLS_SELF_TEST
S *
S * Enable the checkup functions (*_self_test).
S */
S#define MBEDTLS_SELF_TEST
S
S/**
S * \def MBEDTLS_SHA256_SMALLER
S *
S * Enable an implementation of SHA-256 that has lower ROM footprint but also
S * lower performance.
S *
S * The default implementation is meant to be a reasonnable compromise between
S * performance and size. This version optimizes more aggressively for size at
S * the expense of performance. Eg on Cortex-M4 it reduces the size of
S * mbedtls_sha256_process() from ~2KB to ~0.5KB for a performance hit of about
S * 30%.
S *
S * Uncomment to enable the smaller implementation of SHA256.
S */
S//#define MBEDTLS_SHA256_SMALLER
S
S/**
S * \def MBEDTLS_SSL_AEAD_RANDOM_IV
S *
S * Generate a random IV rather than using the record sequence number as a
S * nonce for ciphersuites using and AEAD algorithm (GCM or CCM).
S *
S * Using the sequence number is generally recommended.
S *
S * Uncomment this macro to always use random IVs with AEAD ciphersuites.
S */
S//#define MBEDTLS_SSL_AEAD_RANDOM_IV
S
S/**
S * \def MBEDTLS_SSL_ALL_ALERT_MESSAGES
S *
S * Enable sending of alert messages in case of encountered errors as per RFC.
S * If you choose not to send the alert messages, mbed TLS can still communicate
S * with other servers, only debugging of failures is harder.
S *
S * The advantage of not sending alert messages, is that no information is given
S * about reasons for failures thus preventing adversaries of gaining intel.
S *
S * Enable sending of all alert messages
S */
S#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
S
S/**
S * \def MBEDTLS_SSL_DEBUG_ALL
S *
S * Enable the debug messages in SSL module for all issues.
S * Debug messages have been disabled in some places to prevent timing
S * attacks due to (unbalanced) debugging function calls.
S *
S * If you need all error reporting you should enable this during debugging,
S * but remove this for production servers that should log as well.
S *
S * Uncomment this macro to report all debug messages on errors introducing
S * a timing side-channel.
S *
S */
S//#define MBEDTLS_SSL_DEBUG_ALL
S
S/** \def MBEDTLS_SSL_ENCRYPT_THEN_MAC
S *
S * Enable support for Encrypt-then-MAC, RFC 7366.
S *
S * This allows peers that both support it to use a more robust protection for
S * ciphersuites using CBC, providing deep resistance against timing attacks
S * on the padding or underlying cipher.
S *
S * This only affects CBC ciphersuites, and is useless if none is defined.
S *
S * Requires: MBEDTLS_SSL_PROTO_TLS1    or
S *           MBEDTLS_SSL_PROTO_TLS1_1  or
S *           MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Comment this macro to disable support for Encrypt-then-MAC
S */
S#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
S
S/** \def MBEDTLS_SSL_EXTENDED_MASTER_SECRET
S *
S * Enable support for Extended Master Secret, aka Session Hash
S * (draft-ietf-tls-session-hash-02).
S *
S * This was introduced as "the proper fix" to the Triple Handshake familiy of
S * attacks, but it is recommended to always use it (even if you disable
S * renegotiation), since it actually fixes a more fundamental issue in the
S * original SSL/TLS design, and has implications beyond Triple Handshake.
S *
S * Requires: MBEDTLS_SSL_PROTO_TLS1    or
S *           MBEDTLS_SSL_PROTO_TLS1_1  or
S *           MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Comment this macro to disable support for Extended Master Secret.
S */
S#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
S
S/**
S * \def MBEDTLS_SSL_FALLBACK_SCSV
S *
S * Enable support for FALLBACK_SCSV (draft-ietf-tls-downgrade-scsv-00).
S *
S * For servers, it is recommended to always enable this, unless you support
S * only one version of TLS, or know for sure that none of your clients
S * implements a fallback strategy.
S *
S * For clients, you only need this if you're using a fallback strategy, which
S * is not recommended in the first place, unless you absolutely need it to
S * interoperate with buggy (version-intolerant) servers.
S *
S * Comment this macro to disable support for FALLBACK_SCSV
S */
S#define MBEDTLS_SSL_FALLBACK_SCSV
S
S/**
S * \def MBEDTLS_SSL_HW_RECORD_ACCEL
S *
S * Enable hooking functions in SSL module for hardware acceleration of
S * individual records.
S *
S * Uncomment this macro to enable hooking functions.
S */
S//#define MBEDTLS_SSL_HW_RECORD_ACCEL
S
S/**
S * \def MBEDTLS_SSL_CBC_RECORD_SPLITTING
S *
S * Enable 1/n-1 record splitting for CBC mode in SSLv3 and TLS 1.0.
S *
S * This is a countermeasure to the BEAST attack, which also minimizes the risk
S * of interoperability issues compared to sending 0-length records.
S *
S * Comment this macro to disable 1/n-1 record splitting.
S */
S#define MBEDTLS_SSL_CBC_RECORD_SPLITTING
S
S/**
S * \def MBEDTLS_SSL_RENEGOTIATION
S *
S * Disable support for TLS renegotiation.
S *
S * The two main uses of renegotiation are (1) refresh keys on long-lived
S * connections and (2) client authentication after the initial handshake.
S * If you don't need renegotiation, it's probably better to disable it, since
S * it has been associated with security issues in the past and is easy to
S * misuse/misunderstand.
S *
S * Comment this to disable support for renegotiation.
S */
S#define MBEDTLS_SSL_RENEGOTIATION
S
S/**
S * \def MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
S *
S * Enable support for receiving and parsing SSLv2 Client Hello messages for the
S * SSL Server module (MBEDTLS_SSL_SRV_C).
S *
S * Uncomment this macro to enable support for SSLv2 Client Hello messages.
S */
S//#define MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
S
S/**
S * \def MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE
S *
S * Pick the ciphersuite according to the client's preferences rather than ours
S * in the SSL Server module (MBEDTLS_SSL_SRV_C).
S *
S * Uncomment this macro to respect client's ciphersuite order
S */
S//#define MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE
S
S/**
S * \def MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
S *
S * Enable support for RFC 6066 max_fragment_length extension in SSL.
S *
S * Comment this macro to disable support for the max_fragment_length extension
S */
S#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
S
S/**
S * \def MBEDTLS_SSL_PROTO_SSL3
S *
S * Enable support for SSL 3.0.
S *
S * Requires: MBEDTLS_MD5_C
S *           MBEDTLS_SHA1_C
S *
S * Comment this macro to disable support for SSL 3.0
S */
S#define MBEDTLS_SSL_PROTO_SSL3
S
S/**
S * \def MBEDTLS_SSL_PROTO_TLS1
S *
S * Enable support for TLS 1.0.
S *
S * Requires: MBEDTLS_MD5_C
S *           MBEDTLS_SHA1_C
S *
S * Comment this macro to disable support for TLS 1.0
S */
S#define MBEDTLS_SSL_PROTO_TLS1
S
S/**
S * \def MBEDTLS_SSL_PROTO_TLS1_1
S *
S * Enable support for TLS 1.1 (and DTLS 1.0 if DTLS is enabled).
S *
S * Requires: MBEDTLS_MD5_C
S *           MBEDTLS_SHA1_C
S *
S * Comment this macro to disable support for TLS 1.1 / DTLS 1.0
S */
S#define MBEDTLS_SSL_PROTO_TLS1_1
S
S/**
S * \def MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Enable support for TLS 1.2 (and DTLS 1.2 if DTLS is enabled).
S *
S * Requires: MBEDTLS_SHA1_C or MBEDTLS_SHA256_C or MBEDTLS_SHA512_C
S *           (Depends on ciphersuites)
S *
S * Comment this macro to disable support for TLS 1.2 / DTLS 1.2
S */
S#define MBEDTLS_SSL_PROTO_TLS1_2
S
S/**
S * \def MBEDTLS_SSL_PROTO_DTLS
S *
S * Enable support for DTLS (all available versions).
S *
S * Enable this and MBEDTLS_SSL_PROTO_TLS1_1 to enable DTLS 1.0,
S * and/or this and MBEDTLS_SSL_PROTO_TLS1_2 to enable DTLS 1.2.
S *
S * Requires: MBEDTLS_SSL_PROTO_TLS1_1
S *        or MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Comment this macro to disable support for DTLS
S */
S#define MBEDTLS_SSL_PROTO_DTLS
S
S/**
S * \def MBEDTLS_SSL_ALPN
S *
S * Enable support for RFC 7301 Application Layer Protocol Negotiation.
S *
S * Comment this macro to disable support for ALPN.
S */
S#define MBEDTLS_SSL_ALPN
S
S/**
S * \def MBEDTLS_SSL_DTLS_ANTI_REPLAY
S *
S * Enable support for the anti-replay mechanism in DTLS.
S *
S * Requires: MBEDTLS_SSL_TLS_C
S *           MBEDTLS_SSL_PROTO_DTLS
S *
S * \warning Disabling this is often a security risk!
S * See mbedtls_ssl_conf_dtls_anti_replay() for details.
S *
S * Comment this to disable anti-replay in DTLS.
S */
S#define MBEDTLS_SSL_DTLS_ANTI_REPLAY
S
S/**
S * \def MBEDTLS_SSL_DTLS_HELLO_VERIFY
S *
S * Enable support for HelloVerifyRequest on DTLS servers.
S *
S * This feature is highly recommended to prevent DTLS servers being used as
S * amplifiers in DoS attacks against other hosts. It should always be enabled
S * unless you know for sure amplification cannot be a problem in the
S * environment in which your server operates.
S *
S * \warning Disabling this can ba a security risk! (see above)
S *
S * Requires: MBEDTLS_SSL_PROTO_DTLS
S *
S * Comment this to disable support for HelloVerifyRequest.
S */
S#define MBEDTLS_SSL_DTLS_HELLO_VERIFY
S
S/**
S * \def MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
S *
S * Enable server-side support for clients that reconnect from the same port.
S *
S * Some clients unexpectedly close the connection and try to reconnect using the
S * same source port. This needs special support from the server to handle the
S * new connection securely, as described in section 4.2.8 of RFC 6347. This
S * flag enables that support.
S *
S * Requires: MBEDTLS_SSL_DTLS_HELLO_VERIFY
S *
S * Comment this to disable support for clients reusing the source port.
S */
S#define MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
S
S/**
S * \def MBEDTLS_SSL_DTLS_BADMAC_LIMIT
S *
S * Enable support for a limit of records with bad MAC.
S *
S * See mbedtls_ssl_conf_dtls_badmac_limit().
S *
S * Requires: MBEDTLS_SSL_PROTO_DTLS
S */
S#define MBEDTLS_SSL_DTLS_BADMAC_LIMIT
S
S/**
S * \def MBEDTLS_SSL_SESSION_TICKETS
S *
S * Enable support for RFC 5077 session tickets in SSL.
S * Client-side, provides full support for session tickets (maintainance of a
S * session store remains the responsibility of the application, though).
S * Server-side, you also need to provide callbacks for writing and parsing
S * tickets, including authenticated encryption and key management. Example
S * callbacks are provided by MBEDTLS_SSL_TICKET_C.
S *
S * Comment this macro to disable support for SSL session tickets
S */
S#define MBEDTLS_SSL_SESSION_TICKETS
S
S/**
S * \def MBEDTLS_SSL_EXPORT_KEYS
S *
S * Enable support for exporting key block and master secret.
S * This is required for certain users of TLS, e.g. EAP-TLS.
S *
S * Comment this macro to disable support for key export
S */
S#define MBEDTLS_SSL_EXPORT_KEYS
S
S/**
S * \def MBEDTLS_SSL_SERVER_NAME_INDICATION
S *
S * Enable support for RFC 6066 server name indication (SNI) in SSL.
S *
S * Requires: MBEDTLS_X509_CRT_PARSE_C
S *
S * Comment this macro to disable support for server name indication in SSL
S */
S#define MBEDTLS_SSL_SERVER_NAME_INDICATION
S
S/**
S * \def MBEDTLS_SSL_TRUNCATED_HMAC
S *
S * Enable support for RFC 6066 truncated HMAC in SSL.
S *
S * Comment this macro to disable support for truncated HMAC in SSL
S */
S#define MBEDTLS_SSL_TRUNCATED_HMAC
S
S/**
S * \def MBEDTLS_THREADING_ALT
S *
S * Provide your own alternate threading implementation.
S *
S * Requires: MBEDTLS_THREADING_C
S *
S * Uncomment this to allow your own alternate threading implementation.
S */
S//#define MBEDTLS_THREADING_ALT
S
S/**
S * \def MBEDTLS_THREADING_PTHREAD
S *
S * Enable the pthread wrapper layer for the threading layer.
S *
S * Requires: MBEDTLS_THREADING_C
S *
S * Uncomment this to enable pthread mutexes.
S */
S//#define MBEDTLS_THREADING_PTHREAD
S
S/**
S * \def MBEDTLS_VERSION_FEATURES
S *
S * Allow run-time checking of compile-time enabled features. Thus allowing users
S * to check at run-time if the library is for instance compiled with threading
S * support via mbedtls_version_check_feature().
S *
S * Requires: MBEDTLS_VERSION_C
S *
S * Comment this to disable run-time checking and save ROM space
S */
S#define MBEDTLS_VERSION_FEATURES
S
S/**
S * \def MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3
S *
S * If set, the X509 parser will not break-off when parsing an X509 certificate
S * and encountering an extension in a v1 or v2 certificate.
S *
S * Uncomment to prevent an error.
S */
S//#define MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3
S
S/**
S * \def MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
S *
S * If set, the X509 parser will not break-off when parsing an X509 certificate
S * and encountering an unknown critical extension.
S *
S * \warning Depending on your PKI use, enabling this can be a security risk!
S *
S * Uncomment to prevent an error.
S */
S//#define MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
S
S/**
S * \def MBEDTLS_X509_CHECK_KEY_USAGE
S *
S * Enable verification of the keyUsage extension (CA and leaf certificates).
S *
S * Disabling this avoids problems with mis-issued and/or misused
S * (intermediate) CA and leaf certificates.
S *
S * \warning Depending on your PKI use, disabling this can be a security risk!
S *
S * Comment to skip keyUsage checking for both CA and leaf certificates.
S */
S#define MBEDTLS_X509_CHECK_KEY_USAGE
S
S/**
S * \def MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
S *
S * Enable verification of the extendedKeyUsage extension (leaf certificates).
S *
S * Disabling this avoids problems with mis-issued and/or misused certificates.
S *
S * \warning Depending on your PKI use, disabling this can be a security risk!
S *
S * Comment to skip extendedKeyUsage checking for certificates.
S */
S#define MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
S
S/**
S * \def MBEDTLS_X509_RSASSA_PSS_SUPPORT
S *
S * Enable parsing and verification of X.509 certificates, CRLs and CSRS
S * signed with RSASSA-PSS (aka PKCS#1 v2.1).
S *
S * Comment this macro to disallow using RSASSA-PSS in certificates.
S */
S#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
S
S/**
S * \def MBEDTLS_ZLIB_SUPPORT
S *
S * If set, the SSL/TLS module uses ZLIB to support compression and
S * decompression of packet data.
S *
S * \warning TLS-level compression MAY REDUCE SECURITY! See for example the
S * CRIME attack. Before enabling this option, you should examine with care if
S * CRIME or similar exploits may be a applicable to your use case.
S *
S * \note Currently compression can't be used with DTLS.
S *
S * Used in: library/ssl_tls.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This feature requires zlib library and headers to be present.
S *
S * Uncomment to enable use of ZLIB
S */
S//#define MBEDTLS_ZLIB_SUPPORT
S/* \} name SECTION: mbed TLS feature support */
S
S/**
S * \name SECTION: mbed TLS modules
S *
S * This section enables or disables entire modules in mbed TLS
S * \{
S */
S
S/**
S * \def MBEDTLS_AESNI_C
S *
S * Enable AES-NI support on x86-64.
S *
S * Module:  library/aesni.c
S * Caller:  library/aes.c
S *
S * Requires: MBEDTLS_HAVE_ASM
S *
S * This modules adds support for the AES-NI instructions on x86-64
S */
S#define MBEDTLS_AESNI_C
S
S/**
S * \def MBEDTLS_AES_C
S *
S * Enable the AES block cipher.
S *
S * Module:  library/aes.c
S * Caller:  library/ssl_tls.c
S *          library/pem.c
S *          library/ctr_drbg.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA
S *
S * PEM_PARSE uses AES for decrypting encrypted keys.
S */
S#define MBEDTLS_AES_C
S
S/**
S * \def MBEDTLS_ARC4_C
S *
S * Enable the ARCFOUR stream cipher.
S *
S * Module:  library/arc4.c
S * Caller:  library/ssl_tls.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_MD5
S *      MBEDTLS_TLS_RSA_PSK_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_ARC4_C
S
S/**
S * \def MBEDTLS_ASN1_PARSE_C
S *
S * Enable the generic ASN1 parser.
S *
S * Module:  library/asn1.c
S * Caller:  library/x509.c
S *          library/dhm.c
S *          library/pkcs12.c
S *          library/pkcs5.c
S *          library/pkparse.c
S */
S#define MBEDTLS_ASN1_PARSE_C
S
S/**
S * \def MBEDTLS_ASN1_WRITE_C
S *
S * Enable the generic ASN1 writer.
S *
S * Module:  library/asn1write.c
S * Caller:  library/ecdsa.c
S *          library/pkwrite.c
S *          library/x509_create.c
S *          library/x509write_crt.c
S *          library/mbedtls_x509write_csr.c
S */
S#define MBEDTLS_ASN1_WRITE_C
S
S/**
S * \def MBEDTLS_BASE64_C
S *
S * Enable the Base64 module.
S *
S * Module:  library/base64.c
S * Caller:  library/pem.c
S *
S * This module is required for PEM support (required by X.509).
S */
S#define MBEDTLS_BASE64_C
S
S/**
S * \def MBEDTLS_BIGNUM_C
S *
S * Enable the multi-precision integer library.
S *
S * Module:  library/bignum.c
S * Caller:  library/dhm.c
S *          library/ecp.c
S *          library/ecdsa.c
S *          library/rsa.c
S *          library/ssl_tls.c
S *
S * This module is required for RSA, DHM and ECC (ECDH, ECDSA) support.
S */
S#define MBEDTLS_BIGNUM_C
S
S/**
S * \def MBEDTLS_BLOWFISH_C
S *
S * Enable the Blowfish block cipher.
S *
S * Module:  library/blowfish.c
S */
S#define MBEDTLS_BLOWFISH_C
S
S/**
S * \def MBEDTLS_CAMELLIA_C
S *
S * Enable the Camellia block cipher.
S *
S * Module:  library/camellia.c
S * Caller:  library/ssl_tls.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
S */
S#define MBEDTLS_CAMELLIA_C
S
S/**
S * \def MBEDTLS_CCM_C
S *
S * Enable the Counter with CBC-MAC (CCM) mode for 128-bit block cipher.
S *
S * Module:  library/ccm.c
S *
S * Requires: MBEDTLS_AES_C or MBEDTLS_CAMELLIA_C
S *
S * This module enables the AES-CCM ciphersuites, if other requisites are
S * enabled as well.
S */
S#define MBEDTLS_CCM_C
S
S/**
S * \def MBEDTLS_CERTS_C
S *
S * Enable the test certificates.
S *
S * Module:  library/certs.c
S * Caller:
S *
S * This module is used for testing (ssl_client/server).
S */
S#define MBEDTLS_CERTS_C
S
S/**
S * \def MBEDTLS_CIPHER_C
S *
S * Enable the generic cipher layer.
S *
S * Module:  library/cipher.c
S * Caller:  library/ssl_tls.c
S *
S * Uncomment to enable generic cipher wrappers.
S */
S#define MBEDTLS_CIPHER_C
S
S/**
S * \def MBEDTLS_CTR_DRBG_C
S *
S * Enable the CTR_DRBG AES-256-based random generator.
S *
S * Module:  library/ctr_drbg.c
S * Caller:
S *
S * Requires: MBEDTLS_AES_C
S *
S * This module provides the CTR_DRBG AES-256 random number generator.
S */
S#define MBEDTLS_CTR_DRBG_C
S
S/**
S * \def MBEDTLS_DEBUG_C
S *
S * Enable the debug functions.
S *
S * Module:  library/debug.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *
S * This module provides debugging functions.
S */
S#define MBEDTLS_DEBUG_C
S
S/**
S * \def MBEDTLS_DES_C
S *
S * Enable the DES block cipher.
S *
S * Module:  library/des.c
S * Caller:  library/pem.c
S *          library/ssl_tls.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_3DES_EDE_CBC_SHA
S *
S * PEM_PARSE uses DES/3DES for decrypting encrypted keys.
S */
S#define MBEDTLS_DES_C
S
S/**
S * \def MBEDTLS_DHM_C
S *
S * Enable the Diffie-Hellman-Merkle module.
S *
S * Module:  library/dhm.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This module is used by the following key exchanges:
S *      DHE-RSA, DHE-PSK
S */
S#define MBEDTLS_DHM_C
S
S/**
S * \def MBEDTLS_ECDH_C
S *
S * Enable the elliptic curve Diffie-Hellman library.
S *
S * Module:  library/ecdh.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This module is used by the following key exchanges:
S *      ECDHE-ECDSA, ECDHE-RSA, DHE-PSK
S *
S * Requires: MBEDTLS_ECP_C
S */
S#define MBEDTLS_ECDH_C
S
S/**
S * \def MBEDTLS_ECDSA_C
S *
S * Enable the elliptic curve DSA library.
S *
S * Module:  library/ecdsa.c
S * Caller:
S *
S * This module is used by the following key exchanges:
S *      ECDHE-ECDSA
S *
S * Requires: MBEDTLS_ECP_C, MBEDTLS_ASN1_WRITE_C, MBEDTLS_ASN1_PARSE_C
S */
S#define MBEDTLS_ECDSA_C
S
S/**
S * \def MBEDTLS_ECJPAKE_C
S *
S * Enable the elliptic curve J-PAKE library.
S *
S * \warning This is currently experimental. EC J-PAKE support is based on the
S * Thread v1.0.0 specification; incompatible changes to the specification
S * might still happen. For this reason, this is disabled by default.
S *
S * Module:  library/ecjpake.c
S * Caller:
S *
S * This module is used by the following key exchanges:
S *      ECJPAKE
S *
S * Requires: MBEDTLS_ECP_C, MBEDTLS_MD_C
S */
S//#define MBEDTLS_ECJPAKE_C
S
S/**
S * \def MBEDTLS_ECP_C
S *
S * Enable the elliptic curve over GF(p) library.
S *
S * Module:  library/ecp.c
S * Caller:  library/ecdh.c
S *          library/ecdsa.c
S *          library/ecjpake.c
S *
S * Requires: MBEDTLS_BIGNUM_C and at least one MBEDTLS_ECP_DP_XXX_ENABLED
S */
S#define MBEDTLS_ECP_C
S
S/**
S * \def MBEDTLS_ENTROPY_C
S *
S * Enable the platform-specific entropy code.
S *
S * Module:  library/entropy.c
S * Caller:
S *
S * Requires: MBEDTLS_SHA512_C or MBEDTLS_SHA256_C
S *
S * This module provides a generic entropy pool
S */
S#define MBEDTLS_ENTROPY_C
S
S/**
S * \def MBEDTLS_ERROR_C
S *
S * Enable error code to error string conversion.
S *
S * Module:  library/error.c
S * Caller:
S *
S * This module enables mbedtls_strerror().
S */
S#define MBEDTLS_ERROR_C
S
S/**
S * \def MBEDTLS_GCM_C
S *
S * Enable the Galois/Counter Mode (GCM) for AES.
S *
S * Module:  library/gcm.c
S *
S * Requires: MBEDTLS_AES_C or MBEDTLS_CAMELLIA_C
S *
S * This module enables the AES-GCM and CAMELLIA-GCM ciphersuites, if other
S * requisites are enabled as well.
S */
S#define MBEDTLS_GCM_C
S
S/**
S * \def MBEDTLS_HAVEGE_C
S *
S * Enable the HAVEGE random generator.
S *
S * Warning: the HAVEGE random generator is not suitable for virtualized
S *          environments
S *
S * Warning: the HAVEGE random generator is dependent on timing and specific
S *          processor traits. It is therefore not advised to use HAVEGE as
S *          your applications primary random generator or primary entropy pool
S *          input. As a secondary input to your entropy pool, it IS able add
S *          the (limited) extra entropy it provides.
S *
S * Module:  library/havege.c
S * Caller:
S *
S * Requires: MBEDTLS_TIMING_C
S *
S * Uncomment to enable the HAVEGE random generator.
S */
S//#define MBEDTLS_HAVEGE_C
S
S/**
S * \def MBEDTLS_HMAC_DRBG_C
S *
S * Enable the HMAC_DRBG random generator.
S *
S * Module:  library/hmac_drbg.c
S * Caller:
S *
S * Requires: MBEDTLS_MD_C
S *
S * Uncomment to enable the HMAC_DRBG random number geerator.
S */
S#define MBEDTLS_HMAC_DRBG_C
S
S/**
S * \def MBEDTLS_MD_C
S *
S * Enable the generic message digest layer.
S *
S * Module:  library/mbedtls_md.c
S * Caller:
S *
S * Uncomment to enable generic message digest wrappers.
S */
S#define MBEDTLS_MD_C
S
S/**
S * \def MBEDTLS_MD2_C
S *
S * Enable the MD2 hash algorithm.
S *
S * Module:  library/mbedtls_md2.c
S * Caller:
S *
S * Uncomment to enable support for (rare) MD2-signed X.509 certs.
S */
S//#define MBEDTLS_MD2_C
S
S/**
S * \def MBEDTLS_MD4_C
S *
S * Enable the MD4 hash algorithm.
S *
S * Module:  library/mbedtls_md4.c
S * Caller:
S *
S * Uncomment to enable support for (rare) MD4-signed X.509 certs.
S */
S//#define MBEDTLS_MD4_C
S
S/**
S * \def MBEDTLS_MD5_C
S *
S * Enable the MD5 hash algorithm.
S *
S * Module:  library/mbedtls_md5.c
S * Caller:  library/mbedtls_md.c
S *          library/pem.c
S *          library/ssl_tls.c
S *
S * This module is required for SSL/TLS and X.509.
S * PEM_PARSE uses MD5 for decrypting encrypted keys.
S */
S#define MBEDTLS_MD5_C
S
S/**
S * \def MBEDTLS_MEMORY_BUFFER_ALLOC_C
S *
S * Enable the buffer allocator implementation that makes use of a (stack)
S * based buffer to 'allocate' dynamic memory. (replaces calloc() and free()
S * calls)
S *
S * Module:  library/memory_buffer_alloc.c
S *
S * Requires: MBEDTLS_PLATFORM_C
S *           MBEDTLS_PLATFORM_MEMORY (to use it within mbed TLS)
S *
S * Enable this module to enable the buffer memory allocator.
S */
S//#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
S
S/**
S * \def MBEDTLS_NET_C
S *
S * Enable the TCP/IP networking routines.
S *
S * Module:  library/net.c
S *
S * This module provides TCP/IP networking routines.
S */
S#define MBEDTLS_NET_C
S
S/**
S * \def MBEDTLS_OID_C
S *
S * Enable the OID database.
S *
S * Module:  library/oid.c
S * Caller:  library/asn1write.c
S *          library/pkcs5.c
S *          library/pkparse.c
S *          library/pkwrite.c
S *          library/rsa.c
S *          library/x509.c
S *          library/x509_create.c
S *          library/mbedtls_x509_crl.c
S *          library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *          library/x509write_crt.c
S *          library/mbedtls_x509write_csr.c
S *
S * This modules translates between OIDs and internal values.
S */
S#define MBEDTLS_OID_C
S
S/**
S * \def MBEDTLS_PADLOCK_C
S *
S * Enable VIA Padlock support on x86.
S *
S * Module:  library/padlock.c
S * Caller:  library/aes.c
S *
S * Requires: MBEDTLS_HAVE_ASM
S *
S * This modules adds support for the VIA PadLock on x86.
S */
S#define MBEDTLS_PADLOCK_C
S
S/**
S * \def MBEDTLS_PEM_PARSE_C
S *
S * Enable PEM decoding / parsing.
S *
S * Module:  library/pem.c
S * Caller:  library/dhm.c
S *          library/pkparse.c
S *          library/mbedtls_x509_crl.c
S *          library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *
S * Requires: MBEDTLS_BASE64_C
S *
S * This modules adds support for decoding / parsing PEM files.
S */
S#define MBEDTLS_PEM_PARSE_C
S
S/**
S * \def MBEDTLS_PEM_WRITE_C
S *
S * Enable PEM encoding / writing.
S *
S * Module:  library/pem.c
S * Caller:  library/pkwrite.c
S *          library/x509write_crt.c
S *          library/mbedtls_x509write_csr.c
S *
S * Requires: MBEDTLS_BASE64_C
S *
S * This modules adds support for encoding / writing PEM files.
S */
S#define MBEDTLS_PEM_WRITE_C
S
S/**
S * \def MBEDTLS_PK_C
S *
S * Enable the generic public (asymetric) key layer.
S *
S * Module:  library/pk.c
S * Caller:  library/ssl_tls.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * Requires: MBEDTLS_RSA_C or MBEDTLS_ECP_C
S *
S * Uncomment to enable generic public key wrappers.
S */
S#define MBEDTLS_PK_C
S
S/**
S * \def MBEDTLS_PK_PARSE_C
S *
S * Enable the generic public (asymetric) key parser.
S *
S * Module:  library/pkparse.c
S * Caller:  library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *
S * Requires: MBEDTLS_PK_C
S *
S * Uncomment to enable generic public key parse functions.
S */
S#define MBEDTLS_PK_PARSE_C
S
S/**
S * \def MBEDTLS_PK_WRITE_C
S *
S * Enable the generic public (asymetric) key writer.
S *
S * Module:  library/pkwrite.c
S * Caller:  library/x509write.c
S *
S * Requires: MBEDTLS_PK_C
S *
S * Uncomment to enable generic public key write functions.
S */
S#define MBEDTLS_PK_WRITE_C
S
S/**
S * \def MBEDTLS_PKCS5_C
S *
S * Enable PKCS#5 functions.
S *
S * Module:  library/pkcs5.c
S *
S * Requires: MBEDTLS_MD_C
S *
S * This module adds support for the PKCS#5 functions.
S */
S#define MBEDTLS_PKCS5_C
S
S/**
S * \def MBEDTLS_PKCS11_C
S *
S * Enable wrapper for PKCS#11 smartcard support.
S *
S * Module:  library/pkcs11.c
S * Caller:  library/pk.c
S *
S * Requires: MBEDTLS_PK_C
S *
S * This module enables SSL/TLS PKCS #11 smartcard support.
S * Requires the presence of the PKCS#11 helper library (libpkcs11-helper)
S */
S//#define MBEDTLS_PKCS11_C
S
S/**
S * \def MBEDTLS_PKCS12_C
S *
S * Enable PKCS#12 PBE functions.
S * Adds algorithms for parsing PKCS#8 encrypted private keys
S *
S * Module:  library/pkcs12.c
S * Caller:  library/pkparse.c
S *
S * Requires: MBEDTLS_ASN1_PARSE_C, MBEDTLS_CIPHER_C, MBEDTLS_MD_C
S * Can use:  MBEDTLS_ARC4_C
S *
S * This module enables PKCS#12 functions.
S */
S#define MBEDTLS_PKCS12_C
S
S/**
S * \def MBEDTLS_PLATFORM_C
S *
S * Enable the platform abstraction layer that allows you to re-assign
S * functions like calloc(), free(), snprintf(), printf(), fprintf(), exit().
S *
S * Enabling MBEDTLS_PLATFORM_C enables to use of MBEDTLS_PLATFORM_XXX_ALT
S * or MBEDTLS_PLATFORM_XXX_MACRO directives, allowing the functions mentioned
S * above to be specified at runtime or compile time respectively.
S *
S * \note This abstraction layer must be enabled on Windows (including MSYS2)
S * as other module rely on it for a fixed snprintf implementation.
S *
S * Module:  library/platform.c
S * Caller:  Most other .c files
S *
S * This module enables abstraction of common (libc) functions.
S */
S#define MBEDTLS_PLATFORM_C
S
S/**
S * \def MBEDTLS_RIPEMD160_C
S *
S * Enable the RIPEMD-160 hash algorithm.
S *
S * Module:  library/mbedtls_ripemd160.c
S * Caller:  library/mbedtls_md.c
S *
S */
S#define MBEDTLS_RIPEMD160_C
S
S/**
S * \def MBEDTLS_RSA_C
S *
S * Enable the RSA public-key cryptosystem.
S *
S * Module:  library/rsa.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *          library/x509.c
S *
S * This module is used by the following key exchanges:
S *      RSA, DHE-RSA, ECDHE-RSA, RSA-PSK
S *
S * Requires: MBEDTLS_BIGNUM_C, MBEDTLS_OID_C
S */
S#define MBEDTLS_RSA_C
S
S/**
S * \def MBEDTLS_SHA1_C
S *
S * Enable the SHA1 cryptographic hash algorithm.
S *
S * Module:  library/mbedtls_sha1.c
S * Caller:  library/mbedtls_md.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *          library/x509write_crt.c
S *
S * This module is required for SSL/TLS and SHA1-signed certificates.
S */
S#define MBEDTLS_SHA1_C
S
S/**
S * \def MBEDTLS_SHA256_C
S *
S * Enable the SHA-224 and SHA-256 cryptographic hash algorithms.
S *
S * Module:  library/mbedtls_sha256.c
S * Caller:  library/entropy.c
S *          library/mbedtls_md.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *
S * This module adds support for SHA-224 and SHA-256.
S * This module is required for the SSL/TLS 1.2 PRF function.
S */
S#define MBEDTLS_SHA256_C
S
S/**
S * \def MBEDTLS_SHA512_C
S *
S * Enable the SHA-384 and SHA-512 cryptographic hash algorithms.
S *
S * Module:  library/mbedtls_sha512.c
S * Caller:  library/entropy.c
S *          library/mbedtls_md.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This module adds support for SHA-384 and SHA-512.
S */
S#define MBEDTLS_SHA512_C
S
S/**
S * \def MBEDTLS_SSL_CACHE_C
S *
S * Enable simple SSL cache implementation.
S *
S * Module:  library/ssl_cache.c
S * Caller:
S *
S * Requires: MBEDTLS_SSL_CACHE_C
S */
S#define MBEDTLS_SSL_CACHE_C
S
S/**
S * \def MBEDTLS_SSL_COOKIE_C
S *
S * Enable basic implementation of DTLS cookies for hello verification.
S *
S * Module:  library/ssl_cookie.c
S * Caller:
S */
S#define MBEDTLS_SSL_COOKIE_C
S
S/**
S * \def MBEDTLS_SSL_TICKET_C
S *
S * Enable an implementation of TLS server-side callbacks for session tickets.
S *
S * Module:  library/ssl_ticket.c
S * Caller:
S *
S * Requires: MBEDTLS_CIPHER_C
S */
S#define MBEDTLS_SSL_TICKET_C
S
S/**
S * \def MBEDTLS_SSL_CLI_C
S *
S * Enable the SSL/TLS client code.
S *
S * Module:  library/ssl_cli.c
S * Caller:
S *
S * Requires: MBEDTLS_SSL_TLS_C
S *
S * This module is required for SSL/TLS client support.
S */
S#define MBEDTLS_SSL_CLI_C
S
S/**
S * \def MBEDTLS_SSL_SRV_C
S *
S * Enable the SSL/TLS server code.
S *
S * Module:  library/ssl_srv.c
S * Caller:
S *
S * Requires: MBEDTLS_SSL_TLS_C
S *
S * This module is required for SSL/TLS server support.
S */
S#define MBEDTLS_SSL_SRV_C
S
S/**
S * \def MBEDTLS_SSL_TLS_C
S *
S * Enable the generic SSL/TLS code.
S *
S * Module:  library/ssl_tls.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * Requires: MBEDTLS_CIPHER_C, MBEDTLS_MD_C
S *           and at least one of the MBEDTLS_SSL_PROTO_XXX defines
S *
S * This module is required for SSL/TLS.
S */
S#define MBEDTLS_SSL_TLS_C
S
S/**
S * \def MBEDTLS_THREADING_C
S *
S * Enable the threading abstraction layer.
S * By default mbed TLS assumes it is used in a non-threaded environment or that
S * contexts are not shared between threads. If you do intend to use contexts
S * between threads, you will need to enable this layer to prevent race
S * conditions.
S *
S * Module:  library/threading.c
S *
S * This allows different threading implementations (self-implemented or
S * provided).
S *
S * You will have to enable either MBEDTLS_THREADING_ALT or
S * MBEDTLS_THREADING_PTHREAD.
S *
S * Enable this layer to allow use of mutexes within mbed TLS
S */
S//#define MBEDTLS_THREADING_C
S
S/**
S * \def MBEDTLS_TIMING_C
S *
S * Enable the portable timing interface.
S *
S * Module:  library/timing.c
S * Caller:  library/havege.c
S *
S * This module is used by the HAVEGE random number generator.
S */
S#define MBEDTLS_TIMING_C
S
S/**
S * \def MBEDTLS_VERSION_C
S *
S * Enable run-time version information.
S *
S * Module:  library/version.c
S *
S * This module provides run-time version information.
S */
S#define MBEDTLS_VERSION_C
S
S/**
S * \def MBEDTLS_X509_USE_C
S *
S * Enable X.509 core for using certificates.
S *
S * Module:  library/x509.c
S * Caller:  library/mbedtls_x509_crl.c
S *          library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *
S * Requires: MBEDTLS_ASN1_PARSE_C, MBEDTLS_BIGNUM_C, MBEDTLS_OID_C,
S *           MBEDTLS_PK_PARSE_C
S *
S * This module is required for the X.509 parsing modules.
S */
S#define MBEDTLS_X509_USE_C
S
S/**
S * \def MBEDTLS_X509_CRT_PARSE_C
S *
S * Enable X.509 certificate parsing.
S *
S * Module:  library/mbedtls_x509_crt.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *
S * Requires: MBEDTLS_X509_USE_C
S *
S * This module is required for X.509 certificate parsing.
S */
S#define MBEDTLS_X509_CRT_PARSE_C
S
S/**
S * \def MBEDTLS_X509_CRL_PARSE_C
S *
S * Enable X.509 CRL parsing.
S *
S * Module:  library/mbedtls_x509_crl.c
S * Caller:  library/mbedtls_x509_crt.c
S *
S * Requires: MBEDTLS_X509_USE_C
S *
S * This module is required for X.509 CRL parsing.
S */
S#define MBEDTLS_X509_CRL_PARSE_C
S
S/**
S * \def MBEDTLS_X509_CSR_PARSE_C
S *
S * Enable X.509 Certificate Signing Request (CSR) parsing.
S *
S * Module:  library/mbedtls_x509_csr.c
S * Caller:  library/x509_crt_write.c
S *
S * Requires: MBEDTLS_X509_USE_C
S *
S * This module is used for reading X.509 certificate request.
S */
S#define MBEDTLS_X509_CSR_PARSE_C
S
S/**
S * \def MBEDTLS_X509_CREATE_C
S *
S * Enable X.509 core for creating certificates.
S *
S * Module:  library/x509_create.c
S *
S * Requires: MBEDTLS_BIGNUM_C, MBEDTLS_OID_C, MBEDTLS_PK_WRITE_C
S *
S * This module is the basis for creating X.509 certificates and CSRs.
S */
S#define MBEDTLS_X509_CREATE_C
S
S/**
S * \def MBEDTLS_X509_CRT_WRITE_C
S *
S * Enable creating X.509 certificates.
S *
S * Module:  library/x509_crt_write.c
S *
S * Requires: MBEDTLS_X509_CREATE_C
S *
S * This module is required for X.509 certificate creation.
S */
S#define MBEDTLS_X509_CRT_WRITE_C
S
S/**
S * \def MBEDTLS_X509_CSR_WRITE_C
S *
S * Enable creating X.509 Certificate Signing Requests (CSR).
S *
S * Module:  library/x509_csr_write.c
S *
S * Requires: MBEDTLS_X509_CREATE_C
S *
S * This module is required for X.509 certificate request writing.
S */
S#define MBEDTLS_X509_CSR_WRITE_C
S
S/**
S * \def MBEDTLS_XTEA_C
S *
S * Enable the XTEA block cipher.
S *
S * Module:  library/xtea.c
S * Caller:
S */
S#define MBEDTLS_XTEA_C
S
S/* \} name SECTION: mbed TLS modules */
S
S/**
S * \name SECTION: Module configuration options
S *
S * This section allows for the setting of module specific sizes and
S * configuration options. The default values are already present in the
S * relevant header files and should suffice for the regular use cases.
S *
S * Our advice is to enable options and change their values here
S * only if you have a good reason and know the consequences.
S *
S * Please check the respective header file for documentation on these
S * parameters (to prevent duplicate documentation).
S * \{
S */
S
S/* MPI / BIGNUM options */
S//#define MBEDTLS_MPI_WINDOW_SIZE            6 /**< Maximum windows size used. */
S//#define MBEDTLS_MPI_MAX_SIZE            1024 /**< Maximum number of bytes for usable MPIs. */
S
S/* CTR_DRBG options */
S//#define MBEDTLS_CTR_DRBG_ENTROPY_LEN               48 /**< Amount of entropy used per seed by default (48 with SHA-512, 32 with SHA-256) */
S//#define MBEDTLS_CTR_DRBG_RESEED_INTERVAL        10000 /**< Interval before reseed is performed by default */
S//#define MBEDTLS_CTR_DRBG_MAX_INPUT                256 /**< Maximum number of additional input bytes */
S//#define MBEDTLS_CTR_DRBG_MAX_REQUEST             1024 /**< Maximum number of requested bytes per call */
S//#define MBEDTLS_CTR_DRBG_MAX_SEED_INPUT           384 /**< Maximum size of (re)seed buffer */
S
S/* HMAC_DRBG options */
S//#define MBEDTLS_HMAC_DRBG_RESEED_INTERVAL   10000 /**< Interval before reseed is performed by default */
S//#define MBEDTLS_HMAC_DRBG_MAX_INPUT           256 /**< Maximum number of additional input bytes */
S//#define MBEDTLS_HMAC_DRBG_MAX_REQUEST        1024 /**< Maximum number of requested bytes per call */
S//#define MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT      384 /**< Maximum size of (re)seed buffer */
S
S/* ECP options */
S//#define MBEDTLS_ECP_MAX_BITS             521 /**< Maximum bit size of groups */
S//#define MBEDTLS_ECP_WINDOW_SIZE            6 /**< Maximum window size used */
S//#define MBEDTLS_ECP_FIXED_POINT_OPTIM      1 /**< Enable fixed-point speed-up */
S
S/* Entropy options */
S//#define MBEDTLS_ENTROPY_MAX_SOURCES                20 /**< Maximum number of sources supported */
S//#define MBEDTLS_ENTROPY_MAX_GATHER                128 /**< Maximum amount requested from entropy sources */
S
S/* Memory buffer allocator options */
S//#define MBEDTLS_MEMORY_ALIGN_MULTIPLE      4 /**< Align on multiples of this value */
S
S/* Platform options */
S//#define MBEDTLS_PLATFORM_STD_MEM_HDR   <stdlib.h> /**< Header to include if MBEDTLS_PLATFORM_NO_STD_FUNCTIONS is defined. Don't define if no header is needed. */
S//#define MBEDTLS_PLATFORM_STD_CALLOC        calloc /**< Default allocator to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_FREE            free /**< Default free to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_EXIT            exit /**< Default exit to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_FPRINTF      fprintf /**< Default fprintf to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_PRINTF        printf /**< Default printf to use, can be undefined */
S/* Note: your snprintf must correclty zero-terminate the buffer! */
S//#define MBEDTLS_PLATFORM_STD_SNPRINTF    snprintf /**< Default snprintf to use, can be undefined */
S
S/* To Use Function Macros MBEDTLS_PLATFORM_C must be enabled */
S/* MBEDTLS_PLATFORM_XXX_MACRO and MBEDTLS_PLATFORM_XXX_ALT cannot both be defined */
S//#define MBEDTLS_PLATFORM_CALLOC_MACRO        calloc /**< Default allocator macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_FREE_MACRO            free /**< Default free macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_EXIT_MACRO            exit /**< Default exit macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_FPRINTF_MACRO      fprintf /**< Default fprintf macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_PRINTF_MACRO        printf /**< Default printf macro to use, can be undefined */
S/* Note: your snprintf must correclty zero-terminate the buffer! */
S//#define MBEDTLS_PLATFORM_SNPRINTF_MACRO    snprintf /**< Default snprintf macro to use, can be undefined */
S
S/* SSL Cache options */
S//#define MBEDTLS_SSL_CACHE_DEFAULT_TIMEOUT       86400 /**< 1 day  */
S//#define MBEDTLS_SSL_CACHE_DEFAULT_MAX_ENTRIES      50 /**< Maximum entries in cache */
S
S/* SSL options */
S//#define MBEDTLS_SSL_MAX_CONTENT_LEN             16384 /**< Maxium fragment length in bytes, determines the size of each of the two internal I/O buffers */
S//#define MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME     86400 /**< Lifetime of session tickets (if enabled) */
S//#define MBEDTLS_PSK_MAX_LEN               32 /**< Max size of TLS pre-shared keys, in bytes (default 256 bits) */
S//#define MBEDTLS_SSL_COOKIE_TIMEOUT        60 /**< Default expiration delay of DTLS cookies, in seconds if HAVE_TIME, or in number of cookies issued */
S
S/**
S * Complete list of ciphersuites to use, in order of preference.
S *
S * \warning No dependency checking is done on that field! This option can only
S * be used to restrict the set of available ciphersuites. It is your
S * responsibility to make sure the needed modules are active.
S *
S * Use this to save a few hundred bytes of ROM (default ordering of all
S * available ciphersuites) and a few to a few hundred bytes of RAM.
S *
S * The value below is only an example, not the default.
S */
S//#define MBEDTLS_SSL_CIPHERSUITES MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
S
S/* X509 options */
S//#define MBEDTLS_X509_MAX_INTERMEDIATE_CA   8   /**< Maximum number of intermediate CAs in a verification chain. */
S
S/* \} name SECTION: Module configuration options */
S
S#if defined(TARGET_LIKE_MBED)
S#include "mbedtls/target_config.h"
S#endif
S
S/*
S * Allow user to override any previous default.
S *
S * Use two macro names for that, as:
S * - with yotta the prefix YOTTA_CFG_ is forced
S * - without yotta is looks weird to have a YOTTA prefix.
S */
S#if defined(YOTTA_CFG_MBEDTLS_USER_CONFIG_FILE)
S#include YOTTA_CFG_MBEDTLS_USER_CONFIG_FILE
S#elif defined(MBEDTLS_USER_CONFIG_FILE)
S#include MBEDTLS_USER_CONFIG_FILE
S#endif
S
S#include "check_config.h"
S
N#endif /* MBEDTLS_CONFIG_H */
L 30 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\library\aes.c" 2
N#else
S#include MBEDTLS_CONFIG_FILE
N#endif
N
N#if defined(MBEDTLS_AES_C)
X#if 0L
S
S#include <string.h>
S
S#include "mbedtls/aes.h"
S#if defined(MBEDTLS_PADLOCK_C)
S#include "mbedtls/padlock.h"
S#endif
S#if defined(MBEDTLS_AESNI_C)
S#include "mbedtls/aesni.h"
S#endif
S
S#if defined(MBEDTLS_SELF_TEST)
S#if defined(MBEDTLS_PLATFORM_C)
S#include "mbedtls/platform.h"
S#else
S#include <stdio.h>
S#define mbedtls_printf printf
S#endif /* MBEDTLS_PLATFORM_C */
S#endif /* MBEDTLS_SELF_TEST */
S
S#if !defined(MBEDTLS_AES_ALT)
S
S/* Implementation that should never be optimized out by the compiler */
Sstatic void mbedtls_zeroize( void *v, size_t n ) {
S    volatile unsigned char *p = v; while( n-- ) *p++ = 0;
S}
S
S/*
S * 32-bit integer manipulation macros (little endian)
S */
S#ifndef GET_UINT32_LE
S#define GET_UINT32_LE(n,b,i)                            \
S{                                                       \
S    (n) = ( (uint32_t) (b)[(i)    ]       )             \
S        | ( (uint32_t) (b)[(i) + 1] <<  8 )             \
S        | ( (uint32_t) (b)[(i) + 2] << 16 )             \
S        | ( (uint32_t) (b)[(i) + 3] << 24 );            \
S}
X#define GET_UINT32_LE(n,b,i)                            {                                                           (n) = ( (uint32_t) (b)[(i)    ]       )                     | ( (uint32_t) (b)[(i) + 1] <<  8 )                     | ( (uint32_t) (b)[(i) + 2] << 16 )                     | ( (uint32_t) (b)[(i) + 3] << 24 );            }
S#endif
S
S#ifndef PUT_UINT32_LE
S#define PUT_UINT32_LE(n,b,i)                                    \
S{                                                               \
S    (b)[(i)    ] = (unsigned char) ( ( (n)       ) & 0xFF );    \
S    (b)[(i) + 1] = (unsigned char) ( ( (n) >>  8 ) & 0xFF );    \
S    (b)[(i) + 2] = (unsigned char) ( ( (n) >> 16 ) & 0xFF );    \
S    (b)[(i) + 3] = (unsigned char) ( ( (n) >> 24 ) & 0xFF );    \
S}
X#define PUT_UINT32_LE(n,b,i)                                    {                                                                   (b)[(i)    ] = (unsigned char) ( ( (n)       ) & 0xFF );        (b)[(i) + 1] = (unsigned char) ( ( (n) >>  8 ) & 0xFF );        (b)[(i) + 2] = (unsigned char) ( ( (n) >> 16 ) & 0xFF );        (b)[(i) + 3] = (unsigned char) ( ( (n) >> 24 ) & 0xFF );    }
S#endif
S
S#if defined(MBEDTLS_PADLOCK_C) &&                      \
S    ( defined(MBEDTLS_HAVE_X86) || defined(MBEDTLS_PADLOCK_ALIGN16) )
X#if defined(MBEDTLS_PADLOCK_C) &&                          ( defined(MBEDTLS_HAVE_X86) || defined(MBEDTLS_PADLOCK_ALIGN16) )
Sstatic int aes_padlock_ace = -1;
S#endif
S
S#if defined(MBEDTLS_AES_ROM_TABLES)
S/*
S * Forward S-box
S */
Sstatic const unsigned char FSb[256] =
S{
S    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
S    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
S    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
S    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
S    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
S    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
S    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
S    0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
S    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
S    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
S    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
S    0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
S    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
S    0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
S    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
S    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
S    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
S    0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
S    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
S    0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
S    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
S    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
S    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
S    0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
S    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
S    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
S    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
S    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
S    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
S    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
S    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
S    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
S};
S
S/*
S * Forward tables
S */
S#define FT \
S\
S    V(A5,63,63,C6), V(84,7C,7C,F8), V(99,77,77,EE), V(8D,7B,7B,F6), \
S    V(0D,F2,F2,FF), V(BD,6B,6B,D6), V(B1,6F,6F,DE), V(54,C5,C5,91), \
S    V(50,30,30,60), V(03,01,01,02), V(A9,67,67,CE), V(7D,2B,2B,56), \
S    V(19,FE,FE,E7), V(62,D7,D7,B5), V(E6,AB,AB,4D), V(9A,76,76,EC), \
S    V(45,CA,CA,8F), V(9D,82,82,1F), V(40,C9,C9,89), V(87,7D,7D,FA), \
S    V(15,FA,FA,EF), V(EB,59,59,B2), V(C9,47,47,8E), V(0B,F0,F0,FB), \
S    V(EC,AD,AD,41), V(67,D4,D4,B3), V(FD,A2,A2,5F), V(EA,AF,AF,45), \
S    V(BF,9C,9C,23), V(F7,A4,A4,53), V(96,72,72,E4), V(5B,C0,C0,9B), \
S    V(C2,B7,B7,75), V(1C,FD,FD,E1), V(AE,93,93,3D), V(6A,26,26,4C), \
S    V(5A,36,36,6C), V(41,3F,3F,7E), V(02,F7,F7,F5), V(4F,CC,CC,83), \
S    V(5C,34,34,68), V(F4,A5,A5,51), V(34,E5,E5,D1), V(08,F1,F1,F9), \
S    V(93,71,71,E2), V(73,D8,D8,AB), V(53,31,31,62), V(3F,15,15,2A), \
S    V(0C,04,04,08), V(52,C7,C7,95), V(65,23,23,46), V(5E,C3,C3,9D), \
S    V(28,18,18,30), V(A1,96,96,37), V(0F,05,05,0A), V(B5,9A,9A,2F), \
S    V(09,07,07,0E), V(36,12,12,24), V(9B,80,80,1B), V(3D,E2,E2,DF), \
S    V(26,EB,EB,CD), V(69,27,27,4E), V(CD,B2,B2,7F), V(9F,75,75,EA), \
S    V(1B,09,09,12), V(9E,83,83,1D), V(74,2C,2C,58), V(2E,1A,1A,34), \
S    V(2D,1B,1B,36), V(B2,6E,6E,DC), V(EE,5A,5A,B4), V(FB,A0,A0,5B), \
S    V(F6,52,52,A4), V(4D,3B,3B,76), V(61,D6,D6,B7), V(CE,B3,B3,7D), \
S    V(7B,29,29,52), V(3E,E3,E3,DD), V(71,2F,2F,5E), V(97,84,84,13), \
S    V(F5,53,53,A6), V(68,D1,D1,B9), V(00,00,00,00), V(2C,ED,ED,C1), \
S    V(60,20,20,40), V(1F,FC,FC,E3), V(C8,B1,B1,79), V(ED,5B,5B,B6), \
S    V(BE,6A,6A,D4), V(46,CB,CB,8D), V(D9,BE,BE,67), V(4B,39,39,72), \
S    V(DE,4A,4A,94), V(D4,4C,4C,98), V(E8,58,58,B0), V(4A,CF,CF,85), \
S    V(6B,D0,D0,BB), V(2A,EF,EF,C5), V(E5,AA,AA,4F), V(16,FB,FB,ED), \
S    V(C5,43,43,86), V(D7,4D,4D,9A), V(55,33,33,66), V(94,85,85,11), \
S    V(CF,45,45,8A), V(10,F9,F9,E9), V(06,02,02,04), V(81,7F,7F,FE), \
S    V(F0,50,50,A0), V(44,3C,3C,78), V(BA,9F,9F,25), V(E3,A8,A8,4B), \
S    V(F3,51,51,A2), V(FE,A3,A3,5D), V(C0,40,40,80), V(8A,8F,8F,05), \
S    V(AD,92,92,3F), V(BC,9D,9D,21), V(48,38,38,70), V(04,F5,F5,F1), \
S    V(DF,BC,BC,63), V(C1,B6,B6,77), V(75,DA,DA,AF), V(63,21,21,42), \
S    V(30,10,10,20), V(1A,FF,FF,E5), V(0E,F3,F3,FD), V(6D,D2,D2,BF), \
S    V(4C,CD,CD,81), V(14,0C,0C,18), V(35,13,13,26), V(2F,EC,EC,C3), \
S    V(E1,5F,5F,BE), V(A2,97,97,35), V(CC,44,44,88), V(39,17,17,2E), \
S    V(57,C4,C4,93), V(F2,A7,A7,55), V(82,7E,7E,FC), V(47,3D,3D,7A), \
S    V(AC,64,64,C8), V(E7,5D,5D,BA), V(2B,19,19,32), V(95,73,73,E6), \
S    V(A0,60,60,C0), V(98,81,81,19), V(D1,4F,4F,9E), V(7F,DC,DC,A3), \
S    V(66,22,22,44), V(7E,2A,2A,54), V(AB,90,90,3B), V(83,88,88,0B), \
S    V(CA,46,46,8C), V(29,EE,EE,C7), V(D3,B8,B8,6B), V(3C,14,14,28), \
S    V(79,DE,DE,A7), V(E2,5E,5E,BC), V(1D,0B,0B,16), V(76,DB,DB,AD), \
S    V(3B,E0,E0,DB), V(56,32,32,64), V(4E,3A,3A,74), V(1E,0A,0A,14), \
S    V(DB,49,49,92), V(0A,06,06,0C), V(6C,24,24,48), V(E4,5C,5C,B8), \
S    V(5D,C2,C2,9F), V(6E,D3,D3,BD), V(EF,AC,AC,43), V(A6,62,62,C4), \
S    V(A8,91,91,39), V(A4,95,95,31), V(37,E4,E4,D3), V(8B,79,79,F2), \
S    V(32,E7,E7,D5), V(43,C8,C8,8B), V(59,37,37,6E), V(B7,6D,6D,DA), \
S    V(8C,8D,8D,01), V(64,D5,D5,B1), V(D2,4E,4E,9C), V(E0,A9,A9,49), \
S    V(B4,6C,6C,D8), V(FA,56,56,AC), V(07,F4,F4,F3), V(25,EA,EA,CF), \
S    V(AF,65,65,CA), V(8E,7A,7A,F4), V(E9,AE,AE,47), V(18,08,08,10), \
S    V(D5,BA,BA,6F), V(88,78,78,F0), V(6F,25,25,4A), V(72,2E,2E,5C), \
S    V(24,1C,1C,38), V(F1,A6,A6,57), V(C7,B4,B4,73), V(51,C6,C6,97), \
S    V(23,E8,E8,CB), V(7C,DD,DD,A1), V(9C,74,74,E8), V(21,1F,1F,3E), \
S    V(DD,4B,4B,96), V(DC,BD,BD,61), V(86,8B,8B,0D), V(85,8A,8A,0F), \
S    V(90,70,70,E0), V(42,3E,3E,7C), V(C4,B5,B5,71), V(AA,66,66,CC), \
S    V(D8,48,48,90), V(05,03,03,06), V(01,F6,F6,F7), V(12,0E,0E,1C), \
S    V(A3,61,61,C2), V(5F,35,35,6A), V(F9,57,57,AE), V(D0,B9,B9,69), \
S    V(91,86,86,17), V(58,C1,C1,99), V(27,1D,1D,3A), V(B9,9E,9E,27), \
S    V(38,E1,E1,D9), V(13,F8,F8,EB), V(B3,98,98,2B), V(33,11,11,22), \
S    V(BB,69,69,D2), V(70,D9,D9,A9), V(89,8E,8E,07), V(A7,94,94,33), \
S    V(B6,9B,9B,2D), V(22,1E,1E,3C), V(92,87,87,15), V(20,E9,E9,C9), \
S    V(49,CE,CE,87), V(FF,55,55,AA), V(78,28,28,50), V(7A,DF,DF,A5), \
S    V(8F,8C,8C,03), V(F8,A1,A1,59), V(80,89,89,09), V(17,0D,0D,1A), \
S    V(DA,BF,BF,65), V(31,E6,E6,D7), V(C6,42,42,84), V(B8,68,68,D0), \
S    V(C3,41,41,82), V(B0,99,99,29), V(77,2D,2D,5A), V(11,0F,0F,1E), \
S    V(CB,B0,B0,7B), V(FC,54,54,A8), V(D6,BB,BB,6D), V(3A,16,16,2C)
X#define FT     V(A5,63,63,C6), V(84,7C,7C,F8), V(99,77,77,EE), V(8D,7B,7B,F6),     V(0D,F2,F2,FF), V(BD,6B,6B,D6), V(B1,6F,6F,DE), V(54,C5,C5,91),     V(50,30,30,60), V(03,01,01,02), V(A9,67,67,CE), V(7D,2B,2B,56),     V(19,FE,FE,E7), V(62,D7,D7,B5), V(E6,AB,AB,4D), V(9A,76,76,EC),     V(45,CA,CA,8F), V(9D,82,82,1F), V(40,C9,C9,89), V(87,7D,7D,FA),     V(15,FA,FA,EF), V(EB,59,59,B2), V(C9,47,47,8E), V(0B,F0,F0,FB),     V(EC,AD,AD,41), V(67,D4,D4,B3), V(FD,A2,A2,5F), V(EA,AF,AF,45),     V(BF,9C,9C,23), V(F7,A4,A4,53), V(96,72,72,E4), V(5B,C0,C0,9B),     V(C2,B7,B7,75), V(1C,FD,FD,E1), V(AE,93,93,3D), V(6A,26,26,4C),     V(5A,36,36,6C), V(41,3F,3F,7E), V(02,F7,F7,F5), V(4F,CC,CC,83),     V(5C,34,34,68), V(F4,A5,A5,51), V(34,E5,E5,D1), V(08,F1,F1,F9),     V(93,71,71,E2), V(73,D8,D8,AB), V(53,31,31,62), V(3F,15,15,2A),     V(0C,04,04,08), V(52,C7,C7,95), V(65,23,23,46), V(5E,C3,C3,9D),     V(28,18,18,30), V(A1,96,96,37), V(0F,05,05,0A), V(B5,9A,9A,2F),     V(09,07,07,0E), V(36,12,12,24), V(9B,80,80,1B), V(3D,E2,E2,DF),     V(26,EB,EB,CD), V(69,27,27,4E), V(CD,B2,B2,7F), V(9F,75,75,EA),     V(1B,09,09,12), V(9E,83,83,1D), V(74,2C,2C,58), V(2E,1A,1A,34),     V(2D,1B,1B,36), V(B2,6E,6E,DC), V(EE,5A,5A,B4), V(FB,A0,A0,5B),     V(F6,52,52,A4), V(4D,3B,3B,76), V(61,D6,D6,B7), V(CE,B3,B3,7D),     V(7B,29,29,52), V(3E,E3,E3,DD), V(71,2F,2F,5E), V(97,84,84,13),     V(F5,53,53,A6), V(68,D1,D1,B9), V(00,00,00,00), V(2C,ED,ED,C1),     V(60,20,20,40), V(1F,FC,FC,E3), V(C8,B1,B1,79), V(ED,5B,5B,B6),     V(BE,6A,6A,D4), V(46,CB,CB,8D), V(D9,BE,BE,67), V(4B,39,39,72),     V(DE,4A,4A,94), V(D4,4C,4C,98), V(E8,58,58,B0), V(4A,CF,CF,85),     V(6B,D0,D0,BB), V(2A,EF,EF,C5), V(E5,AA,AA,4F), V(16,FB,FB,ED),     V(C5,43,43,86), V(D7,4D,4D,9A), V(55,33,33,66), V(94,85,85,11),     V(CF,45,45,8A), V(10,F9,F9,E9), V(06,02,02,04), V(81,7F,7F,FE),     V(F0,50,50,A0), V(44,3C,3C,78), V(BA,9F,9F,25), V(E3,A8,A8,4B),     V(F3,51,51,A2), V(FE,A3,A3,5D), V(C0,40,40,80), V(8A,8F,8F,05),     V(AD,92,92,3F), V(BC,9D,9D,21), V(48,38,38,70), V(04,F5,F5,F1),     V(DF,BC,BC,63), V(C1,B6,B6,77), V(75,DA,DA,AF), V(63,21,21,42),     V(30,10,10,20), V(1A,FF,FF,E5), V(0E,F3,F3,FD), V(6D,D2,D2,BF),     V(4C,CD,CD,81), V(14,0C,0C,18), V(35,13,13,26), V(2F,EC,EC,C3),     V(E1,5F,5F,BE), V(A2,97,97,35), V(CC,44,44,88), V(39,17,17,2E),     V(57,C4,C4,93), V(F2,A7,A7,55), V(82,7E,7E,FC), V(47,3D,3D,7A),     V(AC,64,64,C8), V(E7,5D,5D,BA), V(2B,19,19,32), V(95,73,73,E6),     V(A0,60,60,C0), V(98,81,81,19), V(D1,4F,4F,9E), V(7F,DC,DC,A3),     V(66,22,22,44), V(7E,2A,2A,54), V(AB,90,90,3B), V(83,88,88,0B),     V(CA,46,46,8C), V(29,EE,EE,C7), V(D3,B8,B8,6B), V(3C,14,14,28),     V(79,DE,DE,A7), V(E2,5E,5E,BC), V(1D,0B,0B,16), V(76,DB,DB,AD),     V(3B,E0,E0,DB), V(56,32,32,64), V(4E,3A,3A,74), V(1E,0A,0A,14),     V(DB,49,49,92), V(0A,06,06,0C), V(6C,24,24,48), V(E4,5C,5C,B8),     V(5D,C2,C2,9F), V(6E,D3,D3,BD), V(EF,AC,AC,43), V(A6,62,62,C4),     V(A8,91,91,39), V(A4,95,95,31), V(37,E4,E4,D3), V(8B,79,79,F2),     V(32,E7,E7,D5), V(43,C8,C8,8B), V(59,37,37,6E), V(B7,6D,6D,DA),     V(8C,8D,8D,01), V(64,D5,D5,B1), V(D2,4E,4E,9C), V(E0,A9,A9,49),     V(B4,6C,6C,D8), V(FA,56,56,AC), V(07,F4,F4,F3), V(25,EA,EA,CF),     V(AF,65,65,CA), V(8E,7A,7A,F4), V(E9,AE,AE,47), V(18,08,08,10),     V(D5,BA,BA,6F), V(88,78,78,F0), V(6F,25,25,4A), V(72,2E,2E,5C),     V(24,1C,1C,38), V(F1,A6,A6,57), V(C7,B4,B4,73), V(51,C6,C6,97),     V(23,E8,E8,CB), V(7C,DD,DD,A1), V(9C,74,74,E8), V(21,1F,1F,3E),     V(DD,4B,4B,96), V(DC,BD,BD,61), V(86,8B,8B,0D), V(85,8A,8A,0F),     V(90,70,70,E0), V(42,3E,3E,7C), V(C4,B5,B5,71), V(AA,66,66,CC),     V(D8,48,48,90), V(05,03,03,06), V(01,F6,F6,F7), V(12,0E,0E,1C),     V(A3,61,61,C2), V(5F,35,35,6A), V(F9,57,57,AE), V(D0,B9,B9,69),     V(91,86,86,17), V(58,C1,C1,99), V(27,1D,1D,3A), V(B9,9E,9E,27),     V(38,E1,E1,D9), V(13,F8,F8,EB), V(B3,98,98,2B), V(33,11,11,22),     V(BB,69,69,D2), V(70,D9,D9,A9), V(89,8E,8E,07), V(A7,94,94,33),     V(B6,9B,9B,2D), V(22,1E,1E,3C), V(92,87,87,15), V(20,E9,E9,C9),     V(49,CE,CE,87), V(FF,55,55,AA), V(78,28,28,50), V(7A,DF,DF,A5),     V(8F,8C,8C,03), V(F8,A1,A1,59), V(80,89,89,09), V(17,0D,0D,1A),     V(DA,BF,BF,65), V(31,E6,E6,D7), V(C6,42,42,84), V(B8,68,68,D0),     V(C3,41,41,82), V(B0,99,99,29), V(77,2D,2D,5A), V(11,0F,0F,1E),     V(CB,B0,B0,7B), V(FC,54,54,A8), V(D6,BB,BB,6D), V(3A,16,16,2C)
S
S#define V(a,b,c,d) 0x##a##b##c##d
Sstatic const uint32_t FT0[256] = { FT };
S#undef V
S
S#define V(a,b,c,d) 0x##b##c##d##a
Sstatic const uint32_t FT1[256] = { FT };
S#undef V
S
S#define V(a,b,c,d) 0x##c##d##a##b
Sstatic const uint32_t FT2[256] = { FT };
S#undef V
S
S#define V(a,b,c,d) 0x##d##a##b##c
Sstatic const uint32_t FT3[256] = { FT };
S#undef V
S
S#undef FT
S
S/*
S * Reverse S-box
S */
Sstatic const unsigned char RSb[256] =
S{
S    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
S    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
S    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
S    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
S    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
S    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
S    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
S    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
S    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
S    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
S    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
S    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
S    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
S    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
S    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
S    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
S    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
S    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
S    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
S    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
S    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
S    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
S    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
S    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
S    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
S    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
S    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
S    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
S    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
S    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
S    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
S    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
S};
S
S/*
S * Reverse tables
S */
S#define RT \
S\
S    V(50,A7,F4,51), V(53,65,41,7E), V(C3,A4,17,1A), V(96,5E,27,3A), \
S    V(CB,6B,AB,3B), V(F1,45,9D,1F), V(AB,58,FA,AC), V(93,03,E3,4B), \
S    V(55,FA,30,20), V(F6,6D,76,AD), V(91,76,CC,88), V(25,4C,02,F5), \
S    V(FC,D7,E5,4F), V(D7,CB,2A,C5), V(80,44,35,26), V(8F,A3,62,B5), \
S    V(49,5A,B1,DE), V(67,1B,BA,25), V(98,0E,EA,45), V(E1,C0,FE,5D), \
S    V(02,75,2F,C3), V(12,F0,4C,81), V(A3,97,46,8D), V(C6,F9,D3,6B), \
S    V(E7,5F,8F,03), V(95,9C,92,15), V(EB,7A,6D,BF), V(DA,59,52,95), \
S    V(2D,83,BE,D4), V(D3,21,74,58), V(29,69,E0,49), V(44,C8,C9,8E), \
S    V(6A,89,C2,75), V(78,79,8E,F4), V(6B,3E,58,99), V(DD,71,B9,27), \
S    V(B6,4F,E1,BE), V(17,AD,88,F0), V(66,AC,20,C9), V(B4,3A,CE,7D), \
S    V(18,4A,DF,63), V(82,31,1A,E5), V(60,33,51,97), V(45,7F,53,62), \
S    V(E0,77,64,B1), V(84,AE,6B,BB), V(1C,A0,81,FE), V(94,2B,08,F9), \
S    V(58,68,48,70), V(19,FD,45,8F), V(87,6C,DE,94), V(B7,F8,7B,52), \
S    V(23,D3,73,AB), V(E2,02,4B,72), V(57,8F,1F,E3), V(2A,AB,55,66), \
S    V(07,28,EB,B2), V(03,C2,B5,2F), V(9A,7B,C5,86), V(A5,08,37,D3), \
S    V(F2,87,28,30), V(B2,A5,BF,23), V(BA,6A,03,02), V(5C,82,16,ED), \
S    V(2B,1C,CF,8A), V(92,B4,79,A7), V(F0,F2,07,F3), V(A1,E2,69,4E), \
S    V(CD,F4,DA,65), V(D5,BE,05,06), V(1F,62,34,D1), V(8A,FE,A6,C4), \
S    V(9D,53,2E,34), V(A0,55,F3,A2), V(32,E1,8A,05), V(75,EB,F6,A4), \
S    V(39,EC,83,0B), V(AA,EF,60,40), V(06,9F,71,5E), V(51,10,6E,BD), \
S    V(F9,8A,21,3E), V(3D,06,DD,96), V(AE,05,3E,DD), V(46,BD,E6,4D), \
S    V(B5,8D,54,91), V(05,5D,C4,71), V(6F,D4,06,04), V(FF,15,50,60), \
S    V(24,FB,98,19), V(97,E9,BD,D6), V(CC,43,40,89), V(77,9E,D9,67), \
S    V(BD,42,E8,B0), V(88,8B,89,07), V(38,5B,19,E7), V(DB,EE,C8,79), \
S    V(47,0A,7C,A1), V(E9,0F,42,7C), V(C9,1E,84,F8), V(00,00,00,00), \
S    V(83,86,80,09), V(48,ED,2B,32), V(AC,70,11,1E), V(4E,72,5A,6C), \
S    V(FB,FF,0E,FD), V(56,38,85,0F), V(1E,D5,AE,3D), V(27,39,2D,36), \
S    V(64,D9,0F,0A), V(21,A6,5C,68), V(D1,54,5B,9B), V(3A,2E,36,24), \
S    V(B1,67,0A,0C), V(0F,E7,57,93), V(D2,96,EE,B4), V(9E,91,9B,1B), \
S    V(4F,C5,C0,80), V(A2,20,DC,61), V(69,4B,77,5A), V(16,1A,12,1C), \
S    V(0A,BA,93,E2), V(E5,2A,A0,C0), V(43,E0,22,3C), V(1D,17,1B,12), \
S    V(0B,0D,09,0E), V(AD,C7,8B,F2), V(B9,A8,B6,2D), V(C8,A9,1E,14), \
S    V(85,19,F1,57), V(4C,07,75,AF), V(BB,DD,99,EE), V(FD,60,7F,A3), \
S    V(9F,26,01,F7), V(BC,F5,72,5C), V(C5,3B,66,44), V(34,7E,FB,5B), \
S    V(76,29,43,8B), V(DC,C6,23,CB), V(68,FC,ED,B6), V(63,F1,E4,B8), \
S    V(CA,DC,31,D7), V(10,85,63,42), V(40,22,97,13), V(20,11,C6,84), \
S    V(7D,24,4A,85), V(F8,3D,BB,D2), V(11,32,F9,AE), V(6D,A1,29,C7), \
S    V(4B,2F,9E,1D), V(F3,30,B2,DC), V(EC,52,86,0D), V(D0,E3,C1,77), \
S    V(6C,16,B3,2B), V(99,B9,70,A9), V(FA,48,94,11), V(22,64,E9,47), \
S    V(C4,8C,FC,A8), V(1A,3F,F0,A0), V(D8,2C,7D,56), V(EF,90,33,22), \
S    V(C7,4E,49,87), V(C1,D1,38,D9), V(FE,A2,CA,8C), V(36,0B,D4,98), \
S    V(CF,81,F5,A6), V(28,DE,7A,A5), V(26,8E,B7,DA), V(A4,BF,AD,3F), \
S    V(E4,9D,3A,2C), V(0D,92,78,50), V(9B,CC,5F,6A), V(62,46,7E,54), \
S    V(C2,13,8D,F6), V(E8,B8,D8,90), V(5E,F7,39,2E), V(F5,AF,C3,82), \
S    V(BE,80,5D,9F), V(7C,93,D0,69), V(A9,2D,D5,6F), V(B3,12,25,CF), \
S    V(3B,99,AC,C8), V(A7,7D,18,10), V(6E,63,9C,E8), V(7B,BB,3B,DB), \
S    V(09,78,26,CD), V(F4,18,59,6E), V(01,B7,9A,EC), V(A8,9A,4F,83), \
S    V(65,6E,95,E6), V(7E,E6,FF,AA), V(08,CF,BC,21), V(E6,E8,15,EF), \
S    V(D9,9B,E7,BA), V(CE,36,6F,4A), V(D4,09,9F,EA), V(D6,7C,B0,29), \
S    V(AF,B2,A4,31), V(31,23,3F,2A), V(30,94,A5,C6), V(C0,66,A2,35), \
S    V(37,BC,4E,74), V(A6,CA,82,FC), V(B0,D0,90,E0), V(15,D8,A7,33), \
S    V(4A,98,04,F1), V(F7,DA,EC,41), V(0E,50,CD,7F), V(2F,F6,91,17), \
S    V(8D,D6,4D,76), V(4D,B0,EF,43), V(54,4D,AA,CC), V(DF,04,96,E4), \
S    V(E3,B5,D1,9E), V(1B,88,6A,4C), V(B8,1F,2C,C1), V(7F,51,65,46), \
S    V(04,EA,5E,9D), V(5D,35,8C,01), V(73,74,87,FA), V(2E,41,0B,FB), \
S    V(5A,1D,67,B3), V(52,D2,DB,92), V(33,56,10,E9), V(13,47,D6,6D), \
S    V(8C,61,D7,9A), V(7A,0C,A1,37), V(8E,14,F8,59), V(89,3C,13,EB), \
S    V(EE,27,A9,CE), V(35,C9,61,B7), V(ED,E5,1C,E1), V(3C,B1,47,7A), \
S    V(59,DF,D2,9C), V(3F,73,F2,55), V(79,CE,14,18), V(BF,37,C7,73), \
S    V(EA,CD,F7,53), V(5B,AA,FD,5F), V(14,6F,3D,DF), V(86,DB,44,78), \
S    V(81,F3,AF,CA), V(3E,C4,68,B9), V(2C,34,24,38), V(5F,40,A3,C2), \
S    V(72,C3,1D,16), V(0C,25,E2,BC), V(8B,49,3C,28), V(41,95,0D,FF), \
S    V(71,01,A8,39), V(DE,B3,0C,08), V(9C,E4,B4,D8), V(90,C1,56,64), \
S    V(61,84,CB,7B), V(70,B6,32,D5), V(74,5C,6C,48), V(42,57,B8,D0)
X#define RT     V(50,A7,F4,51), V(53,65,41,7E), V(C3,A4,17,1A), V(96,5E,27,3A),     V(CB,6B,AB,3B), V(F1,45,9D,1F), V(AB,58,FA,AC), V(93,03,E3,4B),     V(55,FA,30,20), V(F6,6D,76,AD), V(91,76,CC,88), V(25,4C,02,F5),     V(FC,D7,E5,4F), V(D7,CB,2A,C5), V(80,44,35,26), V(8F,A3,62,B5),     V(49,5A,B1,DE), V(67,1B,BA,25), V(98,0E,EA,45), V(E1,C0,FE,5D),     V(02,75,2F,C3), V(12,F0,4C,81), V(A3,97,46,8D), V(C6,F9,D3,6B),     V(E7,5F,8F,03), V(95,9C,92,15), V(EB,7A,6D,BF), V(DA,59,52,95),     V(2D,83,BE,D4), V(D3,21,74,58), V(29,69,E0,49), V(44,C8,C9,8E),     V(6A,89,C2,75), V(78,79,8E,F4), V(6B,3E,58,99), V(DD,71,B9,27),     V(B6,4F,E1,BE), V(17,AD,88,F0), V(66,AC,20,C9), V(B4,3A,CE,7D),     V(18,4A,DF,63), V(82,31,1A,E5), V(60,33,51,97), V(45,7F,53,62),     V(E0,77,64,B1), V(84,AE,6B,BB), V(1C,A0,81,FE), V(94,2B,08,F9),     V(58,68,48,70), V(19,FD,45,8F), V(87,6C,DE,94), V(B7,F8,7B,52),     V(23,D3,73,AB), V(E2,02,4B,72), V(57,8F,1F,E3), V(2A,AB,55,66),     V(07,28,EB,B2), V(03,C2,B5,2F), V(9A,7B,C5,86), V(A5,08,37,D3),     V(F2,87,28,30), V(B2,A5,BF,23), V(BA,6A,03,02), V(5C,82,16,ED),     V(2B,1C,CF,8A), V(92,B4,79,A7), V(F0,F2,07,F3), V(A1,E2,69,4E),     V(CD,F4,DA,65), V(D5,BE,05,06), V(1F,62,34,D1), V(8A,FE,A6,C4),     V(9D,53,2E,34), V(A0,55,F3,A2), V(32,E1,8A,05), V(75,EB,F6,A4),     V(39,EC,83,0B), V(AA,EF,60,40), V(06,9F,71,5E), V(51,10,6E,BD),     V(F9,8A,21,3E), V(3D,06,DD,96), V(AE,05,3E,DD), V(46,BD,E6,4D),     V(B5,8D,54,91), V(05,5D,C4,71), V(6F,D4,06,04), V(FF,15,50,60),     V(24,FB,98,19), V(97,E9,BD,D6), V(CC,43,40,89), V(77,9E,D9,67),     V(BD,42,E8,B0), V(88,8B,89,07), V(38,5B,19,E7), V(DB,EE,C8,79),     V(47,0A,7C,A1), V(E9,0F,42,7C), V(C9,1E,84,F8), V(00,00,00,00),     V(83,86,80,09), V(48,ED,2B,32), V(AC,70,11,1E), V(4E,72,5A,6C),     V(FB,FF,0E,FD), V(56,38,85,0F), V(1E,D5,AE,3D), V(27,39,2D,36),     V(64,D9,0F,0A), V(21,A6,5C,68), V(D1,54,5B,9B), V(3A,2E,36,24),     V(B1,67,0A,0C), V(0F,E7,57,93), V(D2,96,EE,B4), V(9E,91,9B,1B),     V(4F,C5,C0,80), V(A2,20,DC,61), V(69,4B,77,5A), V(16,1A,12,1C),     V(0A,BA,93,E2), V(E5,2A,A0,C0), V(43,E0,22,3C), V(1D,17,1B,12),     V(0B,0D,09,0E), V(AD,C7,8B,F2), V(B9,A8,B6,2D), V(C8,A9,1E,14),     V(85,19,F1,57), V(4C,07,75,AF), V(BB,DD,99,EE), V(FD,60,7F,A3),     V(9F,26,01,F7), V(BC,F5,72,5C), V(C5,3B,66,44), V(34,7E,FB,5B),     V(76,29,43,8B), V(DC,C6,23,CB), V(68,FC,ED,B6), V(63,F1,E4,B8),     V(CA,DC,31,D7), V(10,85,63,42), V(40,22,97,13), V(20,11,C6,84),     V(7D,24,4A,85), V(F8,3D,BB,D2), V(11,32,F9,AE), V(6D,A1,29,C7),     V(4B,2F,9E,1D), V(F3,30,B2,DC), V(EC,52,86,0D), V(D0,E3,C1,77),     V(6C,16,B3,2B), V(99,B9,70,A9), V(FA,48,94,11), V(22,64,E9,47),     V(C4,8C,FC,A8), V(1A,3F,F0,A0), V(D8,2C,7D,56), V(EF,90,33,22),     V(C7,4E,49,87), V(C1,D1,38,D9), V(FE,A2,CA,8C), V(36,0B,D4,98),     V(CF,81,F5,A6), V(28,DE,7A,A5), V(26,8E,B7,DA), V(A4,BF,AD,3F),     V(E4,9D,3A,2C), V(0D,92,78,50), V(9B,CC,5F,6A), V(62,46,7E,54),     V(C2,13,8D,F6), V(E8,B8,D8,90), V(5E,F7,39,2E), V(F5,AF,C3,82),     V(BE,80,5D,9F), V(7C,93,D0,69), V(A9,2D,D5,6F), V(B3,12,25,CF),     V(3B,99,AC,C8), V(A7,7D,18,10), V(6E,63,9C,E8), V(7B,BB,3B,DB),     V(09,78,26,CD), V(F4,18,59,6E), V(01,B7,9A,EC), V(A8,9A,4F,83),     V(65,6E,95,E6), V(7E,E6,FF,AA), V(08,CF,BC,21), V(E6,E8,15,EF),     V(D9,9B,E7,BA), V(CE,36,6F,4A), V(D4,09,9F,EA), V(D6,7C,B0,29),     V(AF,B2,A4,31), V(31,23,3F,2A), V(30,94,A5,C6), V(C0,66,A2,35),     V(37,BC,4E,74), V(A6,CA,82,FC), V(B0,D0,90,E0), V(15,D8,A7,33),     V(4A,98,04,F1), V(F7,DA,EC,41), V(0E,50,CD,7F), V(2F,F6,91,17),     V(8D,D6,4D,76), V(4D,B0,EF,43), V(54,4D,AA,CC), V(DF,04,96,E4),     V(E3,B5,D1,9E), V(1B,88,6A,4C), V(B8,1F,2C,C1), V(7F,51,65,46),     V(04,EA,5E,9D), V(5D,35,8C,01), V(73,74,87,FA), V(2E,41,0B,FB),     V(5A,1D,67,B3), V(52,D2,DB,92), V(33,56,10,E9), V(13,47,D6,6D),     V(8C,61,D7,9A), V(7A,0C,A1,37), V(8E,14,F8,59), V(89,3C,13,EB),     V(EE,27,A9,CE), V(35,C9,61,B7), V(ED,E5,1C,E1), V(3C,B1,47,7A),     V(59,DF,D2,9C), V(3F,73,F2,55), V(79,CE,14,18), V(BF,37,C7,73),     V(EA,CD,F7,53), V(5B,AA,FD,5F), V(14,6F,3D,DF), V(86,DB,44,78),     V(81,F3,AF,CA), V(3E,C4,68,B9), V(2C,34,24,38), V(5F,40,A3,C2),     V(72,C3,1D,16), V(0C,25,E2,BC), V(8B,49,3C,28), V(41,95,0D,FF),     V(71,01,A8,39), V(DE,B3,0C,08), V(9C,E4,B4,D8), V(90,C1,56,64),     V(61,84,CB,7B), V(70,B6,32,D5), V(74,5C,6C,48), V(42,57,B8,D0)
S
S#define V(a,b,c,d) 0x##a##b##c##d
Sstatic const uint32_t RT0[256] = { RT };
S#undef V
S
S#define V(a,b,c,d) 0x##b##c##d##a
Sstatic const uint32_t RT1[256] = { RT };
S#undef V
S
S#define V(a,b,c,d) 0x##c##d##a##b
Sstatic const uint32_t RT2[256] = { RT };
S#undef V
S
S#define V(a,b,c,d) 0x##d##a##b##c
Sstatic const uint32_t RT3[256] = { RT };
S#undef V
S
S#undef RT
S
S/*
S * Round constants
S */
Sstatic const uint32_t RCON[10] =
S{
S    0x00000001, 0x00000002, 0x00000004, 0x00000008,
S    0x00000010, 0x00000020, 0x00000040, 0x00000080,
S    0x0000001B, 0x00000036
S};
S
S#else /* MBEDTLS_AES_ROM_TABLES */
S
S/*
S * Forward S-box & tables
S */
Sstatic unsigned char FSb[256];
Sstatic uint32_t FT0[256];
Sstatic uint32_t FT1[256];
Sstatic uint32_t FT2[256];
Sstatic uint32_t FT3[256];
S
S/*
S * Reverse S-box & tables
S */
Sstatic unsigned char RSb[256];
Sstatic uint32_t RT0[256];
Sstatic uint32_t RT1[256];
Sstatic uint32_t RT2[256];
Sstatic uint32_t RT3[256];
S
S/*
S * Round constants
S */
Sstatic uint32_t RCON[10];
S
S/*
S * Tables generation code
S */
S#define ROTL8(x) ( ( x << 8 ) & 0xFFFFFFFF ) | ( x >> 24 )
S#define XTIME(x) ( ( x << 1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) )
S#define MUL(x,y) ( ( x && y ) ? pow[(log[x]+log[y]) % 255] : 0 )
S
Sstatic int aes_init_done = 0;
S
Sstatic void aes_gen_tables( void )
S{
S    int i, x, y, z;
S    int pow[256];
S    int log[256];
S
S    /*
S     * compute pow and log tables over GF(2^8)
S     */
S    for( i = 0, x = 1; i < 256; i++ )
S    {
S        pow[i] = x;
S        log[x] = i;
S        x = ( x ^ XTIME( x ) ) & 0xFF;
S    }
S
S    /*
S     * calculate the round constants
S     */
S    for( i = 0, x = 1; i < 10; i++ )
S    {
S        RCON[i] = (uint32_t) x;
S        x = XTIME( x ) & 0xFF;
S    }
S
S    /*
S     * generate the forward and reverse S-boxes
S     */
S    FSb[0x00] = 0x63;
S    RSb[0x63] = 0x00;
S
S    for( i = 1; i < 256; i++ )
S    {
S        x = pow[255 - log[i]];
S
S        y  = x; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
S        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
S        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
S        x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
S        x ^= y ^ 0x63;
S
S        FSb[i] = (unsigned char) x;
S        RSb[x] = (unsigned char) i;
S    }
S
S    /*
S     * generate the forward and reverse tables
S     */
S    for( i = 0; i < 256; i++ )
S    {
S        x = FSb[i];
S        y = XTIME( x ) & 0xFF;
S        z =  ( y ^ x ) & 0xFF;
S
S        FT0[i] = ( (uint32_t) y       ) ^
S                 ( (uint32_t) x <<  8 ) ^
S                 ( (uint32_t) x << 16 ) ^
S                 ( (uint32_t) z << 24 );
S
S        FT1[i] = ROTL8( FT0[i] );
S        FT2[i] = ROTL8( FT1[i] );
S        FT3[i] = ROTL8( FT2[i] );
S
S        x = RSb[i];
S
S        RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
S                 ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^
S                 ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^
S                 ( (uint32_t) MUL( 0x0B, x ) << 24 );
S
S        RT1[i] = ROTL8( RT0[i] );
S        RT2[i] = ROTL8( RT1[i] );
S        RT3[i] = ROTL8( RT2[i] );
S    }
S}
S
S#endif /* MBEDTLS_AES_ROM_TABLES */
S
Svoid mbedtls_aes_init( mbedtls_aes_context *ctx )
S{
S    memset( ctx, 0, sizeof( mbedtls_aes_context ) );
S}
S
Svoid mbedtls_aes_free( mbedtls_aes_context *ctx )
S{
S    if( ctx == NULL )
S        return;
S
S    mbedtls_zeroize( ctx, sizeof( mbedtls_aes_context ) );
S}
S
S/*
S * AES key schedule (encryption)
S */
S#if !defined(MBEDTLS_AES_SETKEY_ENC_ALT)
Sint mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key,
S                    unsigned int keybits )
S{
S    unsigned int i;
S    uint32_t *RK;
S
S#if !defined(MBEDTLS_AES_ROM_TABLES)
S    if( aes_init_done == 0 )
S    {
S        aes_gen_tables();
S        aes_init_done = 1;
S
S    }
S#endif
S
S    switch( keybits )
S    {
S        case 128: ctx->nr = 10; break;
S        case 192: ctx->nr = 12; break;
S        case 256: ctx->nr = 14; break;
S        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
S    }
S
S#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)
S    if( aes_padlock_ace == -1 )
S        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );
S
S    if( aes_padlock_ace )
S        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
S    else
S#endif
S    ctx->rk = RK = ctx->buf;
S
S#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
S    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
S        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );
S#endif
S
S    for( i = 0; i < ( keybits >> 5 ); i++ )
S    {
S        GET_UINT32_LE( RK[i], key, i << 2 );
S    }
S
S    switch( ctx->nr )
S    {
S        case 10:
S
S            for( i = 0; i < 10; i++, RK += 4 )
S            {
S                RK[4]  = RK[0] ^ RCON[i] ^
S                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
S                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
S                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
S                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
S
S                RK[5]  = RK[1] ^ RK[4];
S                RK[6]  = RK[2] ^ RK[5];
S                RK[7]  = RK[3] ^ RK[6];
S            }
S            break;
S
S        case 12:
S
S            for( i = 0; i < 8; i++, RK += 6 )
S            {
S                RK[6]  = RK[0] ^ RCON[i] ^
S                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
S                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
S                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
S                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
S
S                RK[7]  = RK[1] ^ RK[6];
S                RK[8]  = RK[2] ^ RK[7];
S                RK[9]  = RK[3] ^ RK[8];
S                RK[10] = RK[4] ^ RK[9];
S                RK[11] = RK[5] ^ RK[10];
S            }
S            break;
S
S        case 14:
S
S            for( i = 0; i < 7; i++, RK += 8 )
S            {
S                RK[8]  = RK[0] ^ RCON[i] ^
S                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
S                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
S                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
S                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
S
S                RK[9]  = RK[1] ^ RK[8];
S                RK[10] = RK[2] ^ RK[9];
S                RK[11] = RK[3] ^ RK[10];
S
S                RK[12] = RK[4] ^
S                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
S                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
S                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
S                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );
S
S                RK[13] = RK[5] ^ RK[12];
S                RK[14] = RK[6] ^ RK[13];
S                RK[15] = RK[7] ^ RK[14];
S            }
S            break;
S    }
S
S    return( 0 );
S}
S#endif /* !MBEDTLS_AES_SETKEY_ENC_ALT */
S
S/*
S * AES key schedule (decryption)
S */
S#if !defined(MBEDTLS_AES_SETKEY_DEC_ALT)
Sint mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,
S                    unsigned int keybits )
S{
S    int i, j, ret;
S    mbedtls_aes_context cty;
S    uint32_t *RK;
S    uint32_t *SK;
S
S    mbedtls_aes_init( &cty );
S
S#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)
S    if( aes_padlock_ace == -1 )
S        aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );
S
S    if( aes_padlock_ace )
S        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
S    else
S#endif
S    ctx->rk = RK = ctx->buf;
S
S    /* Also checks keybits */
S    if( ( ret = mbedtls_aes_setkey_enc( &cty, key, keybits ) ) != 0 )
S        goto exit;
S
S    ctx->nr = cty.nr;
S
S#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
S    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
S    {
S        mbedtls_aesni_inverse_key( (unsigned char *) ctx->rk,
S                           (const unsigned char *) cty.rk, ctx->nr );
S        goto exit;
S    }
S#endif
S
S    SK = cty.rk + cty.nr * 4;
S
S    *RK++ = *SK++;
S    *RK++ = *SK++;
S    *RK++ = *SK++;
S    *RK++ = *SK++;
S
S    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
S    {
S        for( j = 0; j < 4; j++, SK++ )
S        {
S            *RK++ = RT0[ FSb[ ( *SK       ) & 0xFF ] ] ^
S                    RT1[ FSb[ ( *SK >>  8 ) & 0xFF ] ] ^
S                    RT2[ FSb[ ( *SK >> 16 ) & 0xFF ] ] ^
S                    RT3[ FSb[ ( *SK >> 24 ) & 0xFF ] ];
S        }
S    }
S
S    *RK++ = *SK++;
S    *RK++ = *SK++;
S    *RK++ = *SK++;
S    *RK++ = *SK++;
S
Sexit:
S    mbedtls_aes_free( &cty );
S
S    return( ret );
S}
S#endif /* !MBEDTLS_AES_SETKEY_DEC_ALT */
S
S#define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
S{                                               \
S    X0 = *RK++ ^ FT0[ ( Y0       ) & 0xFF ] ^   \
S                 FT1[ ( Y1 >>  8 ) & 0xFF ] ^   \
S                 FT2[ ( Y2 >> 16 ) & 0xFF ] ^   \
S                 FT3[ ( Y3 >> 24 ) & 0xFF ];    \
S                                                \
S    X1 = *RK++ ^ FT0[ ( Y1       ) & 0xFF ] ^   \
S                 FT1[ ( Y2 >>  8 ) & 0xFF ] ^   \
S                 FT2[ ( Y3 >> 16 ) & 0xFF ] ^   \
S                 FT3[ ( Y0 >> 24 ) & 0xFF ];    \
S                                                \
S    X2 = *RK++ ^ FT0[ ( Y2       ) & 0xFF ] ^   \
S                 FT1[ ( Y3 >>  8 ) & 0xFF ] ^   \
S                 FT2[ ( Y0 >> 16 ) & 0xFF ] ^   \
S                 FT3[ ( Y1 >> 24 ) & 0xFF ];    \
S                                                \
S    X3 = *RK++ ^ FT0[ ( Y3       ) & 0xFF ] ^   \
S                 FT1[ ( Y0 >>  8 ) & 0xFF ] ^   \
S                 FT2[ ( Y1 >> 16 ) & 0xFF ] ^   \
S                 FT3[ ( Y2 >> 24 ) & 0xFF ];    \
S}
X#define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     {                                                   X0 = *RK++ ^ FT0[ ( Y0       ) & 0xFF ] ^                    FT1[ ( Y1 >>  8 ) & 0xFF ] ^                    FT2[ ( Y2 >> 16 ) & 0xFF ] ^                    FT3[ ( Y3 >> 24 ) & 0xFF ];                                                        X1 = *RK++ ^ FT0[ ( Y1       ) & 0xFF ] ^                    FT1[ ( Y2 >>  8 ) & 0xFF ] ^                    FT2[ ( Y3 >> 16 ) & 0xFF ] ^                    FT3[ ( Y0 >> 24 ) & 0xFF ];                                                        X2 = *RK++ ^ FT0[ ( Y2       ) & 0xFF ] ^                    FT1[ ( Y3 >>  8 ) & 0xFF ] ^                    FT2[ ( Y0 >> 16 ) & 0xFF ] ^                    FT3[ ( Y1 >> 24 ) & 0xFF ];                                                        X3 = *RK++ ^ FT0[ ( Y3       ) & 0xFF ] ^                    FT1[ ( Y0 >>  8 ) & 0xFF ] ^                    FT2[ ( Y1 >> 16 ) & 0xFF ] ^                    FT3[ ( Y2 >> 24 ) & 0xFF ];    }
S
S#define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
S{                                               \
S    X0 = *RK++ ^ RT0[ ( Y0       ) & 0xFF ] ^   \
S                 RT1[ ( Y3 >>  8 ) & 0xFF ] ^   \
S                 RT2[ ( Y2 >> 16 ) & 0xFF ] ^   \
S                 RT3[ ( Y1 >> 24 ) & 0xFF ];    \
S                                                \
S    X1 = *RK++ ^ RT0[ ( Y1       ) & 0xFF ] ^   \
S                 RT1[ ( Y0 >>  8 ) & 0xFF ] ^   \
S                 RT2[ ( Y3 >> 16 ) & 0xFF ] ^   \
S                 RT3[ ( Y2 >> 24 ) & 0xFF ];    \
S                                                \
S    X2 = *RK++ ^ RT0[ ( Y2       ) & 0xFF ] ^   \
S                 RT1[ ( Y1 >>  8 ) & 0xFF ] ^   \
S                 RT2[ ( Y0 >> 16 ) & 0xFF ] ^   \
S                 RT3[ ( Y3 >> 24 ) & 0xFF ];    \
S                                                \
S    X3 = *RK++ ^ RT0[ ( Y3       ) & 0xFF ] ^   \
S                 RT1[ ( Y2 >>  8 ) & 0xFF ] ^   \
S                 RT2[ ( Y1 >> 16 ) & 0xFF ] ^   \
S                 RT3[ ( Y0 >> 24 ) & 0xFF ];    \
S}
X#define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     {                                                   X0 = *RK++ ^ RT0[ ( Y0       ) & 0xFF ] ^                    RT1[ ( Y3 >>  8 ) & 0xFF ] ^                    RT2[ ( Y2 >> 16 ) & 0xFF ] ^                    RT3[ ( Y1 >> 24 ) & 0xFF ];                                                        X1 = *RK++ ^ RT0[ ( Y1       ) & 0xFF ] ^                    RT1[ ( Y0 >>  8 ) & 0xFF ] ^                    RT2[ ( Y3 >> 16 ) & 0xFF ] ^                    RT3[ ( Y2 >> 24 ) & 0xFF ];                                                        X2 = *RK++ ^ RT0[ ( Y2       ) & 0xFF ] ^                    RT1[ ( Y1 >>  8 ) & 0xFF ] ^                    RT2[ ( Y0 >> 16 ) & 0xFF ] ^                    RT3[ ( Y3 >> 24 ) & 0xFF ];                                                        X3 = *RK++ ^ RT0[ ( Y3       ) & 0xFF ] ^                    RT1[ ( Y2 >>  8 ) & 0xFF ] ^                    RT2[ ( Y1 >> 16 ) & 0xFF ] ^                    RT3[ ( Y0 >> 24 ) & 0xFF ];    }
S
S/*
S * AES-ECB block encryption
S */
S#if !defined(MBEDTLS_AES_ENCRYPT_ALT)
Svoid mbedtls_aes_encrypt( mbedtls_aes_context *ctx,
S                          const unsigned char input[16],
S                          unsigned char output[16] )
S{
S    int i;
S    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
S
S    RK = ctx->rk;
S
S    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
S    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
S    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
S    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
S
S    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
S    {
S        AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
S        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
S    }
S
S    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
S
S    X0 = *RK++ ^ \
S            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
X    X0 = *RK++ ^             ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
S            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
S            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
S            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
S
S    X1 = *RK++ ^ \
S            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
X    X1 = *RK++ ^             ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
S            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
S            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
S            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
S
S    X2 = *RK++ ^ \
S            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
X    X2 = *RK++ ^             ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
S            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
S            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
S            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
S
S    X3 = *RK++ ^ \
S            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
X    X3 = *RK++ ^             ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
S            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
S            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
S            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
S
S    PUT_UINT32_LE( X0, output,  0 );
S    PUT_UINT32_LE( X1, output,  4 );
S    PUT_UINT32_LE( X2, output,  8 );
S    PUT_UINT32_LE( X3, output, 12 );
S}
S#endif /* !MBEDTLS_AES_ENCRYPT_ALT */
S
S/*
S * AES-ECB block decryption
S */
S#if !defined(MBEDTLS_AES_DECRYPT_ALT)
Svoid mbedtls_aes_decrypt( mbedtls_aes_context *ctx,
S                          const unsigned char input[16],
S                          unsigned char output[16] )
S{
S    int i;
S    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
S
S    RK = ctx->rk;
S
S    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
S    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
S    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
S    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
S
S    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
S    {
S        AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
S        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
S    }
S
S    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
S
S    X0 = *RK++ ^ \
S            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
X    X0 = *RK++ ^             ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
S            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
S            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
S            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
S
S    X1 = *RK++ ^ \
S            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
X    X1 = *RK++ ^             ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
S            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
S            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
S            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
S
S    X2 = *RK++ ^ \
S            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
X    X2 = *RK++ ^             ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
S            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
S            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
S            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
S
S    X3 = *RK++ ^ \
S            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
X    X3 = *RK++ ^             ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
S            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
S            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
S            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
S
S    PUT_UINT32_LE( X0, output,  0 );
S    PUT_UINT32_LE( X1, output,  4 );
S    PUT_UINT32_LE( X2, output,  8 );
S    PUT_UINT32_LE( X3, output, 12 );
S}
S#endif /* !MBEDTLS_AES_DECRYPT_ALT */
S
S/*
S * AES-ECB block encryption/decryption
S */
Sint mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,
S                    int mode,
S                    const unsigned char input[16],
S                    unsigned char output[16] )
S{
S#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
S    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
S        return( mbedtls_aesni_crypt_ecb( ctx, mode, input, output ) );
S#endif
S
S#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)
S    if( aes_padlock_ace )
S    {
S        if( mbedtls_padlock_xcryptecb( ctx, mode, input, output ) == 0 )
S            return( 0 );
S
S        // If padlock data misaligned, we just fall back to
S        // unaccelerated mode
S        //
S    }
S#endif
S
S    if( mode == MBEDTLS_AES_ENCRYPT )
S        mbedtls_aes_encrypt( ctx, input, output );
S    else
S        mbedtls_aes_decrypt( ctx, input, output );
S
S    return( 0 );
S}
S
S#if defined(MBEDTLS_CIPHER_MODE_CBC)
S/*
S * AES-CBC buffer encryption/decryption
S */
Sint mbedtls_aes_crypt_cbc( mbedtls_aes_context *ctx,
S                    int mode,
S                    size_t length,
S                    unsigned char iv[16],
S                    const unsigned char *input,
S                    unsigned char *output )
S{
S    int i;
S    unsigned char temp[16];
S
S    if( length % 16 )
S        return( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
S
S#if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)
S    if( aes_padlock_ace )
S    {
S        if( mbedtls_padlock_xcryptcbc( ctx, mode, length, iv, input, output ) == 0 )
S            return( 0 );
S
S        // If padlock data misaligned, we just fall back to
S        // unaccelerated mode
S        //
S    }
S#endif
S
S    if( mode == MBEDTLS_AES_DECRYPT )
S    {
S        while( length > 0 )
S        {
S            memcpy( temp, input, 16 );
S            mbedtls_aes_crypt_ecb( ctx, mode, input, output );
S
S            for( i = 0; i < 16; i++ )
S                output[i] = (unsigned char)( output[i] ^ iv[i] );
S
S            memcpy( iv, temp, 16 );
S
S            input  += 16;
S            output += 16;
S            length -= 16;
S        }
S    }
S    else
S    {
S        while( length > 0 )
S        {
S            for( i = 0; i < 16; i++ )
S                output[i] = (unsigned char)( input[i] ^ iv[i] );
S
S            mbedtls_aes_crypt_ecb( ctx, mode, output, output );
S            memcpy( iv, output, 16 );
S
S            input  += 16;
S            output += 16;
S            length -= 16;
S        }
S    }
S
S    return( 0 );
S}
S#endif /* MBEDTLS_CIPHER_MODE_CBC */
S
S#if defined(MBEDTLS_CIPHER_MODE_CFB)
S/*
S * AES-CFB128 buffer encryption/decryption
S */
Sint mbedtls_aes_crypt_cfb128( mbedtls_aes_context *ctx,
S                       int mode,
S                       size_t length,
S                       size_t *iv_off,
S                       unsigned char iv[16],
S                       const unsigned char *input,
S                       unsigned char *output )
S{
S    int c;
S    size_t n = *iv_off;
S
S    if( mode == MBEDTLS_AES_DECRYPT )
S    {
S        while( length-- )
S        {
S            if( n == 0 )
S                mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
S
S            c = *input++;
S            *output++ = (unsigned char)( c ^ iv[n] );
S            iv[n] = (unsigned char) c;
S
S            n = ( n + 1 ) & 0x0F;
S        }
S    }
S    else
S    {
S        while( length-- )
S        {
S            if( n == 0 )
S                mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
S
S            iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );
S
S            n = ( n + 1 ) & 0x0F;
S        }
S    }
S
S    *iv_off = n;
S
S    return( 0 );
S}
S
S/*
S * AES-CFB8 buffer encryption/decryption
S */
Sint mbedtls_aes_crypt_cfb8( mbedtls_aes_context *ctx,
S                       int mode,
S                       size_t length,
S                       unsigned char iv[16],
S                       const unsigned char *input,
S                       unsigned char *output )
S{
S    unsigned char c;
S    unsigned char ov[17];
S
S    while( length-- )
S    {
S        memcpy( ov, iv, 16 );
S        mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
S
S        if( mode == MBEDTLS_AES_DECRYPT )
S            ov[16] = *input;
S
S        c = *output++ = (unsigned char)( iv[0] ^ *input++ );
S
S        if( mode == MBEDTLS_AES_ENCRYPT )
S            ov[16] = c;
S
S        memcpy( iv, ov + 1, 16 );
S    }
S
S    return( 0 );
S}
S#endif /*MBEDTLS_CIPHER_MODE_CFB */
S
S#if defined(MBEDTLS_CIPHER_MODE_CTR)
S/*
S * AES-CTR buffer encryption/decryption
S */
Sint mbedtls_aes_crypt_ctr( mbedtls_aes_context *ctx,
S                       size_t length,
S                       size_t *nc_off,
S                       unsigned char nonce_counter[16],
S                       unsigned char stream_block[16],
S                       const unsigned char *input,
S                       unsigned char *output )
S{
S    int c, i;
S    size_t n = *nc_off;
S
S    while( length-- )
S    {
S        if( n == 0 ) {
S            mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, nonce_counter, stream_block );
S
S            for( i = 16; i > 0; i-- )
S                if( ++nonce_counter[i - 1] != 0 )
S                    break;
S        }
S        c = *input++;
S        *output++ = (unsigned char)( c ^ stream_block[n] );
S
S        n = ( n + 1 ) & 0x0F;
S    }
S
S    *nc_off = n;
S
S    return( 0 );
S}
S#endif /* MBEDTLS_CIPHER_MODE_CTR */
S
S#endif /* !MBEDTLS_AES_ALT */
S
S#if defined(MBEDTLS_SELF_TEST)
S/*
S * AES test vectors from:
S *
S * http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip
S */
Sstatic const unsigned char aes_test_ecb_dec[3][16] =
S{
S    { 0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,
S      0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0 },
S    { 0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,
S      0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4 },
S    { 0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,
S      0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE }
S};
S
Sstatic const unsigned char aes_test_ecb_enc[3][16] =
S{
S    { 0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,
S      0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F },
S    { 0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,
S      0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14 },
S    { 0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,
S      0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4 }
S};
S
S#if defined(MBEDTLS_CIPHER_MODE_CBC)
Sstatic const unsigned char aes_test_cbc_dec[3][16] =
S{
S    { 0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,
S      0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86 },
S    { 0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,
S      0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B },
S    { 0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,
S      0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13 }
S};
S
Sstatic const unsigned char aes_test_cbc_enc[3][16] =
S{
S    { 0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,
S      0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D },
S    { 0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,
S      0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04 },
S    { 0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,
S      0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0 }
S};
S#endif /* MBEDTLS_CIPHER_MODE_CBC */
S
S#if defined(MBEDTLS_CIPHER_MODE_CFB)
S/*
S * AES-CFB128 test vectors from:
S *
S * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
S */
Sstatic const unsigned char aes_test_cfb128_key[3][32] =
S{
S    { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
S      0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C },
S    { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,
S      0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,
S      0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B },
S    { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,
S      0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,
S      0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,
S      0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 }
S};
S
Sstatic const unsigned char aes_test_cfb128_iv[16] =
S{
S    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
S    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
S};
S
Sstatic const unsigned char aes_test_cfb128_pt[64] =
S{
S    0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
S    0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,
S    0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
S    0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,
S    0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
S    0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,
S    0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,
S    0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
S};
S
Sstatic const unsigned char aes_test_cfb128_ct[3][64] =
S{
S    { 0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,
S      0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,
S      0xC8, 0xA6, 0x45, 0x37, 0xA0, 0xB3, 0xA9, 0x3F,
S      0xCD, 0xE3, 0xCD, 0xAD, 0x9F, 0x1C, 0xE5, 0x8B,
S      0x26, 0x75, 0x1F, 0x67, 0xA3, 0xCB, 0xB1, 0x40,
S      0xB1, 0x80, 0x8C, 0xF1, 0x87, 0xA4, 0xF4, 0xDF,
S      0xC0, 0x4B, 0x05, 0x35, 0x7C, 0x5D, 0x1C, 0x0E,
S      0xEA, 0xC4, 0xC6, 0x6F, 0x9F, 0xF7, 0xF2, 0xE6 },
S    { 0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,
S      0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,
S      0x67, 0xCE, 0x7F, 0x7F, 0x81, 0x17, 0x36, 0x21,
S      0x96, 0x1A, 0x2B, 0x70, 0x17, 0x1D, 0x3D, 0x7A,
S      0x2E, 0x1E, 0x8A, 0x1D, 0xD5, 0x9B, 0x88, 0xB1,
S      0xC8, 0xE6, 0x0F, 0xED, 0x1E, 0xFA, 0xC4, 0xC9,
S      0xC0, 0x5F, 0x9F, 0x9C, 0xA9, 0x83, 0x4F, 0xA0,
S      0x42, 0xAE, 0x8F, 0xBA, 0x58, 0x4B, 0x09, 0xFF },
S    { 0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,
S      0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,
S      0x39, 0xFF, 0xED, 0x14, 0x3B, 0x28, 0xB1, 0xC8,
S      0x32, 0x11, 0x3C, 0x63, 0x31, 0xE5, 0x40, 0x7B,
S      0xDF, 0x10, 0x13, 0x24, 0x15, 0xE5, 0x4B, 0x92,
S      0xA1, 0x3E, 0xD0, 0xA8, 0x26, 0x7A, 0xE2, 0xF9,
S      0x75, 0xA3, 0x85, 0x74, 0x1A, 0xB9, 0xCE, 0xF8,
S      0x20, 0x31, 0x62, 0x3D, 0x55, 0xB1, 0xE4, 0x71 }
S};
S#endif /* MBEDTLS_CIPHER_MODE_CFB */
S
S#if defined(MBEDTLS_CIPHER_MODE_CTR)
S/*
S * AES-CTR test vectors from:
S *
S * http://www.faqs.org/rfcs/rfc3686.html
S */
S
Sstatic const unsigned char aes_test_ctr_key[3][16] =
S{
S    { 0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
S      0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E },
S    { 0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7,
S      0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63 },
S    { 0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8,
S      0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC }
S};
S
Sstatic const unsigned char aes_test_ctr_nonce_counter[3][16] =
S{
S    { 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
S      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
S    { 0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59,
S      0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01 },
S    { 0x00, 0xE0, 0x01, 0x7B, 0x27, 0x77, 0x7F, 0x3F,
S      0x4A, 0x17, 0x86, 0xF0, 0x00, 0x00, 0x00, 0x01 }
S};
S
Sstatic const unsigned char aes_test_ctr_pt[3][48] =
S{
S    { 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,
S      0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67 },
S
S    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
S      0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
S      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
S      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F },
S
S    { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
S      0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
S      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
S      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
S      0x20, 0x21, 0x22, 0x23 }
S};
S
Sstatic const unsigned char aes_test_ctr_ct[3][48] =
S{
S    { 0xE4, 0x09, 0x5D, 0x4F, 0xB7, 0xA7, 0xB3, 0x79,
S      0x2D, 0x61, 0x75, 0xA3, 0x26, 0x13, 0x11, 0xB8 },
S    { 0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9,
S      0x79, 0x0D, 0x41, 0xEE, 0x8E, 0xDA, 0xD3, 0x88,
S      0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA, 0x57, 0xC8,
S      0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28 },
S    { 0xC1, 0xCF, 0x48, 0xA8, 0x9F, 0x2F, 0xFD, 0xD9,
S      0xCF, 0x46, 0x52, 0xE9, 0xEF, 0xDB, 0x72, 0xD7,
S      0x45, 0x40, 0xA4, 0x2B, 0xDE, 0x6D, 0x78, 0x36,
S      0xD5, 0x9A, 0x5C, 0xEA, 0xAE, 0xF3, 0x10, 0x53,
S      0x25, 0xB2, 0x07, 0x2F }
S};
S
Sstatic const int aes_test_ctr_len[3] =
S    { 16, 32, 36 };
S#endif /* MBEDTLS_CIPHER_MODE_CTR */
S
S/*
S * Checkup routine
S */
Sint mbedtls_aes_self_test( int verbose )
S{
S    int ret = 0, i, j, u, v;
S    unsigned char key[32];
S    unsigned char buf[64];
S    unsigned char iv[16];
S#if defined(MBEDTLS_CIPHER_MODE_CBC)
S    unsigned char prv[16];
S#endif
S#if defined(MBEDTLS_CIPHER_MODE_CTR) || defined(MBEDTLS_CIPHER_MODE_CFB)
S    size_t offset;
S#endif
S#if defined(MBEDTLS_CIPHER_MODE_CTR)
S    int len;
S    unsigned char nonce_counter[16];
S    unsigned char stream_block[16];
S#endif
S    mbedtls_aes_context ctx;
S
S    memset( key, 0, 32 );
S    mbedtls_aes_init( &ctx );
S
S    /*
S     * ECB mode
S     */
S    for( i = 0; i < 6; i++ )
S    {
S        u = i >> 1;
S        v = i  & 1;
S
S        if( verbose != 0 )
S            mbedtls_printf( "  AES-ECB-%3d (%s): ", 128 + u * 64,
S                             ( v == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
S
S        memset( buf, 0, 16 );
S
S        if( v == MBEDTLS_AES_DECRYPT )
S        {
S            mbedtls_aes_setkey_dec( &ctx, key, 128 + u * 64 );
S
S            for( j = 0; j < 10000; j++ )
S                mbedtls_aes_crypt_ecb( &ctx, v, buf, buf );
S
S            if( memcmp( buf, aes_test_ecb_dec[u], 16 ) != 0 )
S            {
S                if( verbose != 0 )
S                    mbedtls_printf( "failed\n" );
S
S                ret = 1;
S                goto exit;
S            }
S        }
S        else
S        {
S            mbedtls_aes_setkey_enc( &ctx, key, 128 + u * 64 );
S
S            for( j = 0; j < 10000; j++ )
S                mbedtls_aes_crypt_ecb( &ctx, v, buf, buf );
S
S            if( memcmp( buf, aes_test_ecb_enc[u], 16 ) != 0 )
S            {
S                if( verbose != 0 )
S                    mbedtls_printf( "failed\n" );
S
S                ret = 1;
S                goto exit;
S            }
S        }
S
S        if( verbose != 0 )
S            mbedtls_printf( "passed\n" );
S    }
S
S    if( verbose != 0 )
S        mbedtls_printf( "\n" );
S
S#if defined(MBEDTLS_CIPHER_MODE_CBC)
S    /*
S     * CBC mode
S     */
S    for( i = 0; i < 6; i++ )
S    {
S        u = i >> 1;
S        v = i  & 1;
S
S        if( verbose != 0 )
S            mbedtls_printf( "  AES-CBC-%3d (%s): ", 128 + u * 64,
S                             ( v == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
S
S        memset( iv , 0, 16 );
S        memset( prv, 0, 16 );
S        memset( buf, 0, 16 );
S
S        if( v == MBEDTLS_AES_DECRYPT )
S        {
S            mbedtls_aes_setkey_dec( &ctx, key, 128 + u * 64 );
S
S            for( j = 0; j < 10000; j++ )
S                mbedtls_aes_crypt_cbc( &ctx, v, 16, iv, buf, buf );
S
S            if( memcmp( buf, aes_test_cbc_dec[u], 16 ) != 0 )
S            {
S                if( verbose != 0 )
S                    mbedtls_printf( "failed\n" );
S
S                ret = 1;
S                goto exit;
S            }
S        }
S        else
S        {
S            mbedtls_aes_setkey_enc( &ctx, key, 128 + u * 64 );
S
S            for( j = 0; j < 10000; j++ )
S            {
S                unsigned char tmp[16];
S
S                mbedtls_aes_crypt_cbc( &ctx, v, 16, iv, buf, buf );
S
S                memcpy( tmp, prv, 16 );
S                memcpy( prv, buf, 16 );
S                memcpy( buf, tmp, 16 );
S            }
S
S            if( memcmp( prv, aes_test_cbc_enc[u], 16 ) != 0 )
S            {
S                if( verbose != 0 )
S                    mbedtls_printf( "failed\n" );
S
S                ret = 1;
S                goto exit;
S            }
S        }
S
S        if( verbose != 0 )
S            mbedtls_printf( "passed\n" );
S    }
S
S    if( verbose != 0 )
S        mbedtls_printf( "\n" );
S#endif /* MBEDTLS_CIPHER_MODE_CBC */
S
S#if defined(MBEDTLS_CIPHER_MODE_CFB)
S    /*
S     * CFB128 mode
S     */
S    for( i = 0; i < 6; i++ )
S    {
S        u = i >> 1;
S        v = i  & 1;
S
S        if( verbose != 0 )
S            mbedtls_printf( "  AES-CFB128-%3d (%s): ", 128 + u * 64,
S                             ( v == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
S
S        memcpy( iv,  aes_test_cfb128_iv, 16 );
S        memcpy( key, aes_test_cfb128_key[u], 16 + u * 8 );
S
S        offset = 0;
S        mbedtls_aes_setkey_enc( &ctx, key, 128 + u * 64 );
S
S        if( v == MBEDTLS_AES_DECRYPT )
S        {
S            memcpy( buf, aes_test_cfb128_ct[u], 64 );
S            mbedtls_aes_crypt_cfb128( &ctx, v, 64, &offset, iv, buf, buf );
S
S            if( memcmp( buf, aes_test_cfb128_pt, 64 ) != 0 )
S            {
S                if( verbose != 0 )
S                    mbedtls_printf( "failed\n" );
S
S                ret = 1;
S                goto exit;
S            }
S        }
S        else
S        {
S            memcpy( buf, aes_test_cfb128_pt, 64 );
S            mbedtls_aes_crypt_cfb128( &ctx, v, 64, &offset, iv, buf, buf );
S
S            if( memcmp( buf, aes_test_cfb128_ct[u], 64 ) != 0 )
S            {
S                if( verbose != 0 )
S                    mbedtls_printf( "failed\n" );
S
S                ret = 1;
S                goto exit;
S            }
S        }
S
S        if( verbose != 0 )
S            mbedtls_printf( "passed\n" );
S    }
S
S    if( verbose != 0 )
S        mbedtls_printf( "\n" );
S#endif /* MBEDTLS_CIPHER_MODE_CFB */
S
S#if defined(MBEDTLS_CIPHER_MODE_CTR)
S    /*
S     * CTR mode
S     */
S    for( i = 0; i < 6; i++ )
S    {
S        u = i >> 1;
S        v = i  & 1;
S
S        if( verbose != 0 )
S            mbedtls_printf( "  AES-CTR-128 (%s): ",
S                             ( v == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
S
S        memcpy( nonce_counter, aes_test_ctr_nonce_counter[u], 16 );
S        memcpy( key, aes_test_ctr_key[u], 16 );
S
S        offset = 0;
S        mbedtls_aes_setkey_enc( &ctx, key, 128 );
S
S        if( v == MBEDTLS_AES_DECRYPT )
S        {
S            len = aes_test_ctr_len[u];
S            memcpy( buf, aes_test_ctr_ct[u], len );
S
S            mbedtls_aes_crypt_ctr( &ctx, len, &offset, nonce_counter, stream_block,
S                           buf, buf );
S
S            if( memcmp( buf, aes_test_ctr_pt[u], len ) != 0 )
S            {
S                if( verbose != 0 )
S                    mbedtls_printf( "failed\n" );
S
S                ret = 1;
S                goto exit;
S            }
S        }
S        else
S        {
S            len = aes_test_ctr_len[u];
S            memcpy( buf, aes_test_ctr_pt[u], len );
S
S            mbedtls_aes_crypt_ctr( &ctx, len, &offset, nonce_counter, stream_block,
S                           buf, buf );
S
S            if( memcmp( buf, aes_test_ctr_ct[u], len ) != 0 )
S            {
S                if( verbose != 0 )
S                    mbedtls_printf( "failed\n" );
S
S                ret = 1;
S                goto exit;
S            }
S        }
S
S        if( verbose != 0 )
S            mbedtls_printf( "passed\n" );
S    }
S
S    if( verbose != 0 )
S        mbedtls_printf( "\n" );
S#endif /* MBEDTLS_CIPHER_MODE_CTR */
S
S    ret = 0;
S
Sexit:
S    mbedtls_aes_free( &ctx );
S
S    return( ret );
S}
S
S#endif /* MBEDTLS_SELF_TEST */
S
N#endif /* MBEDTLS_AES_C */
