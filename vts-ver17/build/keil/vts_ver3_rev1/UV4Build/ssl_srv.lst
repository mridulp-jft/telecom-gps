L 1 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\library\ssl_srv.c"
N/*
N *  SSLv3/TLSv1 server-side functions
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N#if !defined(MBEDTLS_CONFIG_FILE)
X#if !0L
N#include "mbedtls/config.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls/config.h" 1
N/**
N * \file config.h
N *
N * \brief Configuration options (set of defines)
N *
N *  This set of compile-time options may be used to enable
N *  or disable features selectively, and reduce the global
N *  memory footprint.
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N#ifdef _RTE_
N#include "mbedTLS_config.h"
L 1 ".\RTE\Security\mbedTLS_config.h" 1
N/*
N *  Configuration template
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N/*
N * This set of compile-time options may be used to enable
N * or disable features selectively, and reduce the global
N * memory footprint.
N */
N#ifndef MBEDTLS_CONFIG_H
N#define MBEDTLS_CONFIG_H
N
N/* System support */
N//#define MBEDTLS_HAVE_ASM
N//#define MBEDTLS_HAVE_TIME
N//#define MBEDTLS_HAVE_TIME_DATE
N//#define MBEDTLS_PLATFORM_MEMORY
N//#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
N
N/* mbed TLS feature support */
N//#define MBEDTLS_AES_ROM_TABLES
N//#define MBEDTLS_CAMELLIA_SMALL_MEMORY
N//#define MBEDTLS_CIPHER_MODE_CBC
N//#define MBEDTLS_CIPHER_MODE_CFB
N//#define MBEDTLS_CIPHER_MODE_CTR
N//#define MBEDTLS_CIPHER_PADDING_PKCS7
N//#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
N//#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
N//#define MBEDTLS_CIPHER_PADDING_ZEROS
N//#define MBEDTLS_REMOVE_ARC4_CIPHERSUITES
N//#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
N//#define MBEDTLS_ECP_DP_BP256R1_ENABLED
N//#define MBEDTLS_ECP_DP_BP384R1_ENABLED
N//#define MBEDTLS_ECP_DP_BP512R1_ENABLED
N//#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
N//#define MBEDTLS_ECP_NIST_OPTIM
N//#define MBEDTLS_ECDSA_DETERMINISTIC
N//#define MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
N//#define MBEDTLS_PK_PARSE_EC_EXTENDED
N//#define MBEDTLS_ERROR_STRERROR_DUMMY
N//#define MBEDTLS_GENPRIME
N//#define MBEDTLS_FS_IO
N//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
N//#define MBEDTLS_NO_PLATFORM_ENTROPY
N//#define MBEDTLS_ENTROPY_FORCE_SHA256
N//#define MBEDTLS_MEMORY_DEBUG
N//#define MBEDTLS_MEMORY_BACKTRACE
N//#define MBEDTLS_PK_RSA_ALT_SUPPORT
N//#define MBEDTLS_PKCS1_V15
N//#define MBEDTLS_PKCS1_V21
N//#define MBEDTLS_RSA_NO_CRT
N//#define MBEDTLS_SELF_TEST
N//#define MBEDTLS_SHA256_SMALLER
N//#define MBEDTLS_SSL_AEAD_RANDOM_IV
N//#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
N//#define MBEDTLS_SSL_DEBUG_ALL
N//#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
N//#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
N//#define MBEDTLS_SSL_FALLBACK_SCSV
N//#define MBEDTLS_SSL_HW_RECORD_ACCEL
N//#define MBEDTLS_SSL_CBC_RECORD_SPLITTING
N//#define MBEDTLS_SSL_RENEGOTIATION
N//#define MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
N//#define MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE
N//#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
N//#define MBEDTLS_SSL_PROTO_SSL3
N//#define MBEDTLS_SSL_PROTO_TLS1
N//#define MBEDTLS_SSL_PROTO_TLS1_1
N//#define MBEDTLS_SSL_PROTO_TLS1_2
N//#define MBEDTLS_SSL_PROTO_DTLS
N//#define MBEDTLS_SSL_ALPN
N//#define MBEDTLS_SSL_DTLS_ANTI_REPLAY
N//#define MBEDTLS_SSL_DTLS_HELLO_VERIFY
N//#define MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
N//#define MBEDTLS_SSL_DTLS_BADMAC_LIMIT
N//#define MBEDTLS_SSL_SESSION_TICKETS
N//#define MBEDTLS_SSL_EXPORT_KEYS
N//#define MBEDTLS_SSL_SERVER_NAME_INDICATION
N//#define MBEDTLS_SSL_TRUNCATED_HMAC
N//#define MBEDTLS_VERSION_FEATURES
N//#define MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3
N//#define MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
N//#define MBEDTLS_X509_CHECK_KEY_USAGE
N//#define MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
N//#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
N
N/* mbed TLS modules */
N//#define MBEDTLS_AES_C
N//#define MBEDTLS_ARC4_C
N//#define MBEDTLS_ASN1_PARSE_C
N//#define MBEDTLS_ASN1_WRITE_C
N//#define MBEDTLS_BASE64_C
N//#define MBEDTLS_BIGNUM_C
N//#define MBEDTLS_BLOWFISH_C
N//#define MBEDTLS_CAMELLIA_C
N//#define MBEDTLS_CCM_C
N//#define MBEDTLS_CERTS_C
N//#define MBEDTLS_CIPHER_C
N//#define MBEDTLS_CTR_DRBG_C
N//#define MBEDTLS_DEBUG_C
N//#define MBEDTLS_DES_C
N//#define MBEDTLS_DHM_C
N//#define MBEDTLS_ECDH_C
N//#define MBEDTLS_ECDSA_C
N//#define MBEDTLS_ECJPAKE_C
N//#define MBEDTLS_ECP_C
N//#define MBEDTLS_ENTROPY_C
N//#define MBEDTLS_ERROR_C
N//#define MBEDTLS_GCM_C
N//#define MBEDTLS_HAVEGE_C
N//#define MBEDTLS_HMAC_DRBG_C
N//#define MBEDTLS_MD_C
N//#define MBEDTLS_MD2_C
N//#define MBEDTLS_MD4_C
N//#define MBEDTLS_MD5_C
N//#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
N//#define MBEDTLS_NET_C
N//#define MBEDTLS_OID_C
N//#define MBEDTLS_PEM_PARSE_C
N//#define MBEDTLS_PEM_WRITE_C
N//#define MBEDTLS_PK_C
N//#define MBEDTLS_PK_PARSE_C
N//#define MBEDTLS_PK_WRITE_C
N//#define MBEDTLS_PKCS5_C
N//#define MBEDTLS_PKCS11_C
N//#define MBEDTLS_PKCS12_C
N//#define MBEDTLS_PLATFORM_C
N//#define MBEDTLS_RIPEMD160_C
N//#define MBEDTLS_RSA_C
N//#define MBEDTLS_SHA1_C
N//#define MBEDTLS_SHA256_C
N//#define MBEDTLS_SHA512_C
N//#define MBEDTLS_SSL_CACHE_C
N//#define MBEDTLS_SSL_COOKIE_C
N//#define MBEDTLS_SSL_TICKET_C
N//#define MBEDTLS_SSL_CLI_C
N//#define MBEDTLS_SSL_SRV_C
N//#define MBEDTLS_SSL_TLS_C
N//#define MBEDTLS_THREADING_C
N//#define MBEDTLS_TIMING_C
N//#define MBEDTLS_VERSION_C
N//#define MBEDTLS_X509_USE_C
N//#define MBEDTLS_X509_CRT_PARSE_C
N//#define MBEDTLS_X509_CRL_PARSE_C
N//#define MBEDTLS_X509_CSR_PARSE_C
N//#define MBEDTLS_X509_CREATE_C
N//#define MBEDTLS_X509_CRT_WRITE_C
N//#define MBEDTLS_X509_CSR_WRITE_C
N//#define MBEDTLS_XTEA_C
N
N#include "check_config.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls\check_config.h" 1
N/**
N * \file check_config.h
N *
N * \brief Consistency checks for configuration options
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N/*
N * It is recommended to include this file from your config.h
N * in order to catch dependency issues early.
N */
N
N#ifndef MBEDTLS_CHECK_CONFIG_H
N#define MBEDTLS_CHECK_CONFIG_H
N
N/*
N * We assume CHAR_BIT is 8 in many places. In practice, this is true on our
N * target platforms, so not an issue, but let's just be extra sure.
N */
N#include <limits.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5060002
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
S  #define CHAR_MIN (-128)
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 127
S      /* maximum value for an object of type char */
N#else
N  #define CHAR_MIN 0
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 255
N      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MIN  (~0x7fffffffffffffffL)
N#else
N  #define LONG_MIN  (~0x7fffffffL)
N#endif
N    /* minimum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MAX  0x7fffffffffffffffL
N#else
N  #define LONG_MAX  0x7fffffffL
N#endif
N    /* maximum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define ULONG_MAX 0xffffffffffffffffUL
N#else
N  #define ULONG_MAX 0xffffffffUL
N#endif
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 37 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls\check_config.h" 2
N#if CHAR_BIT != 8
X#if 8 != 8
S#error "mbed TLS requires a platform with 8-bit chars"
N#endif
N
N#if defined(_WIN32)
X#if 0L
S#if !defined(MBEDTLS_PLATFORM_C)
S#error "MBEDTLS_PLATFORM_C is required on Windows"
S#endif
S
S/* Fix the config here. Not convenient to put an #ifdef _WIN32 in config.h as
S * it would confuse config.pl. */
S#if !defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) && \
S    !defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO)
X#if !defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) &&     !defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO)
S#define MBEDTLS_PLATFORM_SNPRINTF_ALT
S#endif
N#endif /* _WIN32 */
N
N#if defined(TARGET_LIKE_MBED) && \
N    ( defined(MBEDTLS_NET_C) || defined(MBEDTLS_TIMING_C) )
X#if 0L &&     ( 0L || 0L )
S#error "The NET and TIMING modules are not available for mbed OS - please use the network and timing functions provided by mbed OS"
N#endif
N
N#if defined(MBEDTLS_DEPRECATED_WARNING) && \
N    !defined(__GNUC__) && !defined(__clang__)
X#if 0L &&     !0L && !0L
S#error "MBEDTLS_DEPRECATED_WARNING only works with GCC and Clang"
N#endif
N
N#if defined(MBEDTLS_HAVE_TIME_DATE) && !defined(MBEDTLS_HAVE_TIME)
X#if 0L && !0L
S#error "MBEDTLS_HAVE_TIME_DATE without MBEDTLS_HAVE_TIME does not make sense"
N#endif
N
N#if defined(MBEDTLS_AESNI_C) && !defined(MBEDTLS_HAVE_ASM)
X#if 0L && !0L
S#error "MBEDTLS_AESNI_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_CTR_DRBG_C) && !defined(MBEDTLS_AES_C)
X#if 0L && !0L
S#error "MBEDTLS_CTR_DRBG_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_DHM_C) && !defined(MBEDTLS_BIGNUM_C)
X#if 0L && !0L
S#error "MBEDTLS_DHM_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECDH_C) && !defined(MBEDTLS_ECP_C)
X#if 0L && !0L
S#error "MBEDTLS_ECDH_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECDSA_C) &&            \
N    ( !defined(MBEDTLS_ECP_C) ||           \
N      !defined(MBEDTLS_ASN1_PARSE_C) ||    \
N      !defined(MBEDTLS_ASN1_WRITE_C) )
X#if 0L &&                ( !0L ||                 !0L ||          !0L )
S#error "MBEDTLS_ECDSA_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECJPAKE_C) &&           \
N    ( !defined(MBEDTLS_ECP_C) || !defined(MBEDTLS_MD_C) )
X#if 0L &&               ( !0L || !0L )
S#error "MBEDTLS_ECJPAKE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECDSA_DETERMINISTIC) && !defined(MBEDTLS_HMAC_DRBG_C)
X#if 0L && !0L
S#error "MBEDTLS_ECDSA_DETERMINISTIC defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECP_C) && ( !defined(MBEDTLS_BIGNUM_C) || (   \
N    !defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)   &&                  \
N    !defined(MBEDTLS_ECP_DP_BP384R1_ENABLED)   &&                  \
N    !defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)   &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED) ) )
X#if 0L && ( !0L || (       !0L &&                      !0L &&                      !0L &&                      !0L &&                      !0L &&                      !0L   &&                      !0L   &&                      !0L   &&                      !0L &&                      !0L &&                      !0L ) )
S#error "MBEDTLS_ECP_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ENTROPY_C) && (!defined(MBEDTLS_SHA512_C) &&      \
N                                    !defined(MBEDTLS_SHA256_C))
X#if 0L && (!0L &&                                          !0L)
S#error "MBEDTLS_ENTROPY_C defined, but not all prerequisites"
N#endif
N#if defined(MBEDTLS_ENTROPY_C) && defined(MBEDTLS_SHA512_C) &&         \
N    defined(MBEDTLS_CTR_DRBG_ENTROPY_LEN) && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 64)
X#if 0L && 0L &&             0L && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 64)
S#error "MBEDTLS_CTR_DRBG_ENTROPY_LEN value too high"
N#endif
N#if defined(MBEDTLS_ENTROPY_C) &&                                            \
N    ( !defined(MBEDTLS_SHA512_C) || defined(MBEDTLS_ENTROPY_FORCE_SHA256) ) \
N    && defined(MBEDTLS_CTR_DRBG_ENTROPY_LEN) && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 32)
X#if 0L &&                                                ( !0L || 0L )     && 0L && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 32)
S#error "MBEDTLS_CTR_DRBG_ENTROPY_LEN value too high"
N#endif
N#if defined(MBEDTLS_ENTROPY_C) && \
N    defined(MBEDTLS_ENTROPY_FORCE_SHA256) && !defined(MBEDTLS_SHA256_C)
X#if 0L &&     0L && !0L
S#error "MBEDTLS_ENTROPY_FORCE_SHA256 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_GCM_C) && (                                        \
N        !defined(MBEDTLS_AES_C) && !defined(MBEDTLS_CAMELLIA_C) )
X#if 0L && (                                                !0L && !0L )
S#error "MBEDTLS_GCM_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_HAVEGE_C) && !defined(MBEDTLS_TIMING_C)
X#if 0L && !0L
S#error "MBEDTLS_HAVEGE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_HMAC_DRBG_C) && !defined(MBEDTLS_MD_C)
X#if 0L && !0L
S#error "MBEDTLS_HMAC_DRBG_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) )
X#if 0L &&                     ( !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) )
X#if 0L &&                     ( !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED) && !defined(MBEDTLS_DHM_C)
X#if 0L && !0L
S#error "MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) &&                     \
N    !defined(MBEDTLS_ECDH_C)
X#if 0L &&                         !0L
S#error "MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) &&                   \
N    ( !defined(MBEDTLS_DHM_C) || !defined(MBEDTLS_RSA_C) ||           \
N      !defined(MBEDTLS_X509_CRT_PARSE_C) || !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                       ( !0L || !0L ||                 !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_RSA_C) ||          \
N      !defined(MBEDTLS_X509_CRT_PARSE_C) || !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                     ( !0L || !0L ||                !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_ECDSA_C) ||          \
N      !defined(MBEDTLS_X509_CRT_PARSE_C) )
X#if 0L &&                     ( !0L || !0L ||                !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED) &&                   \
N    ( !defined(MBEDTLS_RSA_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) || \
N      !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                       ( !0L || !0L ||       !0L )
S#error "MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) &&                       \
N    ( !defined(MBEDTLS_RSA_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) || \
N      !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                           ( !0L || !0L ||       !0L )
S#error "MBEDTLS_KEY_EXCHANGE_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED) &&                    \
N    ( !defined(MBEDTLS_ECJPAKE_C) || !defined(MBEDTLS_SHA256_C) ||      \
N      !defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) )
X#if 0L &&                        ( !0L || !0L ||            !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_MEMORY_BUFFER_ALLOC_C) &&                          \
N    ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
X#if 0L &&                              ( !0L || !0L )
S#error "MBEDTLS_MEMORY_BUFFER_ALLOC_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PADLOCK_C) && !defined(MBEDTLS_HAVE_ASM)
X#if 0L && !0L
S#error "MBEDTLS_PADLOCK_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PEM_PARSE_C) && !defined(MBEDTLS_BASE64_C)
X#if 0L && !0L
S#error "MBEDTLS_PEM_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PEM_WRITE_C) && !defined(MBEDTLS_BASE64_C)
X#if 0L && !0L
S#error "MBEDTLS_PEM_WRITE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PK_C) && \
N    ( !defined(MBEDTLS_RSA_C) && !defined(MBEDTLS_ECP_C) )
X#if 0L &&     ( !0L && !0L )
S#error "MBEDTLS_PK_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PK_PARSE_C) && !defined(MBEDTLS_PK_C)
X#if 0L && !0L
S#error "MBEDTLS_PK_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PK_WRITE_C) && !defined(MBEDTLS_PK_C)
X#if 0L && !0L
S#error "MBEDTLS_PK_WRITE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PKCS11_C) && !defined(MBEDTLS_PK_C)
X#if 0L && !0L
S#error "MBEDTLS_PKCS11_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_EXIT_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_EXIT_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_EXIT_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_EXIT_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_EXIT_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_EXIT) ||\
N        defined(MBEDTLS_PLATFORM_EXIT_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_EXIT_MACRO and MBEDTLS_PLATFORM_STD_EXIT/MBEDTLS_PLATFORM_EXIT_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FPRINTF_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_FPRINTF_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FPRINTF_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_FPRINTF_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FPRINTF_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_FPRINTF) ||\
N        defined(MBEDTLS_PLATFORM_FPRINTF_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_FPRINTF_MACRO and MBEDTLS_PLATFORM_STD_FPRINTF/MBEDTLS_PLATFORM_FPRINTF_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FREE_MACRO) &&\
N    ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
X#if 0L &&    ( !0L || !0L )
S#error "MBEDTLS_PLATFORM_FREE_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FREE_MACRO) &&\
N    defined(MBEDTLS_PLATFORM_STD_FREE)
X#if 0L &&    0L
S#error "MBEDTLS_PLATFORM_FREE_MACRO and MBEDTLS_PLATFORM_STD_FREE cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FREE_MACRO) && !defined(MBEDTLS_PLATFORM_CALLOC_MACRO)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_CALLOC_MACRO must be defined if MBEDTLS_PLATFORM_FREE_MACRO is"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_CALLOC_MACRO) &&\
N    ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
X#if 0L &&    ( !0L || !0L )
S#error "MBEDTLS_PLATFORM_CALLOC_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_CALLOC_MACRO) &&\
N    defined(MBEDTLS_PLATFORM_STD_CALLOC)
X#if 0L &&    0L
S#error "MBEDTLS_PLATFORM_CALLOC_MACRO and MBEDTLS_PLATFORM_STD_CALLOC cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_CALLOC_MACRO) && !defined(MBEDTLS_PLATFORM_FREE_MACRO)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_FREE_MACRO must be defined if MBEDTLS_PLATFORM_CALLOC_MACRO is"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_MEMORY) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_MEMORY defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_PRINTF_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_PRINTF_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_PRINTF_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_PRINTF_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_PRINTF_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_PRINTF) ||\
N        defined(MBEDTLS_PLATFORM_PRINTF_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_PRINTF_MACRO and MBEDTLS_PLATFORM_STD_PRINTF/MBEDTLS_PLATFORM_PRINTF_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_SNPRINTF_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_SNPRINTF_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_SNPRINTF) ||\
N        defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_SNPRINTF_MACRO and MBEDTLS_PLATFORM_STD_SNPRINTF/MBEDTLS_PLATFORM_SNPRINTF_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_MEM_HDR) &&\
N    !defined(MBEDTLS_PLATFORM_NO_STD_FUNCTIONS)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_MEM_HDR defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_CALLOC) && !defined(MBEDTLS_PLATFORM_MEMORY)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_STD_CALLOC defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_CALLOC) && !defined(MBEDTLS_PLATFORM_MEMORY)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_STD_CALLOC defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_FREE) && !defined(MBEDTLS_PLATFORM_MEMORY)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_STD_FREE defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_EXIT) &&\
N    !defined(MBEDTLS_PLATFORM_EXIT_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_EXIT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_FPRINTF) &&\
N    !defined(MBEDTLS_PLATFORM_FPRINTF_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_FPRINTF defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_PRINTF) &&\
N    !defined(MBEDTLS_PLATFORM_PRINTF_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_PRINTF defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_SNPRINTF) &&\
N    !defined(MBEDTLS_PLATFORM_SNPRINTF_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_SNPRINTF defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_RSA_C) && ( !defined(MBEDTLS_BIGNUM_C) ||         \
N    !defined(MBEDTLS_OID_C) )
X#if 0L && ( !0L ||             !0L )
S#error "MBEDTLS_RSA_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT) &&                        \
N    ( !defined(MBEDTLS_RSA_C) || !defined(MBEDTLS_PKCS1_V21) )
X#if 0L &&                            ( !0L || !0L )
S#error "MBEDTLS_X509_RSASSA_PSS_SUPPORT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_SSL3) && ( !defined(MBEDTLS_MD5_C) ||     \
N    !defined(MBEDTLS_SHA1_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_PROTO_SSL3 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_TLS1) && ( !defined(MBEDTLS_MD5_C) ||     \
N    !defined(MBEDTLS_SHA1_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_PROTO_TLS1 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_TLS1_1) && ( !defined(MBEDTLS_MD5_C) ||     \
N    !defined(MBEDTLS_SHA1_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_PROTO_TLS1_1 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && ( !defined(MBEDTLS_SHA1_C) &&     \
N    !defined(MBEDTLS_SHA256_C) && !defined(MBEDTLS_SHA512_C) )
X#if 0L && ( !0L &&         !0L && !0L )
S#error "MBEDTLS_SSL_PROTO_TLS1_2 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_DTLS)     && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1)  && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if 0L     &&     !0L  &&     !0L
S#error "MBEDTLS_SSL_PROTO_DTLS defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_CLI_C) && !defined(MBEDTLS_SSL_TLS_C)
X#if 0L && !0L
S#error "MBEDTLS_SSL_CLI_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && ( !defined(MBEDTLS_CIPHER_C) ||     \
N    !defined(MBEDTLS_MD_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_TLS_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_SRV_C) && !defined(MBEDTLS_SSL_TLS_C)
X#if 0L && !0L
S#error "MBEDTLS_SSL_SRV_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (!defined(MBEDTLS_SSL_PROTO_SSL3) && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1) && !defined(MBEDTLS_SSL_PROTO_TLS1_1) && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2))
X#if 0L && (!0L &&     !0L && !0L &&     !0L)
S#error "MBEDTLS_SSL_TLS_C defined, but no protocols are active"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (defined(MBEDTLS_SSL_PROTO_SSL3) && \
N    defined(MBEDTLS_SSL_PROTO_TLS1_1) && !defined(MBEDTLS_SSL_PROTO_TLS1))
X#if 0L && (0L &&     0L && !0L)
S#error "Illegal protocol selection"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (defined(MBEDTLS_SSL_PROTO_TLS1) && \
N    defined(MBEDTLS_SSL_PROTO_TLS1_2) && !defined(MBEDTLS_SSL_PROTO_TLS1_1))
X#if 0L && (0L &&     0L && !0L)
S#error "Illegal protocol selection"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (defined(MBEDTLS_SSL_PROTO_SSL3) && \
N    defined(MBEDTLS_SSL_PROTO_TLS1_2) && (!defined(MBEDTLS_SSL_PROTO_TLS1) || \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1)))
X#if 0L && (0L &&     0L && (!0L ||     !0L))
S#error "Illegal protocol selection"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && !defined(MBEDTLS_SSL_PROTO_DTLS)
X#if 0L && !0L
S#error "MBEDTLS_SSL_DTLS_HELLO_VERIFY  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && \
N    !defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
X#if 0L &&     !0L
S#error "MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY) &&                              \
N    ( !defined(MBEDTLS_SSL_TLS_C) || !defined(MBEDTLS_SSL_PROTO_DTLS) )
X#if 0L &&                                  ( !0L || !0L )
S#error "MBEDTLS_SSL_DTLS_ANTI_REPLAY  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT) &&                              \
N    ( !defined(MBEDTLS_SSL_TLS_C) || !defined(MBEDTLS_SSL_PROTO_DTLS) )
X#if 0L &&                                  ( !0L || !0L )
S#error "MBEDTLS_SSL_DTLS_BADMAC_LIMIT  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC) &&   \
N    !defined(MBEDTLS_SSL_PROTO_TLS1)   &&      \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1) &&      \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if 0L &&       !0L   &&          !0L &&          !0L
S#error "MBEDTLS_SSL_ENCRYPT_THEN_MAC defined, but not all prerequsites"
N#endif
N
N#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET) && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1)   &&          \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1) &&          \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if 0L &&     !0L   &&              !0L &&              !0L
S#error "MBEDTLS_SSL_EXTENDED_MASTER_SECRET defined, but not all prerequsites"
N#endif
N
N#if defined(MBEDTLS_SSL_TICKET_C) && !defined(MBEDTLS_CIPHER_C)
X#if 0L && !0L
S#error "MBEDTLS_SSL_TICKET_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING) && \
N    !defined(MBEDTLS_SSL_PROTO_SSL3) && !defined(MBEDTLS_SSL_PROTO_TLS1)
X#if 0L &&     !0L && !0L
S#error "MBEDTLS_SSL_CBC_RECORD_SPLITTING defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION) && \
N        !defined(MBEDTLS_X509_CRT_PARSE_C)
X#if 0L &&         !0L
S#error "MBEDTLS_SSL_SERVER_NAME_INDICATION defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_THREADING_PTHREAD)
X#if 0L
S#if !defined(MBEDTLS_THREADING_C) || defined(MBEDTLS_THREADING_IMPL)
S#error "MBEDTLS_THREADING_PTHREAD defined, but not all prerequisites"
S#endif
S#define MBEDTLS_THREADING_IMPL
N#endif
N
N#if defined(MBEDTLS_THREADING_ALT)
X#if 0L
S#if !defined(MBEDTLS_THREADING_C) || defined(MBEDTLS_THREADING_IMPL)
S#error "MBEDTLS_THREADING_ALT defined, but not all prerequisites"
S#endif
S#define MBEDTLS_THREADING_IMPL
N#endif
N
N#if defined(MBEDTLS_THREADING_C) && !defined(MBEDTLS_THREADING_IMPL)
X#if 0L && !0L
S#error "MBEDTLS_THREADING_C defined, single threading implementation required"
N#endif
N#undef MBEDTLS_THREADING_IMPL
N
N#if defined(MBEDTLS_VERSION_FEATURES) && !defined(MBEDTLS_VERSION_C)
X#if 0L && !0L
S#error "MBEDTLS_VERSION_FEATURES defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_USE_C) && ( !defined(MBEDTLS_BIGNUM_C) ||  \
N    !defined(MBEDTLS_OID_C) || !defined(MBEDTLS_ASN1_PARSE_C) ||      \
N    !defined(MBEDTLS_PK_PARSE_C) )
X#if 0L && ( !0L ||      !0L || !0L ||          !0L )
S#error "MBEDTLS_X509_USE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CREATE_C) && ( !defined(MBEDTLS_BIGNUM_C) ||  \
N    !defined(MBEDTLS_OID_C) || !defined(MBEDTLS_ASN1_WRITE_C) ||       \
N    !defined(MBEDTLS_PK_WRITE_C) )
X#if 0L && ( !0L ||      !0L || !0L ||           !0L )
S#error "MBEDTLS_X509_CREATE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CRT_PARSE_C) && ( !defined(MBEDTLS_X509_USE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CRT_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CRL_PARSE_C) && ( !defined(MBEDTLS_X509_USE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CRL_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CSR_PARSE_C) && ( !defined(MBEDTLS_X509_USE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CSR_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CRT_WRITE_C) && ( !defined(MBEDTLS_X509_CREATE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CRT_WRITE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CSR_WRITE_C) && ( !defined(MBEDTLS_X509_CREATE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CSR_WRITE_C defined, but not all prerequisites"
N#endif
N
N/*
N * Avoid warning from -pedantic. This is a convenient place for this
N * workaround since this is included by every single file before the
N * #if defined(MBEDTLS_xxx_C) that results in emtpy translation units.
N */
Ntypedef int mbedtls_iso_c_forbids_empty_translation_units;
N
N#endif /* MBEDTLS_CHECK_CONFIG_H */
L 186 ".\RTE\Security\mbedTLS_config.h" 2
N
N#endif /* MBEDTLS_CONFIG_H */
L 30 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls/config.h" 2
N#endif
N
N#ifndef MBEDTLS_CONFIG_H
S#define MBEDTLS_CONFIG_H
S
S#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
S#define _CRT_SECURE_NO_DEPRECATE 1
S#endif
S
S/**
S * \name SECTION: System support
S *
S * This section sets system specific settings.
S * \{
S */
S
S/**
S * \def MBEDTLS_HAVE_ASM
S *
S * The compiler has support for asm().
S *
S * Requires support for asm() in compiler.
S *
S * Used in:
S *      library/timing.c
S *      library/padlock.c
S *      include/mbedtls/bn_mul.h
S *
S * Comment to disable the use of assembly code.
S */
S#define MBEDTLS_HAVE_ASM
S
S/**
S * \def MBEDTLS_HAVE_SSE2
S *
S * CPU supports SSE2 instruction set.
S *
S * Uncomment if the CPU supports SSE2 (IA-32 specific).
S */
S//#define MBEDTLS_HAVE_SSE2
S
S/**
S * \def MBEDTLS_HAVE_TIME
S *
S * System has time.h and time().
S * The time does not need to be correct, only time differences are used,
S * by contrast with MBEDTLS_HAVE_TIME_DATE
S *
S * Comment if your system does not support time functions
S */
S#define MBEDTLS_HAVE_TIME
S
S/**
S * \def MBEDTLS_HAVE_TIME_DATE
S *
S * System has time.h and time(), gmtime() and the clock is correct.
S * The time needs to be correct (not necesarily very accurate, but at least
S * the date should be correct). This is used to verify the validity period of
S * X.509 certificates.
S *
S * Comment if your system does not have a correct clock.
S */
S#define MBEDTLS_HAVE_TIME_DATE
S
S/**
S * \def MBEDTLS_PLATFORM_MEMORY
S *
S * Enable the memory allocation layer.
S *
S * By default mbed TLS uses the system-provided calloc() and free().
S * This allows different allocators (self-implemented or provided) to be
S * provided to the platform abstraction layer.
S *
S * Enabling MBEDTLS_PLATFORM_MEMORY without the
S * MBEDTLS_PLATFORM_{FREE,CALLOC}_MACROs will provide
S * "mbedtls_platform_set_calloc_free()" allowing you to set an alternative calloc() and
S * free() function pointer at runtime.
S *
S * Enabling MBEDTLS_PLATFORM_MEMORY and specifying
S * MBEDTLS_PLATFORM_{CALLOC,FREE}_MACROs will allow you to specify the
S * alternate function at compile time.
S *
S * Requires: MBEDTLS_PLATFORM_C
S *
S * Enable this layer to allow use of alternative memory allocators.
S */
S//#define MBEDTLS_PLATFORM_MEMORY
S
S/**
S * \def MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
S *
S * Do not assign standard functions in the platform layer (e.g. calloc() to
S * MBEDTLS_PLATFORM_STD_CALLOC and printf() to MBEDTLS_PLATFORM_STD_PRINTF)
S *
S * This makes sure there are no linking errors on platforms that do not support
S * these functions. You will HAVE to provide alternatives, either at runtime
S * via the platform_set_xxx() functions or at compile time by setting
S * the MBEDTLS_PLATFORM_STD_XXX defines, or enabling a
S * MBEDTLS_PLATFORM_XXX_MACRO.
S *
S * Requires: MBEDTLS_PLATFORM_C
S *
S * Uncomment to prevent default assignment of standard functions in the
S * platform layer.
S */
S//#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
S
S/**
S * \def MBEDTLS_PLATFORM_EXIT_ALT
S *
S * MBEDTLS_PLATFORM_XXX_ALT: Uncomment a macro to let mbed TLS support the
S * function in the platform abstraction layer.
S *
S * Example: In case you uncomment MBEDTLS_PLATFORM_PRINTF_ALT, mbed TLS will
S * provide a function "mbedtls_platform_set_printf()" that allows you to set an
S * alternative printf function pointer.
S *
S * All these define require MBEDTLS_PLATFORM_C to be defined!
S *
S * \note MBEDTLS_PLATFORM_SNPRINTF_ALT is required on Windows;
S * it will be enabled automatically by check_config.h
S *
S * \warning MBEDTLS_PLATFORM_XXX_ALT cannot be defined at the same time as
S * MBEDTLS_PLATFORM_XXX_MACRO!
S *
S * Uncomment a macro to enable alternate implementation of specific base
S * platform function
S */
S//#define MBEDTLS_PLATFORM_EXIT_ALT
S//#define MBEDTLS_PLATFORM_FPRINTF_ALT
S//#define MBEDTLS_PLATFORM_PRINTF_ALT
S//#define MBEDTLS_PLATFORM_SNPRINTF_ALT
S
S/**
S * \def MBEDTLS_DEPRECATED_WARNING
S *
S * Mark deprecated functions so that they generate a warning if used.
S * Functions deprecated in one version will usually be removed in the next
S * version. You can enable this to help you prepare the transition to a new
S * major version by making sure your code is not using these functions.
S *
S * This only works with GCC and Clang. With other compilers, you may want to
S * use MBEDTLS_DEPRECATED_REMOVED
S *
S * Uncomment to get warnings on using deprecated functions.
S */
S//#define MBEDTLS_DEPRECATED_WARNING
S
S/**
S * \def MBEDTLS_DEPRECATED_REMOVED
S *
S * Remove deprecated functions so that they generate an error if used.
S * Functions deprecated in one version will usually be removed in the next
S * version. You can enable this to help you prepare the transition to a new
S * major version by making sure your code is not using these functions.
S *
S * Uncomment to get errors on using deprecated functions.
S */
S//#define MBEDTLS_DEPRECATED_REMOVED
S
S/* \} name SECTION: System support */
S
S/**
S * \name SECTION: mbed TLS feature support
S *
S * This section sets support for features that are or are not needed
S * within the modules that are enabled.
S * \{
S */
S
S/**
S * \def MBEDTLS_TIMING_ALT
S *
S * Uncomment to provide your own alternate implementation for mbedtls_timing_hardclock(),
S * mbedtls_timing_get_timer(), mbedtls_set_alarm(), mbedtls_set/get_delay()
S *
S * Only works if you have MBEDTLS_TIMING_C enabled.
S *
S * You will need to provide a header "timing_alt.h" and an implementation at
S * compile time.
S */
S//#define MBEDTLS_TIMING_ALT
S
S/**
S * \def MBEDTLS_AES_ALT
S *
S * MBEDTLS__MODULE_NAME__ALT: Uncomment a macro to let mbed TLS use your
S * alternate core implementation of a symmetric crypto or hash module (e.g.
S * platform specific assembly optimized implementations). Keep in mind that
S * the function prototypes should remain the same.
S *
S * This replaces the whole module. If you only want to replace one of the
S * functions, use one of the MBEDTLS__FUNCTION_NAME__ALT flags.
S *
S * Example: In case you uncomment MBEDTLS_AES_ALT, mbed TLS will no longer
S * provide the "struct mbedtls_aes_context" definition and omit the base function
S * declarations and implementations. "aes_alt.h" will be included from
S * "aes.h" to include the new function definitions.
S *
S * Uncomment a macro to enable alternate implementation of the corresponding
S * module.
S */
S//#define MBEDTLS_AES_ALT
S//#define MBEDTLS_ARC4_ALT
S//#define MBEDTLS_BLOWFISH_ALT
S//#define MBEDTLS_CAMELLIA_ALT
S//#define MBEDTLS_DES_ALT
S//#define MBEDTLS_XTEA_ALT
S//#define MBEDTLS_MD2_ALT
S//#define MBEDTLS_MD4_ALT
S//#define MBEDTLS_MD5_ALT
S//#define MBEDTLS_RIPEMD160_ALT
S//#define MBEDTLS_SHA1_ALT
S//#define MBEDTLS_SHA256_ALT
S//#define MBEDTLS_SHA512_ALT
S
S/**
S * \def MBEDTLS_MD2_PROCESS_ALT
S *
S * MBEDTLS__FUNCTION_NAME__ALT: Uncomment a macro to let mbed TLS use you
S * alternate core implementation of symmetric crypto or hash function. Keep in
S * mind that function prototypes should remain the same.
S *
S * This replaces only one function. The header file from mbed TLS is still
S * used, in contrast to the MBEDTLS__MODULE_NAME__ALT flags.
S *
S * Example: In case you uncomment MBEDTLS_SHA256_PROCESS_ALT, mbed TLS will
S * no longer provide the mbedtls_sha1_process() function, but it will still provide
S * the other function (using your mbedtls_sha1_process() function) and the definition
S * of mbedtls_sha1_context, so your implementation of mbedtls_sha1_process must be compatible
S * with this definition.
S *
S * Note: if you use the AES_xxx_ALT macros, then is is recommended to also set
S * MBEDTLS_AES_ROM_TABLES in order to help the linker garbage-collect the AES
S * tables.
S *
S * Uncomment a macro to enable alternate implementation of the corresponding
S * function.
S */
S//#define MBEDTLS_MD2_PROCESS_ALT
S//#define MBEDTLS_MD4_PROCESS_ALT
S//#define MBEDTLS_MD5_PROCESS_ALT
S//#define MBEDTLS_RIPEMD160_PROCESS_ALT
S//#define MBEDTLS_SHA1_PROCESS_ALT
S//#define MBEDTLS_SHA256_PROCESS_ALT
S//#define MBEDTLS_SHA512_PROCESS_ALT
S//#define MBEDTLS_DES_SETKEY_ALT
S//#define MBEDTLS_DES_CRYPT_ECB_ALT
S//#define MBEDTLS_DES3_CRYPT_ECB_ALT
S//#define MBEDTLS_AES_SETKEY_ENC_ALT
S//#define MBEDTLS_AES_SETKEY_DEC_ALT
S//#define MBEDTLS_AES_ENCRYPT_ALT
S//#define MBEDTLS_AES_DECRYPT_ALT
S
S/**
S * \def MBEDTLS_ENTROPY_HARDWARE_ALT
S *
S * Uncomment this macro to let mbed TLS use your own implementation of a
S * hardware entropy collector.
S *
S * Your function must be called \c mbedtls_hardware_poll(), have the same
S * prototype as declared in entropy_poll.h, and accept NULL as first argument.
S *
S * Uncomment to use your own hardware entropy collector.
S */
S//#define MBEDTLS_ENTROPY_HARDWARE_ALT
S
S/**
S * \def MBEDTLS_AES_ROM_TABLES
S *
S * Store the AES tables in ROM.
S *
S * Uncomment this macro to store the AES tables in ROM.
S */
S//#define MBEDTLS_AES_ROM_TABLES
S
S/**
S * \def MBEDTLS_CAMELLIA_SMALL_MEMORY
S *
S * Use less ROM for the Camellia implementation (saves about 768 bytes).
S *
S * Uncomment this macro to use less memory for Camellia.
S */
S//#define MBEDTLS_CAMELLIA_SMALL_MEMORY
S
S/**
S * \def MBEDTLS_CIPHER_MODE_CBC
S *
S * Enable Cipher Block Chaining mode (CBC) for symmetric ciphers.
S */
S#define MBEDTLS_CIPHER_MODE_CBC
S
S/**
S * \def MBEDTLS_CIPHER_MODE_CFB
S *
S * Enable Cipher Feedback mode (CFB) for symmetric ciphers.
S */
S#define MBEDTLS_CIPHER_MODE_CFB
S
S/**
S * \def MBEDTLS_CIPHER_MODE_CTR
S *
S * Enable Counter Block Cipher mode (CTR) for symmetric ciphers.
S */
S#define MBEDTLS_CIPHER_MODE_CTR
S
S/**
S * \def MBEDTLS_CIPHER_NULL_CIPHER
S *
S * Enable NULL cipher.
S * Warning: Only do so when you know what you are doing. This allows for
S * encryption or channels without any security!
S *
S * Requires MBEDTLS_ENABLE_WEAK_CIPHERSUITES as well to enable
S * the following ciphersuites:
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA
S *      MBEDTLS_TLS_RSA_WITH_NULL_SHA256
S *      MBEDTLS_TLS_RSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_RSA_WITH_NULL_MD5
S *      MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA
S *      MBEDTLS_TLS_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_PSK_WITH_NULL_SHA
S *
S * Uncomment this macro to enable the NULL cipher and ciphersuites
S */
S//#define MBEDTLS_CIPHER_NULL_CIPHER
S
S/**
S * \def MBEDTLS_CIPHER_PADDING_PKCS7
S *
S * MBEDTLS_CIPHER_PADDING_XXX: Uncomment or comment macros to add support for
S * specific padding modes in the cipher layer with cipher modes that support
S * padding (e.g. CBC)
S *
S * If you disable all padding modes, only full blocks can be used with CBC.
S *
S * Enable padding modes in the cipher layer.
S */
S#define MBEDTLS_CIPHER_PADDING_PKCS7
S#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
S#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
S#define MBEDTLS_CIPHER_PADDING_ZEROS
S
S/**
S * \def MBEDTLS_ENABLE_WEAK_CIPHERSUITES
S *
S * Enable weak ciphersuites in SSL / TLS.
S * Warning: Only do so when you know what you are doing. This allows for
S * channels with virtually no security at all!
S *
S * This enables the following ciphersuites:
S *      MBEDTLS_TLS_RSA_WITH_DES_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_DES_CBC_SHA
S *
S * Uncomment this macro to enable weak ciphersuites
S */
S//#define MBEDTLS_ENABLE_WEAK_CIPHERSUITES
S
S/**
S * \def MBEDTLS_REMOVE_ARC4_CIPHERSUITES
S *
S * Remove RC4 ciphersuites by default in SSL / TLS.
S * This flag removes the ciphersuites based on RC4 from the default list as
S * returned by mbedtls_ssl_list_ciphersuites(). However, it is still possible to
S * enable (some of) them with mbedtls_ssl_conf_ciphersuites() by including them
S * explicitly.
S *
S * Uncomment this macro to remove RC4 ciphersuites by default.
S */
S#define MBEDTLS_REMOVE_ARC4_CIPHERSUITES
S
S/**
S * \def MBEDTLS_ECP_DP_SECP192R1_ENABLED
S *
S * MBEDTLS_ECP_XXXX_ENABLED: Enables specific curves within the Elliptic Curve
S * module.  By default all supported curves are enabled.
S *
S * Comment macros to disable the curve and functions for it
S */
S#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
S#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
S#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
S#define MBEDTLS_ECP_DP_BP256R1_ENABLED
S#define MBEDTLS_ECP_DP_BP384R1_ENABLED
S#define MBEDTLS_ECP_DP_BP512R1_ENABLED
S#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
S
S/**
S * \def MBEDTLS_ECP_NIST_OPTIM
S *
S * Enable specific 'modulo p' routines for each NIST prime.
S * Depending on the prime and architecture, makes operations 4 to 8 times
S * faster on the corresponding curve.
S *
S * Comment this macro to disable NIST curves optimisation.
S */
S#define MBEDTLS_ECP_NIST_OPTIM
S
S/**
S * \def MBEDTLS_ECDSA_DETERMINISTIC
S *
S * Enable deterministic ECDSA (RFC 6979).
S * Standard ECDSA is "fragile" in the sense that lack of entropy when signing
S * may result in a compromise of the long-term signing key. This is avoided by
S * the deterministic variant.
S *
S * Requires: MBEDTLS_HMAC_DRBG_C
S *
S * Comment this macro to disable deterministic ECDSA.
S */
S#define MBEDTLS_ECDSA_DETERMINISTIC
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
S *
S * Enable the PSK based ciphersuite modes in SSL / TLS.
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
S *
S * Enable the DHE-PSK based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_DHM_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
S *
S * Enable the ECDHE-PSK based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
S *
S * Enable the RSA-PSK based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
S *
S * Enable the RSA-only based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_MD5
S */
S#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
S *
S * Enable the DHE-RSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_DHM_C, MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
S *
S * Enable the ECDHE-RSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
S *
S * Enable the ECDHE-ECDSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_ECDSA_C, MBEDTLS_X509_CRT_PARSE_C,
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
S *
S * Enable the ECDH-ECDSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
S *
S * Enable the ECDH-RSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
S *
S * Enable the ECJPAKE based ciphersuite modes in SSL / TLS.
S *
S * \warning This is currently experimental. EC J-PAKE support is based on the
S * Thread v1.0.0 specification; incompatible changes to the specification
S * might still happen. For this reason, this is disabled by default.
S *
S * Requires: MBEDTLS_ECJPAKE_C
S *           MBEDTLS_SHA256_C
S *           MBEDTLS_ECP_DP_SECP256R1_ENABLED
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECJPAKE_WITH_AES_128_CCM_8
S */
S//#define MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
S
S/**
S * \def MBEDTLS_PK_PARSE_EC_EXTENDED
S *
S * Enhance support for reading EC keys using variants of SEC1 not allowed by
S * RFC 5915 and RFC 5480.
S *
S * Currently this means parsing the SpecifiedECDomain choice of EC
S * parameters (only known groups are supported, not arbitrary domains, to
S * avoid validation issues).
S *
S * Disable if you only need to support RFC 5915 + 5480 key formats.
S */
S#define MBEDTLS_PK_PARSE_EC_EXTENDED
S
S/**
S * \def MBEDTLS_ERROR_STRERROR_DUMMY
S *
S * Enable a dummy error function to make use of mbedtls_strerror() in
S * third party libraries easier when MBEDTLS_ERROR_C is disabled
S * (no effect when MBEDTLS_ERROR_C is enabled).
S *
S * You can safely disable this if MBEDTLS_ERROR_C is enabled, or if you're
S * not using mbedtls_strerror() or error_strerror() in your application.
S *
S * Disable if you run into name conflicts and want to really remove the
S * mbedtls_strerror()
S */
S#define MBEDTLS_ERROR_STRERROR_DUMMY
S
S/**
S * \def MBEDTLS_GENPRIME
S *
S * Enable the prime-number generation code.
S *
S * Requires: MBEDTLS_BIGNUM_C
S */
S#define MBEDTLS_GENPRIME
S
S/**
S * \def MBEDTLS_FS_IO
S *
S * Enable functions that use the filesystem.
S */
S#define MBEDTLS_FS_IO
S
S/**
S * \def MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
S *
S * Do not add default entropy sources. These are the platform specific,
S * mbedtls_timing_hardclock and HAVEGE based poll functions.
S *
S * This is useful to have more control over the added entropy sources in an
S * application.
S *
S * Uncomment this macro to prevent loading of default entropy functions.
S */
S//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
S
S/**
S * \def MBEDTLS_NO_PLATFORM_ENTROPY
S *
S * Do not use built-in platform entropy functions.
S * This is useful if your platform does not support
S * standards like the /dev/urandom or Windows CryptoAPI.
S *
S * Uncomment this macro to disable the built-in platform entropy functions.
S */
S//#define MBEDTLS_NO_PLATFORM_ENTROPY
S
S/**
S * \def MBEDTLS_ENTROPY_FORCE_SHA256
S *
S * Force the entropy accumulator to use a SHA-256 accumulator instead of the
S * default SHA-512 based one (if both are available).
S *
S * Requires: MBEDTLS_SHA256_C
S *
S * On 32-bit systems SHA-256 can be much faster than SHA-512. Use this option
S * if you have performance concerns.
S *
S * This option is only useful if both MBEDTLS_SHA256_C and
S * MBEDTLS_SHA512_C are defined. Otherwise the available hash module is used.
S */
S//#define MBEDTLS_ENTROPY_FORCE_SHA256
S
S/**
S * \def MBEDTLS_MEMORY_DEBUG
S *
S * Enable debugging of buffer allocator memory issues. Automatically prints
S * (to stderr) all (fatal) messages on memory allocation issues. Enables
S * function for 'debug output' of allocated memory.
S *
S * Requires: MBEDTLS_MEMORY_BUFFER_ALLOC_C
S *
S * Uncomment this macro to let the buffer allocator print out error messages.
S */
S//#define MBEDTLS_MEMORY_DEBUG
S
S/**
S * \def MBEDTLS_MEMORY_BACKTRACE
S *
S * Include backtrace information with each allocated block.
S *
S * Requires: MBEDTLS_MEMORY_BUFFER_ALLOC_C
S *           GLIBC-compatible backtrace() an backtrace_symbols() support
S *
S * Uncomment this macro to include backtrace information
S */
S//#define MBEDTLS_MEMORY_BACKTRACE
S
S/**
S * \def MBEDTLS_PK_RSA_ALT_SUPPORT
S *
S * Support external private RSA keys (eg from a HSM) in the PK layer.
S *
S * Comment this macro to disable support for external private RSA keys.
S */
S#define MBEDTLS_PK_RSA_ALT_SUPPORT
S
S/**
S * \def MBEDTLS_PKCS1_V15
S *
S * Enable support for PKCS#1 v1.5 encoding.
S *
S * Requires: MBEDTLS_RSA_C
S *
S * This enables support for PKCS#1 v1.5 operations.
S */
S#define MBEDTLS_PKCS1_V15
S
S/**
S * \def MBEDTLS_PKCS1_V21
S *
S * Enable support for PKCS#1 v2.1 encoding.
S *
S * Requires: MBEDTLS_MD_C, MBEDTLS_RSA_C
S *
S * This enables support for RSAES-OAEP and RSASSA-PSS operations.
S */
S#define MBEDTLS_PKCS1_V21
S
S/**
S * \def MBEDTLS_RSA_NO_CRT
S *
S * Do not use the Chinese Remainder Theorem for the RSA private operation.
S *
S * Uncomment this macro to disable the use of CRT in RSA.
S *
S */
S//#define MBEDTLS_RSA_NO_CRT
S
S/**
S * \def MBEDTLS_SELF_TEST
S *
S * Enable the checkup functions (*_self_test).
S */
S#define MBEDTLS_SELF_TEST
S
S/**
S * \def MBEDTLS_SHA256_SMALLER
S *
S * Enable an implementation of SHA-256 that has lower ROM footprint but also
S * lower performance.
S *
S * The default implementation is meant to be a reasonnable compromise between
S * performance and size. This version optimizes more aggressively for size at
S * the expense of performance. Eg on Cortex-M4 it reduces the size of
S * mbedtls_sha256_process() from ~2KB to ~0.5KB for a performance hit of about
S * 30%.
S *
S * Uncomment to enable the smaller implementation of SHA256.
S */
S//#define MBEDTLS_SHA256_SMALLER
S
S/**
S * \def MBEDTLS_SSL_AEAD_RANDOM_IV
S *
S * Generate a random IV rather than using the record sequence number as a
S * nonce for ciphersuites using and AEAD algorithm (GCM or CCM).
S *
S * Using the sequence number is generally recommended.
S *
S * Uncomment this macro to always use random IVs with AEAD ciphersuites.
S */
S//#define MBEDTLS_SSL_AEAD_RANDOM_IV
S
S/**
S * \def MBEDTLS_SSL_ALL_ALERT_MESSAGES
S *
S * Enable sending of alert messages in case of encountered errors as per RFC.
S * If you choose not to send the alert messages, mbed TLS can still communicate
S * with other servers, only debugging of failures is harder.
S *
S * The advantage of not sending alert messages, is that no information is given
S * about reasons for failures thus preventing adversaries of gaining intel.
S *
S * Enable sending of all alert messages
S */
S#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
S
S/**
S * \def MBEDTLS_SSL_DEBUG_ALL
S *
S * Enable the debug messages in SSL module for all issues.
S * Debug messages have been disabled in some places to prevent timing
S * attacks due to (unbalanced) debugging function calls.
S *
S * If you need all error reporting you should enable this during debugging,
S * but remove this for production servers that should log as well.
S *
S * Uncomment this macro to report all debug messages on errors introducing
S * a timing side-channel.
S *
S */
S//#define MBEDTLS_SSL_DEBUG_ALL
S
S/** \def MBEDTLS_SSL_ENCRYPT_THEN_MAC
S *
S * Enable support for Encrypt-then-MAC, RFC 7366.
S *
S * This allows peers that both support it to use a more robust protection for
S * ciphersuites using CBC, providing deep resistance against timing attacks
S * on the padding or underlying cipher.
S *
S * This only affects CBC ciphersuites, and is useless if none is defined.
S *
S * Requires: MBEDTLS_SSL_PROTO_TLS1    or
S *           MBEDTLS_SSL_PROTO_TLS1_1  or
S *           MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Comment this macro to disable support for Encrypt-then-MAC
S */
S#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
S
S/** \def MBEDTLS_SSL_EXTENDED_MASTER_SECRET
S *
S * Enable support for Extended Master Secret, aka Session Hash
S * (draft-ietf-tls-session-hash-02).
S *
S * This was introduced as "the proper fix" to the Triple Handshake familiy of
S * attacks, but it is recommended to always use it (even if you disable
S * renegotiation), since it actually fixes a more fundamental issue in the
S * original SSL/TLS design, and has implications beyond Triple Handshake.
S *
S * Requires: MBEDTLS_SSL_PROTO_TLS1    or
S *           MBEDTLS_SSL_PROTO_TLS1_1  or
S *           MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Comment this macro to disable support for Extended Master Secret.
S */
S#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
S
S/**
S * \def MBEDTLS_SSL_FALLBACK_SCSV
S *
S * Enable support for FALLBACK_SCSV (draft-ietf-tls-downgrade-scsv-00).
S *
S * For servers, it is recommended to always enable this, unless you support
S * only one version of TLS, or know for sure that none of your clients
S * implements a fallback strategy.
S *
S * For clients, you only need this if you're using a fallback strategy, which
S * is not recommended in the first place, unless you absolutely need it to
S * interoperate with buggy (version-intolerant) servers.
S *
S * Comment this macro to disable support for FALLBACK_SCSV
S */
S#define MBEDTLS_SSL_FALLBACK_SCSV
S
S/**
S * \def MBEDTLS_SSL_HW_RECORD_ACCEL
S *
S * Enable hooking functions in SSL module for hardware acceleration of
S * individual records.
S *
S * Uncomment this macro to enable hooking functions.
S */
S//#define MBEDTLS_SSL_HW_RECORD_ACCEL
S
S/**
S * \def MBEDTLS_SSL_CBC_RECORD_SPLITTING
S *
S * Enable 1/n-1 record splitting for CBC mode in SSLv3 and TLS 1.0.
S *
S * This is a countermeasure to the BEAST attack, which also minimizes the risk
S * of interoperability issues compared to sending 0-length records.
S *
S * Comment this macro to disable 1/n-1 record splitting.
S */
S#define MBEDTLS_SSL_CBC_RECORD_SPLITTING
S
S/**
S * \def MBEDTLS_SSL_RENEGOTIATION
S *
S * Disable support for TLS renegotiation.
S *
S * The two main uses of renegotiation are (1) refresh keys on long-lived
S * connections and (2) client authentication after the initial handshake.
S * If you don't need renegotiation, it's probably better to disable it, since
S * it has been associated with security issues in the past and is easy to
S * misuse/misunderstand.
S *
S * Comment this to disable support for renegotiation.
S */
S#define MBEDTLS_SSL_RENEGOTIATION
S
S/**
S * \def MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
S *
S * Enable support for receiving and parsing SSLv2 Client Hello messages for the
S * SSL Server module (MBEDTLS_SSL_SRV_C).
S *
S * Uncomment this macro to enable support for SSLv2 Client Hello messages.
S */
S//#define MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
S
S/**
S * \def MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE
S *
S * Pick the ciphersuite according to the client's preferences rather than ours
S * in the SSL Server module (MBEDTLS_SSL_SRV_C).
S *
S * Uncomment this macro to respect client's ciphersuite order
S */
S//#define MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE
S
S/**
S * \def MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
S *
S * Enable support for RFC 6066 max_fragment_length extension in SSL.
S *
S * Comment this macro to disable support for the max_fragment_length extension
S */
S#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
S
S/**
S * \def MBEDTLS_SSL_PROTO_SSL3
S *
S * Enable support for SSL 3.0.
S *
S * Requires: MBEDTLS_MD5_C
S *           MBEDTLS_SHA1_C
S *
S * Comment this macro to disable support for SSL 3.0
S */
S#define MBEDTLS_SSL_PROTO_SSL3
S
S/**
S * \def MBEDTLS_SSL_PROTO_TLS1
S *
S * Enable support for TLS 1.0.
S *
S * Requires: MBEDTLS_MD5_C
S *           MBEDTLS_SHA1_C
S *
S * Comment this macro to disable support for TLS 1.0
S */
S#define MBEDTLS_SSL_PROTO_TLS1
S
S/**
S * \def MBEDTLS_SSL_PROTO_TLS1_1
S *
S * Enable support for TLS 1.1 (and DTLS 1.0 if DTLS is enabled).
S *
S * Requires: MBEDTLS_MD5_C
S *           MBEDTLS_SHA1_C
S *
S * Comment this macro to disable support for TLS 1.1 / DTLS 1.0
S */
S#define MBEDTLS_SSL_PROTO_TLS1_1
S
S/**
S * \def MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Enable support for TLS 1.2 (and DTLS 1.2 if DTLS is enabled).
S *
S * Requires: MBEDTLS_SHA1_C or MBEDTLS_SHA256_C or MBEDTLS_SHA512_C
S *           (Depends on ciphersuites)
S *
S * Comment this macro to disable support for TLS 1.2 / DTLS 1.2
S */
S#define MBEDTLS_SSL_PROTO_TLS1_2
S
S/**
S * \def MBEDTLS_SSL_PROTO_DTLS
S *
S * Enable support for DTLS (all available versions).
S *
S * Enable this and MBEDTLS_SSL_PROTO_TLS1_1 to enable DTLS 1.0,
S * and/or this and MBEDTLS_SSL_PROTO_TLS1_2 to enable DTLS 1.2.
S *
S * Requires: MBEDTLS_SSL_PROTO_TLS1_1
S *        or MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Comment this macro to disable support for DTLS
S */
S#define MBEDTLS_SSL_PROTO_DTLS
S
S/**
S * \def MBEDTLS_SSL_ALPN
S *
S * Enable support for RFC 7301 Application Layer Protocol Negotiation.
S *
S * Comment this macro to disable support for ALPN.
S */
S#define MBEDTLS_SSL_ALPN
S
S/**
S * \def MBEDTLS_SSL_DTLS_ANTI_REPLAY
S *
S * Enable support for the anti-replay mechanism in DTLS.
S *
S * Requires: MBEDTLS_SSL_TLS_C
S *           MBEDTLS_SSL_PROTO_DTLS
S *
S * \warning Disabling this is often a security risk!
S * See mbedtls_ssl_conf_dtls_anti_replay() for details.
S *
S * Comment this to disable anti-replay in DTLS.
S */
S#define MBEDTLS_SSL_DTLS_ANTI_REPLAY
S
S/**
S * \def MBEDTLS_SSL_DTLS_HELLO_VERIFY
S *
S * Enable support for HelloVerifyRequest on DTLS servers.
S *
S * This feature is highly recommended to prevent DTLS servers being used as
S * amplifiers in DoS attacks against other hosts. It should always be enabled
S * unless you know for sure amplification cannot be a problem in the
S * environment in which your server operates.
S *
S * \warning Disabling this can ba a security risk! (see above)
S *
S * Requires: MBEDTLS_SSL_PROTO_DTLS
S *
S * Comment this to disable support for HelloVerifyRequest.
S */
S#define MBEDTLS_SSL_DTLS_HELLO_VERIFY
S
S/**
S * \def MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
S *
S * Enable server-side support for clients that reconnect from the same port.
S *
S * Some clients unexpectedly close the connection and try to reconnect using the
S * same source port. This needs special support from the server to handle the
S * new connection securely, as described in section 4.2.8 of RFC 6347. This
S * flag enables that support.
S *
S * Requires: MBEDTLS_SSL_DTLS_HELLO_VERIFY
S *
S * Comment this to disable support for clients reusing the source port.
S */
S#define MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
S
S/**
S * \def MBEDTLS_SSL_DTLS_BADMAC_LIMIT
S *
S * Enable support for a limit of records with bad MAC.
S *
S * See mbedtls_ssl_conf_dtls_badmac_limit().
S *
S * Requires: MBEDTLS_SSL_PROTO_DTLS
S */
S#define MBEDTLS_SSL_DTLS_BADMAC_LIMIT
S
S/**
S * \def MBEDTLS_SSL_SESSION_TICKETS
S *
S * Enable support for RFC 5077 session tickets in SSL.
S * Client-side, provides full support for session tickets (maintainance of a
S * session store remains the responsibility of the application, though).
S * Server-side, you also need to provide callbacks for writing and parsing
S * tickets, including authenticated encryption and key management. Example
S * callbacks are provided by MBEDTLS_SSL_TICKET_C.
S *
S * Comment this macro to disable support for SSL session tickets
S */
S#define MBEDTLS_SSL_SESSION_TICKETS
S
S/**
S * \def MBEDTLS_SSL_EXPORT_KEYS
S *
S * Enable support for exporting key block and master secret.
S * This is required for certain users of TLS, e.g. EAP-TLS.
S *
S * Comment this macro to disable support for key export
S */
S#define MBEDTLS_SSL_EXPORT_KEYS
S
S/**
S * \def MBEDTLS_SSL_SERVER_NAME_INDICATION
S *
S * Enable support for RFC 6066 server name indication (SNI) in SSL.
S *
S * Requires: MBEDTLS_X509_CRT_PARSE_C
S *
S * Comment this macro to disable support for server name indication in SSL
S */
S#define MBEDTLS_SSL_SERVER_NAME_INDICATION
S
S/**
S * \def MBEDTLS_SSL_TRUNCATED_HMAC
S *
S * Enable support for RFC 6066 truncated HMAC in SSL.
S *
S * Comment this macro to disable support for truncated HMAC in SSL
S */
S#define MBEDTLS_SSL_TRUNCATED_HMAC
S
S/**
S * \def MBEDTLS_THREADING_ALT
S *
S * Provide your own alternate threading implementation.
S *
S * Requires: MBEDTLS_THREADING_C
S *
S * Uncomment this to allow your own alternate threading implementation.
S */
S//#define MBEDTLS_THREADING_ALT
S
S/**
S * \def MBEDTLS_THREADING_PTHREAD
S *
S * Enable the pthread wrapper layer for the threading layer.
S *
S * Requires: MBEDTLS_THREADING_C
S *
S * Uncomment this to enable pthread mutexes.
S */
S//#define MBEDTLS_THREADING_PTHREAD
S
S/**
S * \def MBEDTLS_VERSION_FEATURES
S *
S * Allow run-time checking of compile-time enabled features. Thus allowing users
S * to check at run-time if the library is for instance compiled with threading
S * support via mbedtls_version_check_feature().
S *
S * Requires: MBEDTLS_VERSION_C
S *
S * Comment this to disable run-time checking and save ROM space
S */
S#define MBEDTLS_VERSION_FEATURES
S
S/**
S * \def MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3
S *
S * If set, the X509 parser will not break-off when parsing an X509 certificate
S * and encountering an extension in a v1 or v2 certificate.
S *
S * Uncomment to prevent an error.
S */
S//#define MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3
S
S/**
S * \def MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
S *
S * If set, the X509 parser will not break-off when parsing an X509 certificate
S * and encountering an unknown critical extension.
S *
S * \warning Depending on your PKI use, enabling this can be a security risk!
S *
S * Uncomment to prevent an error.
S */
S//#define MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
S
S/**
S * \def MBEDTLS_X509_CHECK_KEY_USAGE
S *
S * Enable verification of the keyUsage extension (CA and leaf certificates).
S *
S * Disabling this avoids problems with mis-issued and/or misused
S * (intermediate) CA and leaf certificates.
S *
S * \warning Depending on your PKI use, disabling this can be a security risk!
S *
S * Comment to skip keyUsage checking for both CA and leaf certificates.
S */
S#define MBEDTLS_X509_CHECK_KEY_USAGE
S
S/**
S * \def MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
S *
S * Enable verification of the extendedKeyUsage extension (leaf certificates).
S *
S * Disabling this avoids problems with mis-issued and/or misused certificates.
S *
S * \warning Depending on your PKI use, disabling this can be a security risk!
S *
S * Comment to skip extendedKeyUsage checking for certificates.
S */
S#define MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
S
S/**
S * \def MBEDTLS_X509_RSASSA_PSS_SUPPORT
S *
S * Enable parsing and verification of X.509 certificates, CRLs and CSRS
S * signed with RSASSA-PSS (aka PKCS#1 v2.1).
S *
S * Comment this macro to disallow using RSASSA-PSS in certificates.
S */
S#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
S
S/**
S * \def MBEDTLS_ZLIB_SUPPORT
S *
S * If set, the SSL/TLS module uses ZLIB to support compression and
S * decompression of packet data.
S *
S * \warning TLS-level compression MAY REDUCE SECURITY! See for example the
S * CRIME attack. Before enabling this option, you should examine with care if
S * CRIME or similar exploits may be a applicable to your use case.
S *
S * \note Currently compression can't be used with DTLS.
S *
S * Used in: library/ssl_tls.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This feature requires zlib library and headers to be present.
S *
S * Uncomment to enable use of ZLIB
S */
S//#define MBEDTLS_ZLIB_SUPPORT
S/* \} name SECTION: mbed TLS feature support */
S
S/**
S * \name SECTION: mbed TLS modules
S *
S * This section enables or disables entire modules in mbed TLS
S * \{
S */
S
S/**
S * \def MBEDTLS_AESNI_C
S *
S * Enable AES-NI support on x86-64.
S *
S * Module:  library/aesni.c
S * Caller:  library/aes.c
S *
S * Requires: MBEDTLS_HAVE_ASM
S *
S * This modules adds support for the AES-NI instructions on x86-64
S */
S#define MBEDTLS_AESNI_C
S
S/**
S * \def MBEDTLS_AES_C
S *
S * Enable the AES block cipher.
S *
S * Module:  library/aes.c
S * Caller:  library/ssl_tls.c
S *          library/pem.c
S *          library/ctr_drbg.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA
S *
S * PEM_PARSE uses AES for decrypting encrypted keys.
S */
S#define MBEDTLS_AES_C
S
S/**
S * \def MBEDTLS_ARC4_C
S *
S * Enable the ARCFOUR stream cipher.
S *
S * Module:  library/arc4.c
S * Caller:  library/ssl_tls.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_MD5
S *      MBEDTLS_TLS_RSA_PSK_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_ARC4_C
S
S/**
S * \def MBEDTLS_ASN1_PARSE_C
S *
S * Enable the generic ASN1 parser.
S *
S * Module:  library/asn1.c
S * Caller:  library/x509.c
S *          library/dhm.c
S *          library/pkcs12.c
S *          library/pkcs5.c
S *          library/pkparse.c
S */
S#define MBEDTLS_ASN1_PARSE_C
S
S/**
S * \def MBEDTLS_ASN1_WRITE_C
S *
S * Enable the generic ASN1 writer.
S *
S * Module:  library/asn1write.c
S * Caller:  library/ecdsa.c
S *          library/pkwrite.c
S *          library/x509_create.c
S *          library/x509write_crt.c
S *          library/mbedtls_x509write_csr.c
S */
S#define MBEDTLS_ASN1_WRITE_C
S
S/**
S * \def MBEDTLS_BASE64_C
S *
S * Enable the Base64 module.
S *
S * Module:  library/base64.c
S * Caller:  library/pem.c
S *
S * This module is required for PEM support (required by X.509).
S */
S#define MBEDTLS_BASE64_C
S
S/**
S * \def MBEDTLS_BIGNUM_C
S *
S * Enable the multi-precision integer library.
S *
S * Module:  library/bignum.c
S * Caller:  library/dhm.c
S *          library/ecp.c
S *          library/ecdsa.c
S *          library/rsa.c
S *          library/ssl_tls.c
S *
S * This module is required for RSA, DHM and ECC (ECDH, ECDSA) support.
S */
S#define MBEDTLS_BIGNUM_C
S
S/**
S * \def MBEDTLS_BLOWFISH_C
S *
S * Enable the Blowfish block cipher.
S *
S * Module:  library/blowfish.c
S */
S#define MBEDTLS_BLOWFISH_C
S
S/**
S * \def MBEDTLS_CAMELLIA_C
S *
S * Enable the Camellia block cipher.
S *
S * Module:  library/camellia.c
S * Caller:  library/ssl_tls.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
S */
S#define MBEDTLS_CAMELLIA_C
S
S/**
S * \def MBEDTLS_CCM_C
S *
S * Enable the Counter with CBC-MAC (CCM) mode for 128-bit block cipher.
S *
S * Module:  library/ccm.c
S *
S * Requires: MBEDTLS_AES_C or MBEDTLS_CAMELLIA_C
S *
S * This module enables the AES-CCM ciphersuites, if other requisites are
S * enabled as well.
S */
S#define MBEDTLS_CCM_C
S
S/**
S * \def MBEDTLS_CERTS_C
S *
S * Enable the test certificates.
S *
S * Module:  library/certs.c
S * Caller:
S *
S * This module is used for testing (ssl_client/server).
S */
S#define MBEDTLS_CERTS_C
S
S/**
S * \def MBEDTLS_CIPHER_C
S *
S * Enable the generic cipher layer.
S *
S * Module:  library/cipher.c
S * Caller:  library/ssl_tls.c
S *
S * Uncomment to enable generic cipher wrappers.
S */
S#define MBEDTLS_CIPHER_C
S
S/**
S * \def MBEDTLS_CTR_DRBG_C
S *
S * Enable the CTR_DRBG AES-256-based random generator.
S *
S * Module:  library/ctr_drbg.c
S * Caller:
S *
S * Requires: MBEDTLS_AES_C
S *
S * This module provides the CTR_DRBG AES-256 random number generator.
S */
S#define MBEDTLS_CTR_DRBG_C
S
S/**
S * \def MBEDTLS_DEBUG_C
S *
S * Enable the debug functions.
S *
S * Module:  library/debug.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *
S * This module provides debugging functions.
S */
S#define MBEDTLS_DEBUG_C
S
S/**
S * \def MBEDTLS_DES_C
S *
S * Enable the DES block cipher.
S *
S * Module:  library/des.c
S * Caller:  library/pem.c
S *          library/ssl_tls.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_3DES_EDE_CBC_SHA
S *
S * PEM_PARSE uses DES/3DES for decrypting encrypted keys.
S */
S#define MBEDTLS_DES_C
S
S/**
S * \def MBEDTLS_DHM_C
S *
S * Enable the Diffie-Hellman-Merkle module.
S *
S * Module:  library/dhm.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This module is used by the following key exchanges:
S *      DHE-RSA, DHE-PSK
S */
S#define MBEDTLS_DHM_C
S
S/**
S * \def MBEDTLS_ECDH_C
S *
S * Enable the elliptic curve Diffie-Hellman library.
S *
S * Module:  library/ecdh.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This module is used by the following key exchanges:
S *      ECDHE-ECDSA, ECDHE-RSA, DHE-PSK
S *
S * Requires: MBEDTLS_ECP_C
S */
S#define MBEDTLS_ECDH_C
S
S/**
S * \def MBEDTLS_ECDSA_C
S *
S * Enable the elliptic curve DSA library.
S *
S * Module:  library/ecdsa.c
S * Caller:
S *
S * This module is used by the following key exchanges:
S *      ECDHE-ECDSA
S *
S * Requires: MBEDTLS_ECP_C, MBEDTLS_ASN1_WRITE_C, MBEDTLS_ASN1_PARSE_C
S */
S#define MBEDTLS_ECDSA_C
S
S/**
S * \def MBEDTLS_ECJPAKE_C
S *
S * Enable the elliptic curve J-PAKE library.
S *
S * \warning This is currently experimental. EC J-PAKE support is based on the
S * Thread v1.0.0 specification; incompatible changes to the specification
S * might still happen. For this reason, this is disabled by default.
S *
S * Module:  library/ecjpake.c
S * Caller:
S *
S * This module is used by the following key exchanges:
S *      ECJPAKE
S *
S * Requires: MBEDTLS_ECP_C, MBEDTLS_MD_C
S */
S//#define MBEDTLS_ECJPAKE_C
S
S/**
S * \def MBEDTLS_ECP_C
S *
S * Enable the elliptic curve over GF(p) library.
S *
S * Module:  library/ecp.c
S * Caller:  library/ecdh.c
S *          library/ecdsa.c
S *          library/ecjpake.c
S *
S * Requires: MBEDTLS_BIGNUM_C and at least one MBEDTLS_ECP_DP_XXX_ENABLED
S */
S#define MBEDTLS_ECP_C
S
S/**
S * \def MBEDTLS_ENTROPY_C
S *
S * Enable the platform-specific entropy code.
S *
S * Module:  library/entropy.c
S * Caller:
S *
S * Requires: MBEDTLS_SHA512_C or MBEDTLS_SHA256_C
S *
S * This module provides a generic entropy pool
S */
S#define MBEDTLS_ENTROPY_C
S
S/**
S * \def MBEDTLS_ERROR_C
S *
S * Enable error code to error string conversion.
S *
S * Module:  library/error.c
S * Caller:
S *
S * This module enables mbedtls_strerror().
S */
S#define MBEDTLS_ERROR_C
S
S/**
S * \def MBEDTLS_GCM_C
S *
S * Enable the Galois/Counter Mode (GCM) for AES.
S *
S * Module:  library/gcm.c
S *
S * Requires: MBEDTLS_AES_C or MBEDTLS_CAMELLIA_C
S *
S * This module enables the AES-GCM and CAMELLIA-GCM ciphersuites, if other
S * requisites are enabled as well.
S */
S#define MBEDTLS_GCM_C
S
S/**
S * \def MBEDTLS_HAVEGE_C
S *
S * Enable the HAVEGE random generator.
S *
S * Warning: the HAVEGE random generator is not suitable for virtualized
S *          environments
S *
S * Warning: the HAVEGE random generator is dependent on timing and specific
S *          processor traits. It is therefore not advised to use HAVEGE as
S *          your applications primary random generator or primary entropy pool
S *          input. As a secondary input to your entropy pool, it IS able add
S *          the (limited) extra entropy it provides.
S *
S * Module:  library/havege.c
S * Caller:
S *
S * Requires: MBEDTLS_TIMING_C
S *
S * Uncomment to enable the HAVEGE random generator.
S */
S//#define MBEDTLS_HAVEGE_C
S
S/**
S * \def MBEDTLS_HMAC_DRBG_C
S *
S * Enable the HMAC_DRBG random generator.
S *
S * Module:  library/hmac_drbg.c
S * Caller:
S *
S * Requires: MBEDTLS_MD_C
S *
S * Uncomment to enable the HMAC_DRBG random number geerator.
S */
S#define MBEDTLS_HMAC_DRBG_C
S
S/**
S * \def MBEDTLS_MD_C
S *
S * Enable the generic message digest layer.
S *
S * Module:  library/mbedtls_md.c
S * Caller:
S *
S * Uncomment to enable generic message digest wrappers.
S */
S#define MBEDTLS_MD_C
S
S/**
S * \def MBEDTLS_MD2_C
S *
S * Enable the MD2 hash algorithm.
S *
S * Module:  library/mbedtls_md2.c
S * Caller:
S *
S * Uncomment to enable support for (rare) MD2-signed X.509 certs.
S */
S//#define MBEDTLS_MD2_C
S
S/**
S * \def MBEDTLS_MD4_C
S *
S * Enable the MD4 hash algorithm.
S *
S * Module:  library/mbedtls_md4.c
S * Caller:
S *
S * Uncomment to enable support for (rare) MD4-signed X.509 certs.
S */
S//#define MBEDTLS_MD4_C
S
S/**
S * \def MBEDTLS_MD5_C
S *
S * Enable the MD5 hash algorithm.
S *
S * Module:  library/mbedtls_md5.c
S * Caller:  library/mbedtls_md.c
S *          library/pem.c
S *          library/ssl_tls.c
S *
S * This module is required for SSL/TLS and X.509.
S * PEM_PARSE uses MD5 for decrypting encrypted keys.
S */
S#define MBEDTLS_MD5_C
S
S/**
S * \def MBEDTLS_MEMORY_BUFFER_ALLOC_C
S *
S * Enable the buffer allocator implementation that makes use of a (stack)
S * based buffer to 'allocate' dynamic memory. (replaces calloc() and free()
S * calls)
S *
S * Module:  library/memory_buffer_alloc.c
S *
S * Requires: MBEDTLS_PLATFORM_C
S *           MBEDTLS_PLATFORM_MEMORY (to use it within mbed TLS)
S *
S * Enable this module to enable the buffer memory allocator.
S */
S//#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
S
S/**
S * \def MBEDTLS_NET_C
S *
S * Enable the TCP/IP networking routines.
S *
S * Module:  library/net.c
S *
S * This module provides TCP/IP networking routines.
S */
S#define MBEDTLS_NET_C
S
S/**
S * \def MBEDTLS_OID_C
S *
S * Enable the OID database.
S *
S * Module:  library/oid.c
S * Caller:  library/asn1write.c
S *          library/pkcs5.c
S *          library/pkparse.c
S *          library/pkwrite.c
S *          library/rsa.c
S *          library/x509.c
S *          library/x509_create.c
S *          library/mbedtls_x509_crl.c
S *          library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *          library/x509write_crt.c
S *          library/mbedtls_x509write_csr.c
S *
S * This modules translates between OIDs and internal values.
S */
S#define MBEDTLS_OID_C
S
S/**
S * \def MBEDTLS_PADLOCK_C
S *
S * Enable VIA Padlock support on x86.
S *
S * Module:  library/padlock.c
S * Caller:  library/aes.c
S *
S * Requires: MBEDTLS_HAVE_ASM
S *
S * This modules adds support for the VIA PadLock on x86.
S */
S#define MBEDTLS_PADLOCK_C
S
S/**
S * \def MBEDTLS_PEM_PARSE_C
S *
S * Enable PEM decoding / parsing.
S *
S * Module:  library/pem.c
S * Caller:  library/dhm.c
S *          library/pkparse.c
S *          library/mbedtls_x509_crl.c
S *          library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *
S * Requires: MBEDTLS_BASE64_C
S *
S * This modules adds support for decoding / parsing PEM files.
S */
S#define MBEDTLS_PEM_PARSE_C
S
S/**
S * \def MBEDTLS_PEM_WRITE_C
S *
S * Enable PEM encoding / writing.
S *
S * Module:  library/pem.c
S * Caller:  library/pkwrite.c
S *          library/x509write_crt.c
S *          library/mbedtls_x509write_csr.c
S *
S * Requires: MBEDTLS_BASE64_C
S *
S * This modules adds support for encoding / writing PEM files.
S */
S#define MBEDTLS_PEM_WRITE_C
S
S/**
S * \def MBEDTLS_PK_C
S *
S * Enable the generic public (asymetric) key layer.
S *
S * Module:  library/pk.c
S * Caller:  library/ssl_tls.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * Requires: MBEDTLS_RSA_C or MBEDTLS_ECP_C
S *
S * Uncomment to enable generic public key wrappers.
S */
S#define MBEDTLS_PK_C
S
S/**
S * \def MBEDTLS_PK_PARSE_C
S *
S * Enable the generic public (asymetric) key parser.
S *
S * Module:  library/pkparse.c
S * Caller:  library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *
S * Requires: MBEDTLS_PK_C
S *
S * Uncomment to enable generic public key parse functions.
S */
S#define MBEDTLS_PK_PARSE_C
S
S/**
S * \def MBEDTLS_PK_WRITE_C
S *
S * Enable the generic public (asymetric) key writer.
S *
S * Module:  library/pkwrite.c
S * Caller:  library/x509write.c
S *
S * Requires: MBEDTLS_PK_C
S *
S * Uncomment to enable generic public key write functions.
S */
S#define MBEDTLS_PK_WRITE_C
S
S/**
S * \def MBEDTLS_PKCS5_C
S *
S * Enable PKCS#5 functions.
S *
S * Module:  library/pkcs5.c
S *
S * Requires: MBEDTLS_MD_C
S *
S * This module adds support for the PKCS#5 functions.
S */
S#define MBEDTLS_PKCS5_C
S
S/**
S * \def MBEDTLS_PKCS11_C
S *
S * Enable wrapper for PKCS#11 smartcard support.
S *
S * Module:  library/pkcs11.c
S * Caller:  library/pk.c
S *
S * Requires: MBEDTLS_PK_C
S *
S * This module enables SSL/TLS PKCS #11 smartcard support.
S * Requires the presence of the PKCS#11 helper library (libpkcs11-helper)
S */
S//#define MBEDTLS_PKCS11_C
S
S/**
S * \def MBEDTLS_PKCS12_C
S *
S * Enable PKCS#12 PBE functions.
S * Adds algorithms for parsing PKCS#8 encrypted private keys
S *
S * Module:  library/pkcs12.c
S * Caller:  library/pkparse.c
S *
S * Requires: MBEDTLS_ASN1_PARSE_C, MBEDTLS_CIPHER_C, MBEDTLS_MD_C
S * Can use:  MBEDTLS_ARC4_C
S *
S * This module enables PKCS#12 functions.
S */
S#define MBEDTLS_PKCS12_C
S
S/**
S * \def MBEDTLS_PLATFORM_C
S *
S * Enable the platform abstraction layer that allows you to re-assign
S * functions like calloc(), free(), snprintf(), printf(), fprintf(), exit().
S *
S * Enabling MBEDTLS_PLATFORM_C enables to use of MBEDTLS_PLATFORM_XXX_ALT
S * or MBEDTLS_PLATFORM_XXX_MACRO directives, allowing the functions mentioned
S * above to be specified at runtime or compile time respectively.
S *
S * \note This abstraction layer must be enabled on Windows (including MSYS2)
S * as other module rely on it for a fixed snprintf implementation.
S *
S * Module:  library/platform.c
S * Caller:  Most other .c files
S *
S * This module enables abstraction of common (libc) functions.
S */
S#define MBEDTLS_PLATFORM_C
S
S/**
S * \def MBEDTLS_RIPEMD160_C
S *
S * Enable the RIPEMD-160 hash algorithm.
S *
S * Module:  library/mbedtls_ripemd160.c
S * Caller:  library/mbedtls_md.c
S *
S */
S#define MBEDTLS_RIPEMD160_C
S
S/**
S * \def MBEDTLS_RSA_C
S *
S * Enable the RSA public-key cryptosystem.
S *
S * Module:  library/rsa.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *          library/x509.c
S *
S * This module is used by the following key exchanges:
S *      RSA, DHE-RSA, ECDHE-RSA, RSA-PSK
S *
S * Requires: MBEDTLS_BIGNUM_C, MBEDTLS_OID_C
S */
S#define MBEDTLS_RSA_C
S
S/**
S * \def MBEDTLS_SHA1_C
S *
S * Enable the SHA1 cryptographic hash algorithm.
S *
S * Module:  library/mbedtls_sha1.c
S * Caller:  library/mbedtls_md.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *          library/x509write_crt.c
S *
S * This module is required for SSL/TLS and SHA1-signed certificates.
S */
S#define MBEDTLS_SHA1_C
S
S/**
S * \def MBEDTLS_SHA256_C
S *
S * Enable the SHA-224 and SHA-256 cryptographic hash algorithms.
S *
S * Module:  library/mbedtls_sha256.c
S * Caller:  library/entropy.c
S *          library/mbedtls_md.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *
S * This module adds support for SHA-224 and SHA-256.
S * This module is required for the SSL/TLS 1.2 PRF function.
S */
S#define MBEDTLS_SHA256_C
S
S/**
S * \def MBEDTLS_SHA512_C
S *
S * Enable the SHA-384 and SHA-512 cryptographic hash algorithms.
S *
S * Module:  library/mbedtls_sha512.c
S * Caller:  library/entropy.c
S *          library/mbedtls_md.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This module adds support for SHA-384 and SHA-512.
S */
S#define MBEDTLS_SHA512_C
S
S/**
S * \def MBEDTLS_SSL_CACHE_C
S *
S * Enable simple SSL cache implementation.
S *
S * Module:  library/ssl_cache.c
S * Caller:
S *
S * Requires: MBEDTLS_SSL_CACHE_C
S */
S#define MBEDTLS_SSL_CACHE_C
S
S/**
S * \def MBEDTLS_SSL_COOKIE_C
S *
S * Enable basic implementation of DTLS cookies for hello verification.
S *
S * Module:  library/ssl_cookie.c
S * Caller:
S */
S#define MBEDTLS_SSL_COOKIE_C
S
S/**
S * \def MBEDTLS_SSL_TICKET_C
S *
S * Enable an implementation of TLS server-side callbacks for session tickets.
S *
S * Module:  library/ssl_ticket.c
S * Caller:
S *
S * Requires: MBEDTLS_CIPHER_C
S */
S#define MBEDTLS_SSL_TICKET_C
S
S/**
S * \def MBEDTLS_SSL_CLI_C
S *
S * Enable the SSL/TLS client code.
S *
S * Module:  library/ssl_cli.c
S * Caller:
S *
S * Requires: MBEDTLS_SSL_TLS_C
S *
S * This module is required for SSL/TLS client support.
S */
S#define MBEDTLS_SSL_CLI_C
S
S/**
S * \def MBEDTLS_SSL_SRV_C
S *
S * Enable the SSL/TLS server code.
S *
S * Module:  library/ssl_srv.c
S * Caller:
S *
S * Requires: MBEDTLS_SSL_TLS_C
S *
S * This module is required for SSL/TLS server support.
S */
S#define MBEDTLS_SSL_SRV_C
S
S/**
S * \def MBEDTLS_SSL_TLS_C
S *
S * Enable the generic SSL/TLS code.
S *
S * Module:  library/ssl_tls.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * Requires: MBEDTLS_CIPHER_C, MBEDTLS_MD_C
S *           and at least one of the MBEDTLS_SSL_PROTO_XXX defines
S *
S * This module is required for SSL/TLS.
S */
S#define MBEDTLS_SSL_TLS_C
S
S/**
S * \def MBEDTLS_THREADING_C
S *
S * Enable the threading abstraction layer.
S * By default mbed TLS assumes it is used in a non-threaded environment or that
S * contexts are not shared between threads. If you do intend to use contexts
S * between threads, you will need to enable this layer to prevent race
S * conditions.
S *
S * Module:  library/threading.c
S *
S * This allows different threading implementations (self-implemented or
S * provided).
S *
S * You will have to enable either MBEDTLS_THREADING_ALT or
S * MBEDTLS_THREADING_PTHREAD.
S *
S * Enable this layer to allow use of mutexes within mbed TLS
S */
S//#define MBEDTLS_THREADING_C
S
S/**
S * \def MBEDTLS_TIMING_C
S *
S * Enable the portable timing interface.
S *
S * Module:  library/timing.c
S * Caller:  library/havege.c
S *
S * This module is used by the HAVEGE random number generator.
S */
S#define MBEDTLS_TIMING_C
S
S/**
S * \def MBEDTLS_VERSION_C
S *
S * Enable run-time version information.
S *
S * Module:  library/version.c
S *
S * This module provides run-time version information.
S */
S#define MBEDTLS_VERSION_C
S
S/**
S * \def MBEDTLS_X509_USE_C
S *
S * Enable X.509 core for using certificates.
S *
S * Module:  library/x509.c
S * Caller:  library/mbedtls_x509_crl.c
S *          library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *
S * Requires: MBEDTLS_ASN1_PARSE_C, MBEDTLS_BIGNUM_C, MBEDTLS_OID_C,
S *           MBEDTLS_PK_PARSE_C
S *
S * This module is required for the X.509 parsing modules.
S */
S#define MBEDTLS_X509_USE_C
S
S/**
S * \def MBEDTLS_X509_CRT_PARSE_C
S *
S * Enable X.509 certificate parsing.
S *
S * Module:  library/mbedtls_x509_crt.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *
S * Requires: MBEDTLS_X509_USE_C
S *
S * This module is required for X.509 certificate parsing.
S */
S#define MBEDTLS_X509_CRT_PARSE_C
S
S/**
S * \def MBEDTLS_X509_CRL_PARSE_C
S *
S * Enable X.509 CRL parsing.
S *
S * Module:  library/mbedtls_x509_crl.c
S * Caller:  library/mbedtls_x509_crt.c
S *
S * Requires: MBEDTLS_X509_USE_C
S *
S * This module is required for X.509 CRL parsing.
S */
S#define MBEDTLS_X509_CRL_PARSE_C
S
S/**
S * \def MBEDTLS_X509_CSR_PARSE_C
S *
S * Enable X.509 Certificate Signing Request (CSR) parsing.
S *
S * Module:  library/mbedtls_x509_csr.c
S * Caller:  library/x509_crt_write.c
S *
S * Requires: MBEDTLS_X509_USE_C
S *
S * This module is used for reading X.509 certificate request.
S */
S#define MBEDTLS_X509_CSR_PARSE_C
S
S/**
S * \def MBEDTLS_X509_CREATE_C
S *
S * Enable X.509 core for creating certificates.
S *
S * Module:  library/x509_create.c
S *
S * Requires: MBEDTLS_BIGNUM_C, MBEDTLS_OID_C, MBEDTLS_PK_WRITE_C
S *
S * This module is the basis for creating X.509 certificates and CSRs.
S */
S#define MBEDTLS_X509_CREATE_C
S
S/**
S * \def MBEDTLS_X509_CRT_WRITE_C
S *
S * Enable creating X.509 certificates.
S *
S * Module:  library/x509_crt_write.c
S *
S * Requires: MBEDTLS_X509_CREATE_C
S *
S * This module is required for X.509 certificate creation.
S */
S#define MBEDTLS_X509_CRT_WRITE_C
S
S/**
S * \def MBEDTLS_X509_CSR_WRITE_C
S *
S * Enable creating X.509 Certificate Signing Requests (CSR).
S *
S * Module:  library/x509_csr_write.c
S *
S * Requires: MBEDTLS_X509_CREATE_C
S *
S * This module is required for X.509 certificate request writing.
S */
S#define MBEDTLS_X509_CSR_WRITE_C
S
S/**
S * \def MBEDTLS_XTEA_C
S *
S * Enable the XTEA block cipher.
S *
S * Module:  library/xtea.c
S * Caller:
S */
S#define MBEDTLS_XTEA_C
S
S/* \} name SECTION: mbed TLS modules */
S
S/**
S * \name SECTION: Module configuration options
S *
S * This section allows for the setting of module specific sizes and
S * configuration options. The default values are already present in the
S * relevant header files and should suffice for the regular use cases.
S *
S * Our advice is to enable options and change their values here
S * only if you have a good reason and know the consequences.
S *
S * Please check the respective header file for documentation on these
S * parameters (to prevent duplicate documentation).
S * \{
S */
S
S/* MPI / BIGNUM options */
S//#define MBEDTLS_MPI_WINDOW_SIZE            6 /**< Maximum windows size used. */
S//#define MBEDTLS_MPI_MAX_SIZE            1024 /**< Maximum number of bytes for usable MPIs. */
S
S/* CTR_DRBG options */
S//#define MBEDTLS_CTR_DRBG_ENTROPY_LEN               48 /**< Amount of entropy used per seed by default (48 with SHA-512, 32 with SHA-256) */
S//#define MBEDTLS_CTR_DRBG_RESEED_INTERVAL        10000 /**< Interval before reseed is performed by default */
S//#define MBEDTLS_CTR_DRBG_MAX_INPUT                256 /**< Maximum number of additional input bytes */
S//#define MBEDTLS_CTR_DRBG_MAX_REQUEST             1024 /**< Maximum number of requested bytes per call */
S//#define MBEDTLS_CTR_DRBG_MAX_SEED_INPUT           384 /**< Maximum size of (re)seed buffer */
S
S/* HMAC_DRBG options */
S//#define MBEDTLS_HMAC_DRBG_RESEED_INTERVAL   10000 /**< Interval before reseed is performed by default */
S//#define MBEDTLS_HMAC_DRBG_MAX_INPUT           256 /**< Maximum number of additional input bytes */
S//#define MBEDTLS_HMAC_DRBG_MAX_REQUEST        1024 /**< Maximum number of requested bytes per call */
S//#define MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT      384 /**< Maximum size of (re)seed buffer */
S
S/* ECP options */
S//#define MBEDTLS_ECP_MAX_BITS             521 /**< Maximum bit size of groups */
S//#define MBEDTLS_ECP_WINDOW_SIZE            6 /**< Maximum window size used */
S//#define MBEDTLS_ECP_FIXED_POINT_OPTIM      1 /**< Enable fixed-point speed-up */
S
S/* Entropy options */
S//#define MBEDTLS_ENTROPY_MAX_SOURCES                20 /**< Maximum number of sources supported */
S//#define MBEDTLS_ENTROPY_MAX_GATHER                128 /**< Maximum amount requested from entropy sources */
S
S/* Memory buffer allocator options */
S//#define MBEDTLS_MEMORY_ALIGN_MULTIPLE      4 /**< Align on multiples of this value */
S
S/* Platform options */
S//#define MBEDTLS_PLATFORM_STD_MEM_HDR   <stdlib.h> /**< Header to include if MBEDTLS_PLATFORM_NO_STD_FUNCTIONS is defined. Don't define if no header is needed. */
S//#define MBEDTLS_PLATFORM_STD_CALLOC        calloc /**< Default allocator to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_FREE            free /**< Default free to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_EXIT            exit /**< Default exit to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_FPRINTF      fprintf /**< Default fprintf to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_PRINTF        printf /**< Default printf to use, can be undefined */
S/* Note: your snprintf must correclty zero-terminate the buffer! */
S//#define MBEDTLS_PLATFORM_STD_SNPRINTF    snprintf /**< Default snprintf to use, can be undefined */
S
S/* To Use Function Macros MBEDTLS_PLATFORM_C must be enabled */
S/* MBEDTLS_PLATFORM_XXX_MACRO and MBEDTLS_PLATFORM_XXX_ALT cannot both be defined */
S//#define MBEDTLS_PLATFORM_CALLOC_MACRO        calloc /**< Default allocator macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_FREE_MACRO            free /**< Default free macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_EXIT_MACRO            exit /**< Default exit macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_FPRINTF_MACRO      fprintf /**< Default fprintf macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_PRINTF_MACRO        printf /**< Default printf macro to use, can be undefined */
S/* Note: your snprintf must correclty zero-terminate the buffer! */
S//#define MBEDTLS_PLATFORM_SNPRINTF_MACRO    snprintf /**< Default snprintf macro to use, can be undefined */
S
S/* SSL Cache options */
S//#define MBEDTLS_SSL_CACHE_DEFAULT_TIMEOUT       86400 /**< 1 day  */
S//#define MBEDTLS_SSL_CACHE_DEFAULT_MAX_ENTRIES      50 /**< Maximum entries in cache */
S
S/* SSL options */
S//#define MBEDTLS_SSL_MAX_CONTENT_LEN             16384 /**< Maxium fragment length in bytes, determines the size of each of the two internal I/O buffers */
S//#define MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME     86400 /**< Lifetime of session tickets (if enabled) */
S//#define MBEDTLS_PSK_MAX_LEN               32 /**< Max size of TLS pre-shared keys, in bytes (default 256 bits) */
S//#define MBEDTLS_SSL_COOKIE_TIMEOUT        60 /**< Default expiration delay of DTLS cookies, in seconds if HAVE_TIME, or in number of cookies issued */
S
S/**
S * Complete list of ciphersuites to use, in order of preference.
S *
S * \warning No dependency checking is done on that field! This option can only
S * be used to restrict the set of available ciphersuites. It is your
S * responsibility to make sure the needed modules are active.
S *
S * Use this to save a few hundred bytes of ROM (default ordering of all
S * available ciphersuites) and a few to a few hundred bytes of RAM.
S *
S * The value below is only an example, not the default.
S */
S//#define MBEDTLS_SSL_CIPHERSUITES MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
S
S/* X509 options */
S//#define MBEDTLS_X509_MAX_INTERMEDIATE_CA   8   /**< Maximum number of intermediate CAs in a verification chain. */
S
S/* \} name SECTION: Module configuration options */
S
S#if defined(TARGET_LIKE_MBED)
S#include "mbedtls/target_config.h"
S#endif
S
S/*
S * Allow user to override any previous default.
S *
S * Use two macro names for that, as:
S * - with yotta the prefix YOTTA_CFG_ is forced
S * - without yotta is looks weird to have a YOTTA prefix.
S */
S#if defined(YOTTA_CFG_MBEDTLS_USER_CONFIG_FILE)
S#include YOTTA_CFG_MBEDTLS_USER_CONFIG_FILE
S#elif defined(MBEDTLS_USER_CONFIG_FILE)
S#include MBEDTLS_USER_CONFIG_FILE
S#endif
S
S#include "check_config.h"
S
N#endif /* MBEDTLS_CONFIG_H */
L 24 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\library\ssl_srv.c" 2
N#else
S#include MBEDTLS_CONFIG_FILE
N#endif
N
N#if defined(MBEDTLS_SSL_SRV_C)
X#if 0L
S
S#include "mbedtls/debug.h"
S#include "mbedtls/ssl.h"
S#include "mbedtls/ssl_internal.h"
S
S#include <string.h>
S
S#if defined(MBEDTLS_ECP_C)
S#include "mbedtls/ecp.h"
S#endif
S
S#if defined(MBEDTLS_PLATFORM_C)
S#include "mbedtls/platform.h"
S#else
S#include <stdlib.h>
S#define mbedtls_calloc    calloc
S#define mbedtls_free       free
S#endif
S
S#if defined(MBEDTLS_HAVE_TIME)
S#include <time.h>
S#endif
S
S#if defined(MBEDTLS_SSL_SESSION_TICKETS)
S/* Implementation that should never be optimized out by the compiler */
Sstatic void mbedtls_zeroize( void *v, size_t n ) {
S    volatile unsigned char *p = v; while( n-- ) *p++ = 0;
S}
S#endif
S
S#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
Sint mbedtls_ssl_set_client_transport_id( mbedtls_ssl_context *ssl,
S                                 const unsigned char *info,
S                                 size_t ilen )
S{
S    if( ssl->conf->endpoint != MBEDTLS_SSL_IS_SERVER )
S        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
S
S    mbedtls_free( ssl->cli_id );
S
S    if( ( ssl->cli_id = mbedtls_calloc( 1, ilen ) ) == NULL )
S        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
S
S    memcpy( ssl->cli_id, info, ilen );
S    ssl->cli_id_len = ilen;
S
S    return( 0 );
S}
S
Svoid mbedtls_ssl_conf_dtls_cookies( mbedtls_ssl_config *conf,
S                           mbedtls_ssl_cookie_write_t *f_cookie_write,
S                           mbedtls_ssl_cookie_check_t *f_cookie_check,
S                           void *p_cookie )
S{
S    conf->f_cookie_write = f_cookie_write;
S    conf->f_cookie_check = f_cookie_check;
S    conf->p_cookie       = p_cookie;
S}
S#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
S
S#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
Sstatic int ssl_parse_servername_ext( mbedtls_ssl_context *ssl,
S                                     const unsigned char *buf,
S                                     size_t len )
S{
S    int ret;
S    size_t servername_list_size, hostname_len;
S    const unsigned char *p;
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "parse ServerName extension" ) );
S
S    servername_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
S    if( servername_list_size + 2 != len )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    p = buf + 2;
S    while( servername_list_size > 0 )
S    {
S        hostname_len = ( ( p[1] << 8 ) | p[2] );
S        if( hostname_len + 3 > servername_list_size )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S
S        if( p[0] == MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME )
S        {
S            ret = ssl->conf->f_sni( ssl->conf->p_sni,
S                                    ssl, p + 3, hostname_len );
S            if( ret != 0 )
S            {
S                MBEDTLS_SSL_DEBUG_RET( 1, "ssl_sni_wrapper", ret );
S                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
S                        MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME );
S                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S            }
S            return( 0 );
S        }
S
S        servername_list_size -= hostname_len + 3;
S        p += hostname_len + 3;
S    }
S
S    if( servername_list_size != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
S
Sstatic int ssl_parse_renegotiation_info( mbedtls_ssl_context *ssl,
S                                         const unsigned char *buf,
S                                         size_t len )
S{
S    int ret;
S
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
S    {
S        /* Check verify-data in constant-time. The length OTOH is no secret */
S        if( len    != 1 + ssl->verify_data_len ||
S            buf[0] !=     ssl->verify_data_len ||
S            mbedtls_ssl_safer_memcmp( buf + 1, ssl->peer_verify_data,
S                          ssl->verify_data_len ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching renegotiation info" ) );
S
S            if( ( ret = mbedtls_ssl_send_fatal_handshake_failure( ssl ) ) != 0 )
S                return( ret );
S
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S    }
S    else
S#endif /* MBEDTLS_SSL_RENEGOTIATION */
S    {
S        if( len != 1 || buf[0] != 0x0 )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-zero length renegotiation info" ) );
S
S            if( ( ret = mbedtls_ssl_send_fatal_handshake_failure( ssl ) ) != 0 )
S                return( ret );
S
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S
S        ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
S    }
S
S    return( 0 );
S}
S
S#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
S    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
X#if defined(MBEDTLS_SSL_PROTO_TLS1_2) &&     defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
Sstatic int ssl_parse_signature_algorithms_ext( mbedtls_ssl_context *ssl,
S                                               const unsigned char *buf,
S                                               size_t len )
S{
S    size_t sig_alg_list_size;
S    const unsigned char *p;
S    const unsigned char *end = buf + len;
S    const int *md_cur;
S
S
S    sig_alg_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
S    if( sig_alg_list_size + 2 != len ||
S        sig_alg_list_size % 2 != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    /*
S     * For now, ignore the SignatureAlgorithm part and rely on offered
S     * ciphersuites only for that part. To be fixed later.
S     *
S     * So, just look at the HashAlgorithm part.
S     */
S    for( md_cur = ssl->conf->sig_hashes; *md_cur != MBEDTLS_MD_NONE; md_cur++ ) {
S        for( p = buf + 2; p < end; p += 2 ) {
S            if( *md_cur == (int) mbedtls_ssl_md_alg_from_hash( p[0] ) ) {
S                ssl->handshake->sig_alg = p[0];
S                goto have_sig_alg;
S            }
S        }
S    }
S
S    /* Some key echanges do not need signatures at all */
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "no signature_algorithm in common" ) );
S    return( 0 );
S
Shave_sig_alg:
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext: %d",
S                   ssl->handshake->sig_alg ) );
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
S          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
S
S#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
S    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
X#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) ||     defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
Sstatic int ssl_parse_supported_elliptic_curves( mbedtls_ssl_context *ssl,
S                                                const unsigned char *buf,
S                                                size_t len )
S{
S    size_t list_size, our_size;
S    const unsigned char *p;
S    const mbedtls_ecp_curve_info *curve_info, **curves;
S
S    list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
S    if( list_size + 2 != len ||
S        list_size % 2 != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    /* Should never happen unless client duplicates the extension */
S    if( ssl->handshake->curves != NULL )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    /* Don't allow our peer to make us allocate too much memory,
S     * and leave room for a final 0 */
S    our_size = list_size / 2 + 1;
S    if( our_size > MBEDTLS_ECP_DP_MAX )
S        our_size = MBEDTLS_ECP_DP_MAX;
S
S    if( ( curves = mbedtls_calloc( our_size, sizeof( *curves ) ) ) == NULL )
S        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
S
S    ssl->handshake->curves = curves;
S
S    p = buf + 2;
S    while( list_size > 0 && our_size > 1 )
S    {
S        curve_info = mbedtls_ecp_curve_info_from_tls_id( ( p[0] << 8 ) | p[1] );
S
S        if( curve_info != NULL )
S        {
S            *curves++ = curve_info;
S            our_size--;
S        }
S
S        list_size -= 2;
S        p += 2;
S    }
S
S    return( 0 );
S}
S
Sstatic int ssl_parse_supported_point_formats( mbedtls_ssl_context *ssl,
S                                              const unsigned char *buf,
S                                              size_t len )
S{
S    size_t list_size;
S    const unsigned char *p;
S
S    list_size = buf[0];
S    if( list_size + 1 != len )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    p = buf + 1;
S    while( list_size > 0 )
S    {
S        if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||
S            p[0] == MBEDTLS_ECP_PF_COMPRESSED )
S        {
S#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)
S            ssl->handshake->ecdh_ctx.point_format = p[0];
S#endif
S#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
S            ssl->handshake->ecjpake_ctx.point_format = p[0];
S#endif
S            MBEDTLS_SSL_DEBUG_MSG( 4, ( "point format selected: %d", p[0] ) );
S            return( 0 );
S        }
S
S        list_size--;
S        p++;
S    }
S
S    return( 0 );
S}
S#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||
S          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
Sstatic int ssl_parse_ecjpake_kkpp( mbedtls_ssl_context *ssl,
S                                   const unsigned char *buf,
S                                   size_t len )
S{
S    int ret;
S
S    if( mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "skip ecjpake kkpp extension" ) );
S        return( 0 );
S    }
S
S    if( ( ret = mbedtls_ecjpake_read_round_one( &ssl->handshake->ecjpake_ctx,
S                                                buf, len ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_read_round_one", ret );
S        return( ret );
S    }
S
S    /* Only mark the extension as OK when we're sure it is */
S    ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK;
S
S    return( 0 );
S}
S#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
S
S#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
Sstatic int ssl_parse_max_fragment_length_ext( mbedtls_ssl_context *ssl,
S                                              const unsigned char *buf,
S                                              size_t len )
S{
S    if( len != 1 || buf[0] >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    ssl->session_negotiate->mfl_code = buf[0];
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
S
S#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
Sstatic int ssl_parse_truncated_hmac_ext( mbedtls_ssl_context *ssl,
S                                         const unsigned char *buf,
S                                         size_t len )
S{
S    if( len != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    ((void) buf);
S
S    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )
S        ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
S
S#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
Sstatic int ssl_parse_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
S                                      const unsigned char *buf,
S                                      size_t len )
S{
S    if( len != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    ((void) buf);
S
S    if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED &&
S        ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
S    {
S        ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
S    }
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
S
S#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
Sstatic int ssl_parse_extended_ms_ext( mbedtls_ssl_context *ssl,
S                                      const unsigned char *buf,
S                                      size_t len )
S{
S    if( len != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    ((void) buf);
S
S    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED &&
S        ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
S    {
S        ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
S    }
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
S
S#if defined(MBEDTLS_SSL_SESSION_TICKETS)
Sstatic int ssl_parse_session_ticket_ext( mbedtls_ssl_context *ssl,
S                                         unsigned char *buf,
S                                         size_t len )
S{
S    int ret;
S    mbedtls_ssl_session session;
S
S    mbedtls_ssl_session_init( &session );
S
S    if( ssl->conf->f_ticket_parse == NULL ||
S        ssl->conf->f_ticket_write == NULL )
S    {
S        return( 0 );
S    }
S
S    /* Remember the client asked us to send a new ticket */
S    ssl->handshake->new_session_ticket = 1;
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket length: %d", len ) );
S
S    if( len == 0 )
S        return( 0 );
S
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket rejected: renegotiating" ) );
S        return( 0 );
S    }
S#endif /* MBEDTLS_SSL_RENEGOTIATION */
S
S    /*
S     * Failures are ok: just ignore the ticket and proceed.
S     */
S    if( ( ret = ssl->conf->f_ticket_parse( ssl->conf->p_ticket, &session,
S                                           buf, len ) ) != 0 )
S    {
S        mbedtls_ssl_session_free( &session );
S
S        if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket is not authentic" ) );
S        else if( ret == MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED )
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket is expired" ) );
S        else
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_parse", ret );
S
S        return( 0 );
S    }
S
S    /*
S     * Keep the session ID sent by the client, since we MUST send it back to
S     * inform them we're accepting the ticket  (RFC 5077 section 3.4)
S     */
S    session.id_len = ssl->session_negotiate->id_len;
S    memcpy( &session.id, ssl->session_negotiate->id, session.id_len );
S
S    mbedtls_ssl_session_free( ssl->session_negotiate );
S    memcpy( ssl->session_negotiate, &session, sizeof( mbedtls_ssl_session ) );
S
S    /* Zeroize instead of free as we copied the content */
S    mbedtls_zeroize( &session, sizeof( mbedtls_ssl_session ) );
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "session successfully restored from ticket" ) );
S
S    ssl->handshake->resume = 1;
S
S    /* Don't send a new ticket after all, this one is OK */
S    ssl->handshake->new_session_ticket = 0;
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_SESSION_TICKETS */
S
S#if defined(MBEDTLS_SSL_ALPN)
Sstatic int ssl_parse_alpn_ext( mbedtls_ssl_context *ssl,
S                               const unsigned char *buf, size_t len )
S{
S    size_t list_len, cur_len, ours_len;
S    const unsigned char *theirs, *start, *end;
S    const char **ours;
S
S    /* If ALPN not configured, just ignore the extension */
S    if( ssl->conf->alpn_list == NULL )
S        return( 0 );
S
S    /*
S     * opaque ProtocolName<1..2^8-1>;
S     *
S     * struct {
S     *     ProtocolName protocol_name_list<2..2^16-1>
S     * } ProtocolNameList;
S     */
S
S    /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */
S    if( len < 4 )
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S
S    list_len = ( buf[0] << 8 ) | buf[1];
S    if( list_len != len - 2 )
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S
S    /*
S     * Use our order of preference
S     */
S    start = buf + 2;
S    end = buf + len;
S    for( ours = ssl->conf->alpn_list; *ours != NULL; ours++ )
S    {
S        ours_len = strlen( *ours );
S        for( theirs = start; theirs != end; theirs += cur_len )
S        {
S            /* If the list is well formed, we should get equality first */
S            if( theirs > end )
S                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S
S            cur_len = *theirs++;
S
S            /* Empty strings MUST NOT be included */
S            if( cur_len == 0 )
S                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S
S            if( cur_len == ours_len &&
S                memcmp( theirs, *ours, cur_len ) == 0 )
S            {
S                ssl->alpn_chosen = *ours;
S                return( 0 );
S            }
S        }
S    }
S
S    /* If we get there, no match was found */
S    mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
S                            MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL );
S    return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S}
S#endif /* MBEDTLS_SSL_ALPN */
S
S/*
S * Auxiliary functions for ServerHello parsing and related actions
S */
S
S#if defined(MBEDTLS_X509_CRT_PARSE_C)
S/*
S * Return 0 if the given key uses one of the acceptable curves, -1 otherwise
S */
S#if defined(MBEDTLS_ECDSA_C)
Sstatic int ssl_check_key_curve( mbedtls_pk_context *pk,
S                                const mbedtls_ecp_curve_info **curves )
S{
S    const mbedtls_ecp_curve_info **crv = curves;
S    mbedtls_ecp_group_id grp_id = mbedtls_pk_ec( *pk )->grp.id;
S
S    while( *crv != NULL )
S    {
S        if( (*crv)->grp_id == grp_id )
S            return( 0 );
S        crv++;
S    }
S
S    return( -1 );
S}
S#endif /* MBEDTLS_ECDSA_C */
S
S/*
S * Try picking a certificate for this ciphersuite,
S * return 0 on success and -1 on failure.
S */
Sstatic int ssl_pick_cert( mbedtls_ssl_context *ssl,
S                          const mbedtls_ssl_ciphersuite_t * ciphersuite_info )
S{
S    mbedtls_ssl_key_cert *cur, *list, *fallback = NULL;
S    mbedtls_pk_type_t pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );
S    uint32_t flags;
S
S#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
S    if( ssl->handshake->sni_key_cert != NULL )
S        list = ssl->handshake->sni_key_cert;
S    else
S#endif
S        list = ssl->conf->key_cert;
S
S    if( pk_alg == MBEDTLS_PK_NONE )
S        return( 0 );
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite requires certificate" ) );
S
S    if( list == NULL )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "server has no certificate" ) );
S        return( -1 );
S    }
S
S    for( cur = list; cur != NULL; cur = cur->next )
S    {
S        MBEDTLS_SSL_DEBUG_CRT( 3, "candidate certificate chain, certificate",
S                          cur->cert );
S
S        if( ! mbedtls_pk_can_do( cur->key, pk_alg ) )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: key type" ) );
S            continue;
S        }
S
S        /*
S         * This avoids sending the client a cert it'll reject based on
S         * keyUsage or other extensions.
S         *
S         * It also allows the user to provision different certificates for
S         * different uses based on keyUsage, eg if they want to avoid signing
S         * and decrypting with the same RSA key.
S         */
S        if( mbedtls_ssl_check_cert_usage( cur->cert, ciphersuite_info,
S                                  MBEDTLS_SSL_IS_SERVER, &flags ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: "
S                                "(extended) key usage extension" ) );
S            continue;
S        }
S
S#if defined(MBEDTLS_ECDSA_C)
S        if( pk_alg == MBEDTLS_PK_ECDSA &&
S            ssl_check_key_curve( cur->key, ssl->handshake->curves ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: elliptic curve" ) );
S            continue;
S        }
S#endif
S
S        /*
S         * Try to select a SHA-1 certificate for pre-1.2 clients, but still
S         * present them a SHA-higher cert rather than failing if it's the only
S         * one we got that satisfies the other conditions.
S         */
S        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 &&
S            cur->cert->sig_md != MBEDTLS_MD_SHA1 )
S        {
S            if( fallback == NULL )
S                fallback = cur;
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate not preferred: "
S                                    "sha-2 with pre-TLS 1.2 client" ) );
S            continue;
S            }
S        }
S
S        /* If we get there, we got a winner */
S        break;
S    }
S
S    if( cur == NULL )
S        cur = fallback;
S
S    /* Do not update ssl->handshake->key_cert unless there is a match */
S    if( cur != NULL )
S    {
S        ssl->handshake->key_cert = cur;
S        MBEDTLS_SSL_DEBUG_CRT( 3, "selected certificate chain, certificate",
S                          ssl->handshake->key_cert->cert );
S        return( 0 );
S    }
S
S    return( -1 );
S}
S#endif /* MBEDTLS_X509_CRT_PARSE_C */
S
S/*
S * Check if a given ciphersuite is suitable for use with our config/keys/etc
S * Sets ciphersuite_info only if the suite matches.
S */
Sstatic int ssl_ciphersuite_match( mbedtls_ssl_context *ssl, int suite_id,
S                                  const mbedtls_ssl_ciphersuite_t **ciphersuite_info )
S{
S    const mbedtls_ssl_ciphersuite_t *suite_info;
S
S    suite_info = mbedtls_ssl_ciphersuite_from_id( suite_id );
S    if( suite_info == NULL )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
S        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "trying ciphersuite: %s", suite_info->name ) );
S
S    if( suite_info->min_minor_ver > ssl->minor_ver ||
S        suite_info->max_minor_ver < ssl->minor_ver )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: version" ) );
S        return( 0 );
S    }
S
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
S        ( suite_info->flags & MBEDTLS_CIPHERSUITE_NODTLS ) )
S        return( 0 );
S#endif
S
S#if defined(MBEDTLS_ARC4_C)
S    if( ssl->conf->arc4_disabled == MBEDTLS_SSL_ARC4_DISABLED &&
S            suite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: rc4" ) );
S        return( 0 );
S    }
S#endif
S
S#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
S    if( suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&
S        ( ssl->handshake->cli_exts & MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK ) == 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: ecjpake "
S                                    "not configured or ext missing" ) );
S        return( 0 );
S    }
S#endif
S
S
S#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)
S    if( mbedtls_ssl_ciphersuite_uses_ec( suite_info ) &&
S        ( ssl->handshake->curves == NULL ||
S          ssl->handshake->curves[0] == NULL ) )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: "
S                            "no common elliptic curve" ) );
S        return( 0 );
S    }
S#endif
S
S#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
S    /* If the ciphersuite requires a pre-shared key and we don't
S     * have one, skip it now rather than failing later */
S    if( mbedtls_ssl_ciphersuite_uses_psk( suite_info ) &&
S        ssl->conf->f_psk == NULL &&
S        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
S          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: no pre-shared key" ) );
S        return( 0 );
S    }
S#endif
S
S#if defined(MBEDTLS_X509_CRT_PARSE_C)
S    /*
S     * Final check: if ciphersuite requires us to have a
S     * certificate/key of a particular type:
S     * - select the appropriate certificate if we have one, or
S     * - try the next ciphersuite if we don't
S     * This must be done last since we modify the key_cert list.
S     */
S    if( ssl_pick_cert( ssl, suite_info ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: "
S                            "no suitable certificate" ) );
S        return( 0 );
S    }
S#endif
S
S    *ciphersuite_info = suite_info;
S    return( 0 );
S}
S
S#if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)
Sstatic int ssl_parse_client_hello_v2( mbedtls_ssl_context *ssl )
S{
S    int ret, got_common_suite;
S    unsigned int i, j;
S    size_t n;
S    unsigned int ciph_len, sess_len, chal_len;
S    unsigned char *buf, *p;
S    const int *ciphersuites;
S    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client hello v2" ) );
S
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "client hello v2 illegal for renegotiation" ) );
S
S        if( ( ret = mbedtls_ssl_send_fatal_handshake_failure( ssl ) ) != 0 )
S            return( ret );
S
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S#endif /* MBEDTLS_SSL_RENEGOTIATION */
S
S    buf = ssl->in_hdr;
S
S    MBEDTLS_SSL_DEBUG_BUF( 4, "record header", buf, 5 );
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, message type: %d",
S                   buf[2] ) );
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, message len.: %d",
S                   ( ( buf[0] & 0x7F ) << 8 ) | buf[1] ) );
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, max. version: [%d:%d]",
S                   buf[3], buf[4] ) );
S
S    /*
S     * SSLv2 Client Hello
S     *
S     * Record layer:
S     *     0  .   1   message length
S     *
S     * SSL layer:
S     *     2  .   2   message type
S     *     3  .   4   protocol version
S     */
S    if( buf[2] != MBEDTLS_SSL_HS_CLIENT_HELLO ||
S        buf[3] != MBEDTLS_SSL_MAJOR_VERSION_3 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    n = ( ( buf[0] << 8 ) | buf[1] ) & 0x7FFF;
S
S    if( n < 17 || n > 512 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    ssl->major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;
S    ssl->minor_ver = ( buf[4] <= ssl->conf->max_minor_ver )
S                     ? buf[4]  : ssl->conf->max_minor_ver;
S
S    if( ssl->minor_ver < ssl->conf->min_minor_ver )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "client only supports ssl smaller than minimum"
S                            " [%d:%d] < [%d:%d]",
S                            ssl->major_ver, ssl->minor_ver,
S                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );
S
S        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
S                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
S        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );
S    }
S
S    ssl->handshake->max_major_ver = buf[3];
S    ssl->handshake->max_minor_ver = buf[4];
S
S    if( ( ret = mbedtls_ssl_fetch_input( ssl, 2 + n ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
S        return( ret );
S    }
S
S    ssl->handshake->update_checksum( ssl, buf + 2, n );
S
S    buf = ssl->in_msg;
S    n = ssl->in_left - 5;
S
S    /*
S     *    0  .   1   ciphersuitelist length
S     *    2  .   3   session id length
S     *    4  .   5   challenge length
S     *    6  .  ..   ciphersuitelist
S     *   ..  .  ..   session id
S     *   ..  .  ..   challenge
S     */
S    MBEDTLS_SSL_DEBUG_BUF( 4, "record contents", buf, n );
S
S    ciph_len = ( buf[0] << 8 ) | buf[1];
S    sess_len = ( buf[2] << 8 ) | buf[3];
S    chal_len = ( buf[4] << 8 ) | buf[5];
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciph_len: %d, sess_len: %d, chal_len: %d",
S                   ciph_len, sess_len, chal_len ) );
S
S    /*
S     * Make sure each parameter length is valid
S     */
S    if( ciph_len < 3 || ( ciph_len % 3 ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    if( sess_len > 32 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    if( chal_len < 8 || chal_len > 32 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    if( n != 6 + ciph_len + sess_len + chal_len )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, ciphersuitelist",
S                   buf + 6, ciph_len );
S    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, session id",
S                   buf + 6 + ciph_len, sess_len );
S    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, challenge",
S                   buf + 6 + ciph_len + sess_len, chal_len );
S
S    p = buf + 6 + ciph_len;
S    ssl->session_negotiate->id_len = sess_len;
S    memset( ssl->session_negotiate->id, 0,
S            sizeof( ssl->session_negotiate->id ) );
S    memcpy( ssl->session_negotiate->id, p, ssl->session_negotiate->id_len );
S
S    p += sess_len;
S    memset( ssl->handshake->randbytes, 0, 64 );
S    memcpy( ssl->handshake->randbytes + 32 - chal_len, p, chal_len );
S
S    /*
S     * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
S     */
S    for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )
S    {
S        if( p[0] == 0 && p[1] == 0 && p[2] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "received TLS_EMPTY_RENEGOTIATION_INFO " ) );
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S            if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 1, ( "received RENEGOTIATION SCSV "
S                                    "during renegotiation" ) );
S
S                if( ( ret = mbedtls_ssl_send_fatal_handshake_failure( ssl ) ) != 0 )
S                    return( ret );
S
S                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S            }
S#endif /* MBEDTLS_SSL_RENEGOTIATION */
S            ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
S            break;
S        }
S    }
S
S#if defined(MBEDTLS_SSL_FALLBACK_SCSV)
S    for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )
S    {
S        if( p[0] == 0 &&
S            p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&
S            p[2] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "received FALLBACK_SCSV" ) );
S
S            if( ssl->minor_ver < ssl->conf->max_minor_ver )
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 1, ( "inapropriate fallback" ) );
S
S                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
S                                        MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );
S
S                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S            }
S
S            break;
S        }
S    }
S#endif /* MBEDTLS_SSL_FALLBACK_SCSV */
S
S    got_common_suite = 0;
S    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];
S    ciphersuite_info = NULL;
S#if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)
S    for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )
S    {
S        for( i = 0; ciphersuites[i] != 0; i++ )
S#else
S    for( i = 0; ciphersuites[i] != 0; i++ )
S    {
S        for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )
S#endif
S        {
S            if( p[0] != 0 ||
S                p[1] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||
S                p[2] != ( ( ciphersuites[i]      ) & 0xFF ) )
S                continue;
S
S            got_common_suite = 1;
S
S            if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],
S                                               &ciphersuite_info ) ) != 0 )
S                return( ret );
S
S            if( ciphersuite_info != NULL )
S                goto have_ciphersuite_v2;
S        }
S    }
S
S    if( got_common_suite )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got ciphersuites in common, "
S                            "but none of them usable" ) );
S        return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );
S    }
S    else
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no ciphersuites in common" ) );
S        return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
S    }
S
Shave_ciphersuite_v2:
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "selected ciphersuite: %s", ciphersuite_info->name ) );
S
S    ssl->session_negotiate->ciphersuite = ciphersuites[i];
S    ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;
S    mbedtls_ssl_optimize_checksum( ssl, ssl->transform_negotiate->ciphersuite_info );
S
S    /*
S     * SSLv2 Client Hello relevant renegotiation security checks
S     */
S    if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
S        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
S
S        if( ( ret = mbedtls_ssl_send_fatal_handshake_failure( ssl ) ) != 0 )
S            return( ret );
S
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    ssl->in_left = 0;
S    ssl->state++;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client hello v2" ) );
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO */
S
Sstatic int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
S{
S    int ret, got_common_suite;
S    size_t i, j;
S    size_t ciph_offset, comp_offset, ext_offset;
S    size_t msg_len, ciph_len, sess_len, comp_len, ext_len;
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    size_t cookie_offset, cookie_len;
S#endif
S    unsigned char *buf, *p, *ext;
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S    int renegotiation_info_seen = 0;
S#endif
S    int handshake_failure = 0;
S    const int *ciphersuites;
S    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
S    int major, minor;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client hello" ) );
S
S#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
Sread_record_header:
S#endif
S    /*
S     * If renegotiating, then the input was read with mbedtls_ssl_read_record(),
S     * otherwise read it ourselves manually in order to support SSLv2
S     * ClientHello, which doesn't use the same record layer format.
S     */
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )
S#endif
S    {
S        if( ( ret = mbedtls_ssl_fetch_input( ssl, 5 ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
S            return( ret );
S        }
S    }
S
S    buf = ssl->in_hdr;
S
S#if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_STREAM )
S#endif
S        if( ( buf[0] & 0x80 ) != 0 )
S            return ssl_parse_client_hello_v2( ssl );
S#endif
S
S    MBEDTLS_SSL_DEBUG_BUF( 4, "record header", buf, mbedtls_ssl_hdr_len( ssl ) );
S
S    /*
S     * SSLv3/TLS Client Hello
S     *
S     * Record layer:
S     *     0  .   0   message type
S     *     1  .   2   protocol version
S     *     3  .   11  DTLS: epoch + record sequence number
S     *     3  .   4   message length
S     */
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, message type: %d",
S                   buf[0] ) );
S
S    if( buf[0] != MBEDTLS_SSL_MSG_HANDSHAKE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, message len.: %d",
S                   ( ssl->in_len[0] << 8 ) | ssl->in_len[1] ) );
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, protocol version: [%d:%d]",
S                   buf[1], buf[2] ) );
S
S    mbedtls_ssl_read_version( &major, &minor, ssl->conf->transport, buf + 1 );
S
S    /* According to RFC 5246 Appendix E.1, the version here is typically
S     * "{03,00}, the lowest version number supported by the client, [or] the
S     * value of ClientHello.client_version", so the only meaningful check here
S     * is the major version shouldn't be less than 3 */
S    if( major < MBEDTLS_SSL_MAJOR_VERSION_3 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    /* For DTLS if this is the initial handshake, remember the client sequence
S     * number to use it in our next message (RFC 6347 4.2.1) */
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S        && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
S#endif
S        )
S    {
S        /* Epoch should be 0 for initial handshakes */
S        if( ssl->in_ctr[0] != 0 || ssl->in_ctr[1] != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S
S        memcpy( ssl->out_ctr + 2, ssl->in_ctr + 2, 6 );
S
S#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
S        if( mbedtls_ssl_dtls_replay_check( ssl ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "replayed record, discarding" ) );
S            ssl->next_record_offset = 0;
S            ssl->in_left = 0;
S            goto read_record_header;
S        }
S
S        /* No MAC to check yet, so we can update right now */
S        mbedtls_ssl_dtls_replay_update( ssl );
S#endif
S    }
S#endif /* MBEDTLS_SSL_PROTO_DTLS */
S
S    msg_len = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
S
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
S    {
S        /* Set by mbedtls_ssl_read_record() */
S        msg_len = ssl->in_hslen;
S    }
S    else
S#endif
S    {
S        if( msg_len > MBEDTLS_SSL_MAX_CONTENT_LEN )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S
S        if( ( ret = mbedtls_ssl_fetch_input( ssl, mbedtls_ssl_hdr_len( ssl ) + msg_len ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
S            return( ret );
S        }
S
S    /* Done reading this record, get ready for the next one */
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S        if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
S            ssl->next_record_offset = msg_len + mbedtls_ssl_hdr_len( ssl );
S        else
S#endif
S            ssl->in_left = 0;
S    }
S
S    buf = ssl->in_msg;
S
S    MBEDTLS_SSL_DEBUG_BUF( 4, "record contents", buf, msg_len );
S
S    ssl->handshake->update_checksum( ssl, buf, msg_len );
S
S    /*
S     * Handshake layer:
S     *     0  .   0   handshake type
S     *     1  .   3   handshake length
S     *     4  .   5   DTLS only: message seqence number
S     *     6  .   8   DTLS only: fragment offset
S     *     9  .  11   DTLS only: fragment length
S     */
S    if( msg_len < mbedtls_ssl_hs_hdr_len( ssl ) )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, handshake type: %d", buf[0] ) );
S
S    if( buf[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, handshake len.: %d",
S                   ( buf[1] << 16 ) | ( buf[2] << 8 ) | buf[3] ) );
S
S    /* We don't support fragmentation of ClientHello (yet?) */
S    if( buf[1] != 0 ||
S        msg_len != mbedtls_ssl_hs_hdr_len( ssl ) + ( ( buf[2] << 8 ) | buf[3] ) )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
S    {
S        /*
S         * Copy the client's handshake message_seq on initial handshakes,
S         * check sequence number on renego.
S         */
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S        if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
S        {
S            /* This couldn't be done in ssl_prepare_handshake_record() */
S            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
S                                         ssl->in_msg[5];
S
S            if( cli_msg_seq != ssl->handshake->in_msg_seq )
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message_seq: "
S                                    "%d (expected %d)", cli_msg_seq,
S                                    ssl->handshake->in_msg_seq ) );
S                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S            }
S
S            ssl->handshake->in_msg_seq++;
S        }
S        else
S#endif
S        {
S            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
S                                         ssl->in_msg[5];
S            ssl->handshake->out_msg_seq = cli_msg_seq;
S            ssl->handshake->in_msg_seq  = cli_msg_seq + 1;
S        }
S
S        /*
S         * For now we don't support fragmentation, so make sure
S         * fragment_offset == 0 and fragment_length == length
S         */
S        if( ssl->in_msg[6] != 0 || ssl->in_msg[7] != 0 || ssl->in_msg[8] != 0 ||
S            memcmp( ssl->in_msg + 1, ssl->in_msg + 9, 3 ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "ClientHello fragmentation not supported" ) );
S            return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
S        }
S    }
S#endif /* MBEDTLS_SSL_PROTO_DTLS */
S
S    buf += mbedtls_ssl_hs_hdr_len( ssl );
S    msg_len -= mbedtls_ssl_hs_hdr_len( ssl );
S
S    /*
S     * ClientHello layer:
S     *     0  .   1   protocol version
S     *     2  .  33   random bytes (starting with 4 bytes of Unix time)
S     *    34  .  35   session id length (1 byte)
S     *    35  . 34+x  session id
S     *   35+x . 35+x  DTLS only: cookie length (1 byte)
S     *   36+x .  ..   DTLS only: cookie
S     *    ..  .  ..   ciphersuite list length (2 bytes)
S     *    ..  .  ..   ciphersuite list
S     *    ..  .  ..   compression alg. list length (1 byte)
S     *    ..  .  ..   compression alg. list
S     *    ..  .  ..   extensions length (2 bytes, optional)
S     *    ..  .  ..   extensions (optional)
S     */
S
S    /*
S     * Minimal length (with everything empty and extensions ommitted) is
S     * 2 + 32 + 1 + 2 + 1 = 38 bytes. Check that first, so that we can
S     * read at least up to session id length without worrying.
S     */
S    if( msg_len < 38 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    /*
S     * Check and save the protocol version
S     */
S    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, version", buf, 2 );
S
S    mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,
S                      ssl->conf->transport, buf );
S
S    ssl->handshake->max_major_ver = ssl->major_ver;
S    ssl->handshake->max_minor_ver = ssl->minor_ver;
S
S    if( ssl->major_ver < ssl->conf->min_major_ver ||
S        ssl->minor_ver < ssl->conf->min_minor_ver )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "client only supports ssl smaller than minimum"
S                            " [%d:%d] < [%d:%d]",
S                            ssl->major_ver, ssl->minor_ver,
S                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );
S
S        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
S                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
S
S        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );
S    }
S
S    if( ssl->major_ver > ssl->conf->max_major_ver )
S    {
S        ssl->major_ver = ssl->conf->max_major_ver;
S        ssl->minor_ver = ssl->conf->max_minor_ver;
S    }
S    else if( ssl->minor_ver > ssl->conf->max_minor_ver )
S        ssl->minor_ver = ssl->conf->max_minor_ver;
S
S    /*
S     * Save client random (inc. Unix time)
S     */
S    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, random bytes", buf + 2, 32 );
S
S    memcpy( ssl->handshake->randbytes, buf + 2, 32 );
S
S    /*
S     * Check the session ID length and save session ID
S     */
S    sess_len = buf[34];
S
S    if( sess_len > sizeof( ssl->session_negotiate->id ) ||
S        sess_len + 34 + 2 > msg_len ) /* 2 for cipherlist length field */
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, session id", buf + 35, sess_len );
S
S    ssl->session_negotiate->id_len = sess_len;
S    memset( ssl->session_negotiate->id, 0,
S            sizeof( ssl->session_negotiate->id ) );
S    memcpy( ssl->session_negotiate->id, buf + 35,
S            ssl->session_negotiate->id_len );
S
S    /*
S     * Check the cookie length and content
S     */
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
S    {
S        cookie_offset = 35 + sess_len;
S        cookie_len = buf[cookie_offset];
S
S        if( cookie_offset + 1 + cookie_len + 2 > msg_len )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S
S        MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, cookie",
S                       buf + cookie_offset + 1, cookie_len );
S
S#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
S        if( ssl->conf->f_cookie_check != NULL
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S            && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
S#endif
S            )
S        {
S            if( ssl->conf->f_cookie_check( ssl->conf->p_cookie,
S                                     buf + cookie_offset + 1, cookie_len,
S                                     ssl->cli_id, ssl->cli_id_len ) != 0 )
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification failed" ) );
S                ssl->handshake->verify_cookie_len = 1;
S            }
S            else
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification passed" ) );
S                ssl->handshake->verify_cookie_len = 0;
S            }
S        }
S        else
S#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
S        {
S            /* We know we didn't send a cookie, so it should be empty */
S            if( cookie_len != 0 )
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S            }
S
S            MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification skipped" ) );
S        }
S
S    /*
S     * Check the ciphersuitelist length (will be parsed later)
S     */
S        ciph_offset = cookie_offset + 1 + cookie_len;
S    }
S    else
S#endif /* MBEDTLS_SSL_PROTO_DTLS */
S        ciph_offset = 35 + sess_len;
S
S    ciph_len = ( buf[ciph_offset + 0] << 8 )
S             | ( buf[ciph_offset + 1]      );
S
S    if( ciph_len < 2 ||
S        ciph_len + 2 + ciph_offset + 1 > msg_len || /* 1 for comp. alg. len */
S        ( ciph_len % 2 ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, ciphersuitelist",
S                   buf + ciph_offset + 2,  ciph_len );
S
S    /*
S     * Check the compression algorithms length and pick one
S     */
S    comp_offset = ciph_offset + 2 + ciph_len;
S
S    comp_len = buf[comp_offset];
S
S    if( comp_len < 1 ||
S        comp_len > 16 ||
S        comp_len + comp_offset + 1 > msg_len )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, compression",
S                      buf + comp_offset + 1, comp_len );
S
S    ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;
S#if defined(MBEDTLS_ZLIB_SUPPORT)
S    for( i = 0; i < comp_len; ++i )
S    {
S        if( buf[comp_offset + 1 + i] == MBEDTLS_SSL_COMPRESS_DEFLATE )
S        {
S            ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_DEFLATE;
S            break;
S        }
S    }
S#endif
S
S    /* See comments in ssl_write_client_hello() */
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
S        ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;
S#endif
S
S    /*
S     * Check the extension length
S     */
S    ext_offset = comp_offset + 1 + comp_len;
S    if( msg_len > ext_offset )
S    {
S        if( msg_len < ext_offset + 2 )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S
S        ext_len = ( buf[ext_offset + 0] << 8 )
S                | ( buf[ext_offset + 1]      );
S
S        if( ( ext_len > 0 && ext_len < 4 ) ||
S            msg_len != ext_offset + 2 + ext_len )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S    }
S    else
S        ext_len = 0;
S
S    ext = buf + ext_offset + 2;
S    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello extensions", ext, ext_len );
S
S    while( ext_len != 0 )
S    {
S        unsigned int ext_id   = ( ( ext[0] <<  8 )
S                                | ( ext[1]       ) );
S        unsigned int ext_size = ( ( ext[2] <<  8 )
S                                | ( ext[3]       ) );
S
S        if( ext_size + 4 > ext_len )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S        switch( ext_id )
S        {
S#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
S        case MBEDTLS_TLS_EXT_SERVERNAME:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found ServerName extension" ) );
S            if( ssl->conf->f_sni == NULL )
S                break;
S
S            ret = ssl_parse_servername_ext( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
S
S        case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found renegotiation extension" ) );
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S            renegotiation_info_seen = 1;
S#endif
S
S            ret = ssl_parse_renegotiation_info( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S
S#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
S    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
X#if defined(MBEDTLS_SSL_PROTO_TLS1_2) &&     defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
S        case MBEDTLS_TLS_EXT_SIG_ALG:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found signature_algorithms extension" ) );
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S            if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
S                break;
S#endif
S
S            ret = ssl_parse_signature_algorithms_ext( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
S          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
S
S#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
S    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
X#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) ||     defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
S        case MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found supported elliptic curves extension" ) );
S
S            ret = ssl_parse_supported_elliptic_curves( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S
S        case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found supported point formats extension" ) );
S            ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT;
S
S            ret = ssl_parse_supported_point_formats( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||
S          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
S        case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found ecjpake kkpp extension" ) );
S
S            ret = ssl_parse_ecjpake_kkpp( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
S
S#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
S        case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found max fragment length extension" ) );
S
S            ret = ssl_parse_max_fragment_length_ext( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
S
S#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
S        case MBEDTLS_TLS_EXT_TRUNCATED_HMAC:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found truncated hmac extension" ) );
S
S            ret = ssl_parse_truncated_hmac_ext( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
S
S#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
S        case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found encrypt then mac extension" ) );
S
S            ret = ssl_parse_encrypt_then_mac_ext( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
S
S#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
S        case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found extended master secret extension" ) );
S
S            ret = ssl_parse_extended_ms_ext( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
S
S#if defined(MBEDTLS_SSL_SESSION_TICKETS)
S        case MBEDTLS_TLS_EXT_SESSION_TICKET:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found session ticket extension" ) );
S
S            ret = ssl_parse_session_ticket_ext( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_SSL_SESSION_TICKETS */
S
S#if defined(MBEDTLS_SSL_ALPN)
S        case MBEDTLS_TLS_EXT_ALPN:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "found alpn extension" ) );
S
S            ret = ssl_parse_alpn_ext( ssl, ext + 4, ext_size );
S            if( ret != 0 )
S                return( ret );
S            break;
S#endif /* MBEDTLS_SSL_SESSION_TICKETS */
S
S        default:
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "unknown extension found: %d (ignoring)",
S                           ext_id ) );
S        }
S
S        ext_len -= 4 + ext_size;
S        ext += 4 + ext_size;
S
S        if( ext_len > 0 && ext_len < 4 )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S        }
S    }
S
S#if defined(MBEDTLS_SSL_FALLBACK_SCSV)
S    for( i = 0, p = buf + 41 + sess_len; i < ciph_len; i += 2, p += 2 )
S    {
S        if( p[0] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&
S            p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 2, ( "received FALLBACK_SCSV" ) );
S
S            if( ssl->minor_ver < ssl->conf->max_minor_ver )
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 1, ( "inapropriate fallback" ) );
S
S                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
S                                        MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );
S
S                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S            }
S
S            break;
S        }
S    }
S#endif /* MBEDTLS_SSL_FALLBACK_SCSV */
S
S    /*
S     * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
S     */
S    for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )
S    {
S        if( p[0] == 0 && p[1] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 3, ( "received TLS_EMPTY_RENEGOTIATION_INFO " ) );
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S            if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 1, ( "received RENEGOTIATION SCSV during renegotiation" ) );
S
S                if( ( ret = mbedtls_ssl_send_fatal_handshake_failure( ssl ) ) != 0 )
S                    return( ret );
S
S                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S            }
S#endif
S            ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
S            break;
S        }
S    }
S
S    /*
S     * Renegotiation security checks
S     */
S    if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION &&
S        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
S        handshake_failure = 1;
S    }
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
S             ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&
S             renegotiation_info_seen == 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension missing (secure)" ) );
S        handshake_failure = 1;
S    }
S    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
S             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
S             ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation not allowed" ) );
S        handshake_failure = 1;
S    }
S    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
S             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
S             renegotiation_info_seen == 1 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension present (legacy)" ) );
S        handshake_failure = 1;
S    }
S#endif /* MBEDTLS_SSL_RENEGOTIATION */
S
S    if( handshake_failure == 1 )
S    {
S        if( ( ret = mbedtls_ssl_send_fatal_handshake_failure( ssl ) ) != 0 )
S            return( ret );
S
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
S    }
S
S    /*
S     * Search for a matching ciphersuite
S     * (At the end because we need information from the EC-based extensions
S     * and certificate from the SNI callback triggered by the SNI extension.)
S     */
S    got_common_suite = 0;
S    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];
S    ciphersuite_info = NULL;
S#if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)
S    for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )
S    {
S        for( i = 0; ciphersuites[i] != 0; i++ )
S#else
S    for( i = 0; ciphersuites[i] != 0; i++ )
S    {
S        for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )
S#endif
S        {
S            if( p[0] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||
S                p[1] != ( ( ciphersuites[i]      ) & 0xFF ) )
S                continue;
S
S            got_common_suite = 1;
S
S            if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],
S                                               &ciphersuite_info ) ) != 0 )
S                return( ret );
S
S            if( ciphersuite_info != NULL )
S                goto have_ciphersuite;
S        }
S    }
S
S    if( got_common_suite )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got ciphersuites in common, "
S                            "but none of them usable" ) );
S        mbedtls_ssl_send_fatal_handshake_failure( ssl );
S        return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );
S    }
S    else
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no ciphersuites in common" ) );
S        mbedtls_ssl_send_fatal_handshake_failure( ssl );
S        return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
S    }
S
Shave_ciphersuite:
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "selected ciphersuite: %s", ciphersuite_info->name ) );
S
S    ssl->session_negotiate->ciphersuite = ciphersuites[i];
S    ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;
S    mbedtls_ssl_optimize_checksum( ssl, ssl->transform_negotiate->ciphersuite_info );
S
S    ssl->state++;
S
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
S        mbedtls_ssl_recv_flight_completed( ssl );
S#endif
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client hello" ) );
S
S    return( 0 );
S}
S
S#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
Sstatic void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,
S                                          unsigned char *buf,
S                                          size_t *olen )
S{
S    unsigned char *p = buf;
S
S    if( ssl->session_negotiate->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )
S    {
S        *olen = 0;
S        return;
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding truncated hmac extension" ) );
S
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );
S
S    *p++ = 0x00;
S    *p++ = 0x00;
S
S    *olen = 4;
S}
S#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
S
S#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
Sstatic void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
S                                            unsigned char *buf,
S                                            size_t *olen )
S{
S    unsigned char *p = buf;
S    const mbedtls_ssl_ciphersuite_t *suite = NULL;
S    const mbedtls_cipher_info_t *cipher = NULL;
S
S    if( ssl->session_negotiate->encrypt_then_mac == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
S        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
S    {
S        *olen = 0;
S        return;
S    }
S
S    /*
S     * RFC 7366: "If a server receives an encrypt-then-MAC request extension
S     * from a client and then selects a stream or Authenticated Encryption
S     * with Associated Data (AEAD) ciphersuite, it MUST NOT send an
S     * encrypt-then-MAC response extension back to the client."
S     */
S    if( ( suite = mbedtls_ssl_ciphersuite_from_id(
S                    ssl->session_negotiate->ciphersuite ) ) == NULL ||
S        ( cipher = mbedtls_cipher_info_from_type( suite->cipher ) ) == NULL ||
S        cipher->mode != MBEDTLS_MODE_CBC )
S    {
S        *olen = 0;
S        return;
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding encrypt then mac extension" ) );
S
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );
S
S    *p++ = 0x00;
S    *p++ = 0x00;
S
S    *olen = 4;
S}
S#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
S
S#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
Sstatic void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
S                                       unsigned char *buf,
S                                       size_t *olen )
S{
S    unsigned char *p = buf;
S
S    if( ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
S        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
S    {
S        *olen = 0;
S        return;
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding extended master secret "
S                        "extension" ) );
S
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
S
S    *p++ = 0x00;
S    *p++ = 0x00;
S
S    *olen = 4;
S}
S#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
S
S#if defined(MBEDTLS_SSL_SESSION_TICKETS)
Sstatic void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
S                                          unsigned char *buf,
S                                          size_t *olen )
S{
S    unsigned char *p = buf;
S
S    if( ssl->handshake->new_session_ticket == 0 )
S    {
S        *olen = 0;
S        return;
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding session ticket extension" ) );
S
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) & 0xFF );
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) & 0xFF );
S
S    *p++ = 0x00;
S    *p++ = 0x00;
S
S    *olen = 4;
S}
S#endif /* MBEDTLS_SSL_SESSION_TICKETS */
S
Sstatic void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,
S                                         unsigned char *buf,
S                                         size_t *olen )
S{
S    unsigned char *p = buf;
S
S    if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION )
S    {
S        *olen = 0;
S        return;
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, secure renegotiation extension" ) );
S
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );
S
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
S    {
S        *p++ = 0x00;
S        *p++ = ( ssl->verify_data_len * 2 + 1 ) & 0xFF;
S        *p++ = ssl->verify_data_len * 2 & 0xFF;
S
S        memcpy( p, ssl->peer_verify_data, ssl->verify_data_len );
S        p += ssl->verify_data_len;
S        memcpy( p, ssl->own_verify_data, ssl->verify_data_len );
S        p += ssl->verify_data_len;
S    }
S    else
S#endif /* MBEDTLS_SSL_RENEGOTIATION */
S    {
S        *p++ = 0x00;
S        *p++ = 0x01;
S        *p++ = 0x00;
S    }
S
S    *olen = p - buf;
S}
S
S#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
Sstatic void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,
S                                               unsigned char *buf,
S                                               size_t *olen )
S{
S    unsigned char *p = buf;
S
S    if( ssl->session_negotiate->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE )
S    {
S        *olen = 0;
S        return;
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, max_fragment_length extension" ) );
S
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 ) & 0xFF );
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );
S
S    *p++ = 0x00;
S    *p++ = 1;
S
S    *p++ = ssl->session_negotiate->mfl_code;
S
S    *olen = 5;
S}
S#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
S
S#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
S    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
X#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) ||     defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
Sstatic void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,
S                                                   unsigned char *buf,
S                                                   size_t *olen )
S{
S    unsigned char *p = buf;
S    ((void) ssl);
S
S    if( ( ssl->handshake->cli_exts &
S          MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT ) == 0 )
S    {
S        *olen = 0;
S        return;
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, supported_point_formats extension" ) );
S
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS      ) & 0xFF );
S
S    *p++ = 0x00;
S    *p++ = 2;
S
S    *p++ = 1;
S    *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;
S
S    *olen = 6;
S}
S#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
Sstatic void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,
S                                        unsigned char *buf,
S                                        size_t *olen )
S{
S    int ret;
S    unsigned char *p = buf;
S    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
S    size_t kkpp_len;
S
S    *olen = 0;
S
S    /* Skip costly computation if not needed */
S    if( ssl->transform_negotiate->ciphersuite_info->key_exchange !=
S        MBEDTLS_KEY_EXCHANGE_ECJPAKE )
S        return;
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, ecjpake kkpp extension" ) );
S
S    if( end - p < 4 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
S        return;
S    }
S
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP >> 8 ) & 0xFF );
S    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP      ) & 0xFF );
S
S    ret = mbedtls_ecjpake_write_round_one( &ssl->handshake->ecjpake_ctx,
S                                        p + 2, end - p - 2, &kkpp_len,
S                                        ssl->conf->f_rng, ssl->conf->p_rng );
S    if( ret != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1 , "mbedtls_ecjpake_write_round_one", ret );
S        return;
S    }
S
S    *p++ = (unsigned char)( ( kkpp_len >> 8 ) & 0xFF );
S    *p++ = (unsigned char)( ( kkpp_len      ) & 0xFF );
S
S    *olen = kkpp_len + 4;
S}
S#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
S
S#if defined(MBEDTLS_SSL_ALPN )
Sstatic void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,
S                                unsigned char *buf, size_t *olen )
S{
S    if( ssl->alpn_chosen == NULL )
S    {
S        *olen = 0;
S        return;
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding alpn extension" ) );
S
S    /*
S     * 0 . 1    ext identifier
S     * 2 . 3    ext length
S     * 4 . 5    protocol list length
S     * 6 . 6    protocol name length
S     * 7 . 7+n  protocol name
S     */
S    buf[0] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );
S    buf[1] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );
S
S    *olen = 7 + strlen( ssl->alpn_chosen );
S
S    buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );
S    buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );
S
S    buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );
S    buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );
S
S    buf[6] = (unsigned char)( ( ( *olen - 7 )      ) & 0xFF );
S
S    memcpy( buf + 7, ssl->alpn_chosen, *olen - 7 );
S}
S#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C */
S
S#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
Sstatic int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )
S{
S    int ret;
S    unsigned char *p = ssl->out_msg + 4;
S    unsigned char *cookie_len_byte;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write hello verify request" ) );
S
S    /*
S     * struct {
S     *   ProtocolVersion server_version;
S     *   opaque cookie<0..2^8-1>;
S     * } HelloVerifyRequest;
S     */
S
S    /* The RFC is not clear on this point, but sending the actual negotiated
S     * version looks like the most interoperable thing to do. */
S    mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
S                       ssl->conf->transport, p );
S    MBEDTLS_SSL_DEBUG_BUF( 3, "server version", p, 2 );
S    p += 2;
S
S    /* If we get here, f_cookie_check is not null */
S    if( ssl->conf->f_cookie_write == NULL )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "inconsistent cookie callbacks" ) );
S        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
S    }
S
S    /* Skip length byte until we know the length */
S    cookie_len_byte = p++;
S
S    if( ( ret = ssl->conf->f_cookie_write( ssl->conf->p_cookie,
S                                     &p, ssl->out_buf + MBEDTLS_SSL_BUFFER_LEN,
S                                     ssl->cli_id, ssl->cli_id_len ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "f_cookie_write", ret );
S        return( ret );
S    }
S
S    *cookie_len_byte = (unsigned char)( p - ( cookie_len_byte + 1 ) );
S
S    MBEDTLS_SSL_DEBUG_BUF( 3, "cookie sent", cookie_len_byte + 1, *cookie_len_byte );
S
S    ssl->out_msglen  = p - ssl->out_msg;
S    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
S    ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
S
S    ssl->state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;
S
S    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
S        return( ret );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write hello verify request" ) );
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
S
Sstatic int ssl_write_server_hello( mbedtls_ssl_context *ssl )
S{
S#if defined(MBEDTLS_HAVE_TIME)
S    time_t t;
S#endif
S    int ret;
S    size_t olen, ext_len = 0, n;
S    unsigned char *buf, *p;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello" ) );
S
S#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
S        ssl->handshake->verify_cookie_len != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 2, ( "client hello was not authenticated" ) );
S        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello" ) );
S
S        return( ssl_write_hello_verify_request( ssl ) );
S    }
S#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
S
S    if( ssl->conf->f_rng == NULL )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "no RNG provided") );
S        return( MBEDTLS_ERR_SSL_NO_RNG );
S    }
S
S    /*
S     *     0  .   0   handshake type
S     *     1  .   3   handshake length
S     *     4  .   5   protocol version
S     *     6  .   9   UNIX time()
S     *    10  .  37   random bytes
S     */
S    buf = ssl->out_msg;
S    p = buf + 4;
S
S    mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
S                       ssl->conf->transport, p );
S    p += 2;
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen version: [%d:%d]",
S                        buf[4], buf[5] ) );
S
S#if defined(MBEDTLS_HAVE_TIME)
S    t = time( NULL );
S    *p++ = (unsigned char)( t >> 24 );
S    *p++ = (unsigned char)( t >> 16 );
S    *p++ = (unsigned char)( t >>  8 );
S    *p++ = (unsigned char)( t       );
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, current time: %lu", t ) );
S#else
S    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )
S        return( ret );
S
S    p += 4;
S#endif /* MBEDTLS_HAVE_TIME */
S
S    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )
S        return( ret );
S
S    p += 28;
S
S    memcpy( ssl->handshake->randbytes + 32, buf + 6, 32 );
S
S    MBEDTLS_SSL_DEBUG_BUF( 3, "server hello, random bytes", buf + 6, 32 );
S
S    /*
S     * Resume is 0  by default, see ssl_handshake_init().
S     * It may be already set to 1 by ssl_parse_session_ticket_ext().
S     * If not, try looking up session ID in our cache.
S     */
S    if( ssl->handshake->resume == 0 &&
S#if defined(MBEDTLS_SSL_RENEGOTIATION)
S        ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE &&
S#endif
S        ssl->session_negotiate->id_len != 0 &&
S        ssl->conf->f_get_cache != NULL &&
S        ssl->conf->f_get_cache( ssl->conf->p_cache, ssl->session_negotiate ) == 0 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 3, ( "session successfully restored from cache" ) );
S        ssl->handshake->resume = 1;
S    }
S
S    if( ssl->handshake->resume == 0 )
S    {
S        /*
S         * New session, create a new session id,
S         * unless we're about to issue a session ticket
S         */
S        ssl->state++;
S
S#if defined(MBEDTLS_HAVE_TIME)
S        ssl->session_negotiate->start = time( NULL );
S#endif
S
S#if defined(MBEDTLS_SSL_SESSION_TICKETS)
S        if( ssl->handshake->new_session_ticket != 0 )
S        {
S            ssl->session_negotiate->id_len = n = 0;
S            memset( ssl->session_negotiate->id, 0, 32 );
S        }
S        else
S#endif /* MBEDTLS_SSL_SESSION_TICKETS */
S        {
S            ssl->session_negotiate->id_len = n = 32;
S            if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->session_negotiate->id,
S                                    n ) ) != 0 )
S                return( ret );
S        }
S    }
S    else
S    {
S        /*
S         * Resuming a session
S         */
S        n = ssl->session_negotiate->id_len;
S        ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
S
S        if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
S            return( ret );
S        }
S    }
S
S    /*
S     *    38  .  38     session id length
S     *    39  . 38+n    session id
S     *   39+n . 40+n    chosen ciphersuite
S     *   41+n . 41+n    chosen compression alg.
S     *   42+n . 43+n    extensions length
S     *   44+n . 43+n+m  extensions
S     */
S    *p++ = (unsigned char) ssl->session_negotiate->id_len;
S    memcpy( p, ssl->session_negotiate->id, ssl->session_negotiate->id_len );
S    p += ssl->session_negotiate->id_len;
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, session id len.: %d", n ) );
S    MBEDTLS_SSL_DEBUG_BUF( 3,   "server hello, session id", buf + 39, n );
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "%s session has been resumed",
S                   ssl->handshake->resume ? "a" : "no" ) );
S
S    *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite >> 8 );
S    *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite      );
S    *p++ = (unsigned char)( ssl->session_negotiate->compression      );
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen ciphersuite: %s",
S           mbedtls_ssl_get_ciphersuite_name( ssl->session_negotiate->ciphersuite ) ) );
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, compress alg.: 0x%02X",
S                   ssl->session_negotiate->compression ) );
S
S    /*
S     *  First write extensions, then the total length
S     */
S    ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );
S    ext_len += olen;
S
S#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
S    ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );
S    ext_len += olen;
S#endif
S
S#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
S    ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );
S    ext_len += olen;
S#endif
S
S#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
S    ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );
S    ext_len += olen;
S#endif
S
S#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
S    ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );
S    ext_len += olen;
S#endif
S
S#if defined(MBEDTLS_SSL_SESSION_TICKETS)
S    ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );
S    ext_len += olen;
S#endif
S
S#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
S    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
X#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) ||     defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
S    ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );
S    ext_len += olen;
S#endif
S
S#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
S    ssl_write_ecjpake_kkpp_ext( ssl, p + 2 + ext_len, &olen );
S    ext_len += olen;
S#endif
S
S#if defined(MBEDTLS_SSL_ALPN)
S    ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );
S    ext_len += olen;
S#endif
S
S    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, total extension length: %d", ext_len ) );
S
S    if( ext_len > 0 )
S    {
S        *p++ = (unsigned char)( ( ext_len >> 8 ) & 0xFF );
S        *p++ = (unsigned char)( ( ext_len      ) & 0xFF );
S        p += ext_len;
S    }
S
S    ssl->out_msglen  = p - buf;
S    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
S    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;
S
S    ret = mbedtls_ssl_write_record( ssl );
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello" ) );
S
S    return( ret );
S}
S
S#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \
S    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \
S    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \
S    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
X#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       &&     !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   &&     !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) &&     !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
Sstatic int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
S{
S    const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate request" ) );
S
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate request" ) );
S        ssl->state++;
S        return( 0 );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
S    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
S}
S#else
Sstatic int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
S{
S    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
S    const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
S    size_t dn_size, total_dn_size; /* excluding length bytes */
S    size_t ct_len, sa_len; /* including length bytes */
S    unsigned char *buf, *p;
S    const unsigned char * const end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
S    const mbedtls_x509_crt *crt;
S    int authmode;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate request" ) );
S
S    ssl->state++;
S
S#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
S    if( ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET )
S        authmode = ssl->handshake->sni_authmode;
S    else
S#endif
S        authmode = ssl->conf->authmode;
S
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||
S        authmode == MBEDTLS_SSL_VERIFY_NONE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate request" ) );
S        return( 0 );
S    }
S
S    /*
S     *     0  .   0   handshake type
S     *     1  .   3   handshake length
S     *     4  .   4   cert type count
S     *     5  .. m-1  cert types
S     *     m  .. m+1  sig alg length (TLS 1.2 only)
S     *    m+1 .. n-1  SignatureAndHashAlgorithms (TLS 1.2 only)
S     *     n  .. n+1  length of all DNs
S     *    n+2 .. n+3  length of DN 1
S     *    n+4 .. ...  Distinguished Name #1
S     *    ... .. ...  length of DN 2, etc.
S     */
S    buf = ssl->out_msg;
S    p = buf + 4;
S
S    /*
S     * Supported certificate types
S     *
S     *     ClientCertificateType certificate_types<1..2^8-1>;
S     *     enum { (255) } ClientCertificateType;
S     */
S    ct_len = 0;
S
S#if defined(MBEDTLS_RSA_C)
S    p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_RSA_SIGN;
S#endif
S#if defined(MBEDTLS_ECDSA_C)
S    p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN;
S#endif
S
S    p[0] = (unsigned char) ct_len++;
S    p += ct_len;
S
S    sa_len = 0;
S#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
S    /*
S     * Add signature_algorithms for verify (TLS 1.2)
S     *
S     *     SignatureAndHashAlgorithm supported_signature_algorithms<2..2^16-2>;
S     *
S     *     struct {
S     *           HashAlgorithm hash;
S     *           SignatureAlgorithm signature;
S     *     } SignatureAndHashAlgorithm;
S     *
S     *     enum { (255) } HashAlgorithm;
S     *     enum { (255) } SignatureAlgorithm;
S     */
S    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
S    {
S        /*
S         * Only use current running hash algorithm that is already required
S         * for requested ciphersuite.
S         */
S        ssl->handshake->verify_sig_alg = MBEDTLS_SSL_HASH_SHA256;
S
S        if( ssl->transform_negotiate->ciphersuite_info->mac ==
S            MBEDTLS_MD_SHA384 )
S        {
S            ssl->handshake->verify_sig_alg = MBEDTLS_SSL_HASH_SHA384;
S        }
S
S        /*
S         * Supported signature algorithms
S         */
S#if defined(MBEDTLS_RSA_C)
S        p[2 + sa_len++] = ssl->handshake->verify_sig_alg;
S        p[2 + sa_len++] = MBEDTLS_SSL_SIG_RSA;
S#endif
S#if defined(MBEDTLS_ECDSA_C)
S        p[2 + sa_len++] = ssl->handshake->verify_sig_alg;
S        p[2 + sa_len++] = MBEDTLS_SSL_SIG_ECDSA;
S#endif
S
S        p[0] = (unsigned char)( sa_len >> 8 );
S        p[1] = (unsigned char)( sa_len      );
S        sa_len += 2;
S        p += sa_len;
S    }
S#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
S
S    /*
S     * DistinguishedName certificate_authorities<0..2^16-1>;
S     * opaque DistinguishedName<1..2^16-1>;
S     */
S    p += 2;
S#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
S    if( ssl->handshake->sni_ca_chain != NULL )
S        crt = ssl->handshake->sni_ca_chain;
S    else
S#endif
S        crt = ssl->conf->ca_chain;
S
S    total_dn_size = 0;
S    while( crt != NULL && crt->version != 0 )
S    {
S        dn_size = crt->subject_raw.len;
S
S        if( end < p ||
S            (size_t)( end - p ) < dn_size ||
S            (size_t)( end - p ) < 2 + dn_size )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "skipping CAs: buffer too short" ) );
S            break;
S        }
S
S        *p++ = (unsigned char)( dn_size >> 8 );
S        *p++ = (unsigned char)( dn_size      );
S        memcpy( p, crt->subject_raw.p, dn_size );
S        p += dn_size;
S
S        MBEDTLS_SSL_DEBUG_BUF( 3, "requested DN", p - dn_size, dn_size );
S
S        total_dn_size += 2 + dn_size;
S        crt = crt->next;
S    }
S
S    ssl->out_msglen  = p - buf;
S    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
S    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;
S    ssl->out_msg[4 + ct_len + sa_len] = (unsigned char)( total_dn_size  >> 8 );
S    ssl->out_msg[5 + ct_len + sa_len] = (unsigned char)( total_dn_size       );
S
S    ret = mbedtls_ssl_write_record( ssl );
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write certificate request" ) );
S
S    return( ret );
S}
S#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&
S          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&
S          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&
S          !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||     defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
Sstatic int ssl_get_ecdh_params_from_cert( mbedtls_ssl_context *ssl )
S{
S    int ret;
S
S    if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_ECKEY ) )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server key not ECDH capable" ) );
S        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );
S    }
S
S    if( ( ret = mbedtls_ecdh_get_params( &ssl->handshake->ecdh_ctx,
S                                 mbedtls_pk_ec( *mbedtls_ssl_own_key( ssl ) ),
S                                 MBEDTLS_ECDH_OURS ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ecdh_get_params" ), ret );
S        return( ret );
S    }
S
S    return( 0 );
S}
S#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||
S          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
S
Sstatic int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
S{
S    int ret;
S    size_t n = 0;
S    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
S                            ssl->transform_negotiate->ciphersuite_info;
S
S#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
S    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED) ||                       \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
S    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                           defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED) ||                           defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                         defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                         defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                       defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
S    unsigned char *p = ssl->out_msg + 4;
S    unsigned char *dig_signed = p;
S    size_t dig_signed_len = 0, len;
S    ((void) dig_signed);
S    ((void) dig_signed_len);
S    ((void) len);
S#endif
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server key exchange" ) );
S
S#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \
S    defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                           \
S    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                               defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                               defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write server key exchange" ) );
S        ssl->state++;
S        return( 0 );
S    }
S#endif
S
S#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||     defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )
S    {
S        ssl_get_ecdh_params_from_cert( ssl );
S
S        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write server key exchange" ) );
S        ssl->state++;
S        return( 0 );
S    }
S#endif
S
S#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
S    {
S        size_t jlen;
S        const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
S
S        ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,
S                p, end - p, &jlen, ssl->conf->f_rng, ssl->conf->p_rng );
S        if( ret != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_write_round_two", ret );
S            return( ret );
S        }
S
S        p += jlen;
S        n += jlen;
S    }
S#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED) ||                       \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED) ||                           defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
S    {
S        /* TODO: Support identity hints */
S        *(p++) = 0x00;
S        *(p++) = 0x00;
S
S        n += 2;
S    }
S#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED ||
S          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
S    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                           defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )
S    {
S        if( ssl->conf->dhm_P.p == NULL || ssl->conf->dhm_G.p == NULL )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "no DH parameters set" ) );
S            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
S        }
S
S        /*
S         * Ephemeral DH parameters:
S         *
S         * struct {
S         *     opaque dh_p<1..2^16-1>;
S         *     opaque dh_g<1..2^16-1>;
S         *     opaque dh_Ys<1..2^16-1>;
S         * } ServerDHParams;
S         */
S        if( ( ret = mbedtls_mpi_copy( &ssl->handshake->dhm_ctx.P, &ssl->conf->dhm_P ) ) != 0 ||
S            ( ret = mbedtls_mpi_copy( &ssl->handshake->dhm_ctx.G, &ssl->conf->dhm_G ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_mpi_copy", ret );
S            return( ret );
S        }
S
S        if( ( ret = mbedtls_dhm_make_params( &ssl->handshake->dhm_ctx,
S                        (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),
S                        p, &len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_make_params", ret );
S            return( ret );
S        }
S
S        dig_signed = p;
S        dig_signed_len = len;
S
S        p += len;
S        n += len;
S
S        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: X ", &ssl->handshake->dhm_ctx.X  );
S        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: P ", &ssl->handshake->dhm_ctx.P  );
S        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: G ", &ssl->handshake->dhm_ctx.G  );
S        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: GX", &ssl->handshake->dhm_ctx.GX );
S    }
S#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
S          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
S    {
S        /*
S         * Ephemeral ECDH parameters:
S         *
S         * struct {
S         *     ECParameters curve_params;
S         *     ECPoint      public;
S         * } ServerECDHParams;
S         */
S        const mbedtls_ecp_curve_info **curve = NULL;
S        const mbedtls_ecp_group_id *gid;
S
S        /* Match our preference list against the offered curves */
S        for( gid = ssl->conf->curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )
S            for( curve = ssl->handshake->curves; *curve != NULL; curve++ )
S                if( (*curve)->grp_id == *gid )
S                    goto curve_matching_done;
S
Scurve_matching_done:
S        if( curve == NULL || *curve == NULL )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "no matching curve for ECDHE" ) );
S            return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
S        }
S
S        MBEDTLS_SSL_DEBUG_MSG( 2, ( "ECDHE curve: %s", (*curve)->name ) );
S
S        if( ( ret = mbedtls_ecp_group_load( &ssl->handshake->ecdh_ctx.grp,
S                                       (*curve)->grp_id ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecp_group_load", ret );
S            return( ret );
S        }
S
S        if( ( ret = mbedtls_ecdh_make_params( &ssl->handshake->ecdh_ctx, &len,
S                                      p, MBEDTLS_SSL_MAX_CONTENT_LEN - n,
S                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_make_params", ret );
S            return( ret );
S        }
S
S        dig_signed = p;
S        dig_signed_len = len;
S
S        p += len;
S        n += len;
S
S        MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Q ", &ssl->handshake->ecdh_ctx.Q );
S    }
S#endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                           defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                         defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )
S    {
S        size_t signature_len = 0;
S        unsigned int hashlen = 0;
S        unsigned char hash[64];
S        mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE;
S
S        /*
S         * Choose hash algorithm. NONE means MD5 + SHA1 here.
S         */
S#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
S        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
S        {
S            md_alg = mbedtls_ssl_md_alg_from_hash( ssl->handshake->sig_alg );
S
S            if( md_alg == MBEDTLS_MD_NONE )
S            {
S                MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
S                return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
S            }
S        }
S        else
S#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
S#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
S    defined(MBEDTLS_SSL_PROTO_TLS1_1)
X#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) ||     defined(MBEDTLS_SSL_PROTO_TLS1_1)
S        if( ciphersuite_info->key_exchange ==
S                  MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )
S        {
S            md_alg = MBEDTLS_MD_SHA1;
S        }
S        else
S#endif
S        {
S            md_alg = MBEDTLS_MD_NONE;
S        }
S
S        /*
S         * Compute the hash to be signed
S         */
S#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
S    defined(MBEDTLS_SSL_PROTO_TLS1_1)
X#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) ||     defined(MBEDTLS_SSL_PROTO_TLS1_1)
S        if( md_alg == MBEDTLS_MD_NONE )
S        {
S            mbedtls_md5_context mbedtls_md5;
S            mbedtls_sha1_context mbedtls_sha1;
S
S            mbedtls_md5_init(  &mbedtls_md5  );
S            mbedtls_sha1_init( &mbedtls_sha1 );
S
S            /*
S             * digitally-signed struct {
S             *     opaque md5_hash[16];
S             *     opaque sha_hash[20];
S             * };
S             *
S             * md5_hash
S             *     MD5(ClientHello.random + ServerHello.random
S             *                            + ServerParams);
S             * sha_hash
S             *     SHA(ClientHello.random + ServerHello.random
S             *                            + ServerParams);
S             */
S            mbedtls_md5_starts( &mbedtls_md5 );
S            mbedtls_md5_update( &mbedtls_md5, ssl->handshake->randbytes,  64 );
S            mbedtls_md5_update( &mbedtls_md5, dig_signed, dig_signed_len );
S            mbedtls_md5_finish( &mbedtls_md5, hash );
S
S            mbedtls_sha1_starts( &mbedtls_sha1 );
S            mbedtls_sha1_update( &mbedtls_sha1, ssl->handshake->randbytes,  64 );
S            mbedtls_sha1_update( &mbedtls_sha1, dig_signed, dig_signed_len );
S            mbedtls_sha1_finish( &mbedtls_sha1, hash + 16 );
S
S            hashlen = 36;
S
S            mbedtls_md5_free(  &mbedtls_md5  );
S            mbedtls_sha1_free( &mbedtls_sha1 );
S        }
S        else
S#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \
S          MBEDTLS_SSL_PROTO_TLS1_1 */
X#endif  
S#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
S    defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) ||     defined(MBEDTLS_SSL_PROTO_TLS1_2)
S        if( md_alg != MBEDTLS_MD_NONE )
S        {
S            mbedtls_md_context_t ctx;
S            const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
S
S            mbedtls_md_init( &ctx );
S
S            /* Info from md_alg will be used instead */
S            hashlen = 0;
S
S            /*
S             * digitally-signed struct {
S             *     opaque client_random[32];
S             *     opaque server_random[32];
S             *     ServerDHParams params;
S             * };
S             */
S            if( ( ret = mbedtls_md_setup( &ctx, md_info, 0 ) ) != 0 )
S            {
S                MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_setup", ret );
S                return( ret );
S            }
S
S            mbedtls_md_starts( &ctx );
S            mbedtls_md_update( &ctx, ssl->handshake->randbytes, 64 );
S            mbedtls_md_update( &ctx, dig_signed, dig_signed_len );
S            mbedtls_md_finish( &ctx, hash );
S            mbedtls_md_free( &ctx );
S        }
S        else
S#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \
S          MBEDTLS_SSL_PROTO_TLS1_2 */
X#endif  
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
S            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
S        }
S
S        MBEDTLS_SSL_DEBUG_BUF( 3, "parameters hash", hash, hashlen != 0 ? hashlen :
S            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );
S
S        /*
S         * Make the signature
S         */
S        if( mbedtls_ssl_own_key( ssl ) == NULL )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no private key" ) );
S            return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
S        }
S
S#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
S        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
S        {
S            *(p++) = ssl->handshake->sig_alg;
S            *(p++) = mbedtls_ssl_sig_from_pk( mbedtls_ssl_own_key( ssl ) );
S
S            n += 2;
S        }
S#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
S
S        if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash, hashlen,
S                        p + 2 , &signature_len,
S                        ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_sign", ret );
S            return( ret );
S        }
S
S        *(p++) = (unsigned char)( signature_len >> 8 );
S        *(p++) = (unsigned char)( signature_len      );
S        n += 2;
S
S        MBEDTLS_SSL_DEBUG_BUF( 3, "my signature", p, signature_len );
S
S        n += signature_len;
S    }
S#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||
S          MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
S          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
S
S    ssl->out_msglen  = 4 + n;
S    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
S    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE;
S
S    ssl->state++;
S
S    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
S        return( ret );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server key exchange" ) );
S
S    return( 0 );
S}
S
Sstatic int ssl_write_server_hello_done( mbedtls_ssl_context *ssl )
S{
S    int ret;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello done" ) );
S
S    ssl->out_msglen  = 4;
S    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
S    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO_DONE;
S
S    ssl->state++;
S
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
S        mbedtls_ssl_send_flight_completed( ssl );
S#endif
S
S    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
S        return( ret );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello done" ) );
S
S    return( 0 );
S}
S
S#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
S    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                           defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
Sstatic int ssl_parse_client_dh_public( mbedtls_ssl_context *ssl, unsigned char **p,
S                                       const unsigned char *end )
S{
S    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
S    size_t n;
S
S    /*
S     * Receive G^Y mod P, premaster = (G^Y)^X mod P
S     */
S    if( *p + 2 > end )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S    }
S
S    n = ( (*p)[0] << 8 ) | (*p)[1];
S    *p += 2;
S
S    if( *p + n > end )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S    }
S
S    if( ( ret = mbedtls_dhm_read_public( &ssl->handshake->dhm_ctx, *p, n ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_read_public", ret );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
S    }
S
S    *p += n;
S
S    MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: GY", &ssl->handshake->dhm_ctx.GY );
S
S    return( ret );
S}
S#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
S          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \
S    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                               defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
Sstatic int ssl_parse_encrypted_pms( mbedtls_ssl_context *ssl,
S                                    const unsigned char *p,
S                                    const unsigned char *end,
S                                    size_t pms_offset )
S{
S    int ret;
S    size_t len = mbedtls_pk_get_len( mbedtls_ssl_own_key( ssl ) );
S    unsigned char *pms = ssl->handshake->premaster + pms_offset;
S    unsigned char ver[2];
S    unsigned char fake_pms[48], peer_pms[48];
S    unsigned char mask;
S    size_t i, peer_pmslen;
S    unsigned int diff;
S
S    if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_RSA ) )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no RSA private key" ) );
S        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
S    }
S
S    /*
S     * Decrypt the premaster using own private RSA key
S     */
S#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
S    defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) ||     defined(MBEDTLS_SSL_PROTO_TLS1_2)
S    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
S    {
S        if( *p++ != ( ( len >> 8 ) & 0xFF ) ||
S            *p++ != ( ( len      ) & 0xFF ) )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S        }
S    }
S#endif
S
S    if( p + len != end )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S    }
S
S    mbedtls_ssl_write_version( ssl->handshake->max_major_ver,
S                       ssl->handshake->max_minor_ver,
S                       ssl->conf->transport, ver );
S
S    /*
S     * Protection against Bleichenbacher's attack: invalid PKCS#1 v1.5 padding
S     * must not cause the connection to end immediately; instead, send a
S     * bad_record_mac later in the handshake.
S     * Also, avoid data-dependant branches here to protect against
S     * timing-based variants.
S     */
S    ret = ssl->conf->f_rng( ssl->conf->p_rng, fake_pms, sizeof( fake_pms ) );
S    if( ret != 0 )
S        return( ret );
S
S    ret = mbedtls_pk_decrypt( mbedtls_ssl_own_key( ssl ), p, len,
S                      peer_pms, &peer_pmslen,
S                      sizeof( peer_pms ),
S                      ssl->conf->f_rng, ssl->conf->p_rng );
S
S    diff  = (unsigned int) ret;
S    diff |= peer_pmslen ^ 48;
S    diff |= peer_pms[0] ^ ver[0];
S    diff |= peer_pms[1] ^ ver[1];
S
S#if defined(MBEDTLS_SSL_DEBUG_ALL)
S    if( diff != 0 )
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
S#endif
S
S    if( sizeof( ssl->handshake->premaster ) < pms_offset ||
S        sizeof( ssl->handshake->premaster ) - pms_offset < 48 )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
S        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
S    }
S    ssl->handshake->pmslen = 48;
S
S    /* mask = diff ? 0xff : 0x00 using bit operations to avoid branches */
S    /* MSVC has a warning about unary minus on unsigned, but this is
S     * well-defined and precisely what we want to do here */
S#if defined(_MSC_VER)
S#pragma warning( push )
S#pragma warning( disable : 4146 )
S#endif
S    mask = - ( ( diff | - diff ) >> ( sizeof( unsigned int ) * 8 - 1 ) );
S#if defined(_MSC_VER)
S#pragma warning( pop )
S#endif
S
S    for( i = 0; i < ssl->handshake->pmslen; i++ )
S        pms[i] = ( mask & fake_pms[i] ) | ( (~mask) & peer_pms[i] );
S
S    return( 0 );
S}
S#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||
S          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
S
S#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
Sstatic int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,
S                                          const unsigned char *end )
S{
S    int ret = 0;
S    size_t n;
S
S    if( ssl->conf->f_psk == NULL &&
S        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
S          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no pre-shared key" ) );
S        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
S    }
S
S    /*
S     * Receive client pre-shared key identity name
S     */
S    if( *p + 2 > end )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S    }
S
S    n = ( (*p)[0] << 8 ) | (*p)[1];
S    *p += 2;
S
S    if( n < 1 || n > 65535 || *p + n > end )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S    }
S
S    if( ssl->conf->f_psk != NULL )
S    {
S        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )
S            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
S    }
S    else
S    {
S        /* Identity is not a big secret since clients send it in the clear,
S         * but treat it carefully anyway, just in case */
S        if( n != ssl->conf->psk_identity_len ||
S            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )
S        {
S            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
S        }
S    }
S
S    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )
S    {
S        MBEDTLS_SSL_DEBUG_BUF( 3, "Unknown PSK identity", *p, n );
S        if( ( ret = mbedtls_ssl_send_alert_message( ssl,
S                              MBEDTLS_SSL_ALERT_LEVEL_FATAL,
S                              MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY ) ) != 0 )
S        {
S            return( ret );
S        }
S
S        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );
S    }
S
S    *p += n;
S
S    return( 0 );
S}
S#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */
S
Sstatic int ssl_parse_client_key_exchange( mbedtls_ssl_context *ssl )
S{
S    int ret;
S    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
S    unsigned char *p, *end;
S
S    ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client key exchange" ) );
S
S    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
S        return( ret );
S    }
S
S    p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
S    end = ssl->in_msg + ssl->in_hslen;
S
S    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S    }
S
S    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S    }
S
S#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA )
S    {
S        if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_dh_public" ), ret );
S            return( ret );
S        }
S
S        if( p != end )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S        }
S
S        if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,
S                                      ssl->handshake->premaster,
S                                      MBEDTLS_PREMASTER_SIZE,
S                                     &ssl->handshake->pmslen,
S                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_calc_secret", ret );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );
S        }
S
S        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: K ", &ssl->handshake->dhm_ctx.K  );
S    }
S    else
S#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */
S#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
S    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
X#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                         defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                       defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                          defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )
S    {
S        if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,
S                                      p, end - p) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_read_public", ret );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
S        }
S
S        MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Qp ", &ssl->handshake->ecdh_ctx.Qp );
S
S        if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx,
S                                      &ssl->handshake->pmslen,
S                                       ssl->handshake->premaster,
S                                       MBEDTLS_MPI_MAX_SIZE,
S                                       ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_calc_secret", ret );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );
S        }
S
S        MBEDTLS_SSL_DEBUG_MPI( 3, "ECDH: z  ", &ssl->handshake->ecdh_ctx.z );
S    }
S    else
S#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
S          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
S          MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
S          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
S#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK )
S    {
S        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
S            return( ret );
S        }
S
S        if( p != end )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S        }
S
S        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
S                        ciphersuite_info->key_exchange ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
S            return( ret );
S        }
S    }
S    else
S#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */
S#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
S    {
S        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
S            return( ret );
S        }
S
S        if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 2 ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_encrypted_pms" ), ret );
S            return( ret );
S        }
S
S        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
S                        ciphersuite_info->key_exchange ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
S            return( ret );
S        }
S    }
S    else
S#endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
S#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )
S    {
S        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
S            return( ret );
S        }
S        if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_dh_public" ), ret );
S            return( ret );
S        }
S
S        if( p != end )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
S        }
S
S        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
S                        ciphersuite_info->key_exchange ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
S            return( ret );
S        }
S    }
S    else
S#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
S#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
S    {
S        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
S            return( ret );
S        }
S
S        if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,
S                                       p, end - p ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_read_public", ret );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
S        }
S
S        MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Qp ", &ssl->handshake->ecdh_ctx.Qp );
S
S        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
S                        ciphersuite_info->key_exchange ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
S            return( ret );
S        }
S    }
S    else
S#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
S#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )
S    {
S        if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 0 ) ) != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_parse_encrypted_pms_secret" ), ret );
S            return( ret );
S        }
S    }
S    else
S#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */
S#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
S    {
S        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,
S                                              p, end - p );
S        if( ret != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_read_round_two", ret );
S            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
S        }
S
S        ret = mbedtls_ecjpake_derive_secret( &ssl->handshake->ecjpake_ctx,
S                ssl->handshake->premaster, 32, &ssl->handshake->pmslen,
S                ssl->conf->f_rng, ssl->conf->p_rng );
S        if( ret != 0 )
S        {
S            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_derive_secret", ret );
S            return( ret );
S        }
S    }
S    else
S#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
S        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
S    }
S
S    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
S        return( ret );
S    }
S
S    ssl->state++;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client key exchange" ) );
S
S    return( 0 );
S}
S
S#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \
S    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \
S    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \
S    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
X#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       &&     !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   &&     !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) &&     !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
Sstatic int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
S{
S    const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate verify" ) );
S
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate verify" ) );
S        ssl->state++;
S        return( 0 );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
S    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
S}
S#else
Sstatic int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
S{
S    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
S    size_t i, sig_len;
S    unsigned char hash[48];
S    unsigned char *hash_start = hash;
S    size_t hashlen;
S#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
S    mbedtls_pk_type_t pk_alg;
S#endif
S    mbedtls_md_type_t md_alg;
S    const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate verify" ) );
S
S    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
S        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||
S        ssl->session_negotiate->peer_cert == NULL )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate verify" ) );
S        ssl->state++;
S        return( 0 );
S    }
S
S    /* Needs to be done before read_record() to exclude current message */
S    ssl->handshake->calc_verify( ssl, hash );
S
S    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
S        return( ret );
S    }
S
S    ssl->state++;
S
S    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||
S        ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE_VERIFY )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
S    }
S
S    i = mbedtls_ssl_hs_hdr_len( ssl );
S
S    /*
S     *  struct {
S     *     SignatureAndHashAlgorithm algorithm; -- TLS 1.2 only
S     *     opaque signature<0..2^16-1>;
S     *  } DigitallySigned;
S     */
S#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
S    defined(MBEDTLS_SSL_PROTO_TLS1_1)
X#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) ||     defined(MBEDTLS_SSL_PROTO_TLS1_1)
S    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )
S    {
S        md_alg = MBEDTLS_MD_NONE;
S        hashlen = 36;
S
S        /* For ECDSA, use SHA-1, not MD-5 + SHA-1 */
S        if( mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,
S                        MBEDTLS_PK_ECDSA ) )
S        {
S            hash_start += 16;
S            hashlen -= 16;
S            md_alg = MBEDTLS_MD_SHA1;
S        }
S    }
S    else
S#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 ||
S          MBEDTLS_SSL_PROTO_TLS1_1 */
S#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
S    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
S    {
S        if( i + 2 > ssl->in_hslen )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
S        }
S
S        /*
S         * Hash
S         */
S        if( ssl->in_msg[i] != ssl->handshake->verify_sig_alg )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
S                                " for verify message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
S        }
S
S        md_alg = mbedtls_ssl_md_alg_from_hash( ssl->handshake->verify_sig_alg );
S
S        /* Info from md_alg will be used instead */
S        hashlen = 0;
S
S        i++;
S
S        /*
S         * Signature
S         */
S        if( ( pk_alg = mbedtls_ssl_pk_alg_from_sig( ssl->in_msg[i] ) )
S                        == MBEDTLS_PK_NONE )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
S                                " for verify message" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
S        }
S
S        /*
S         * Check the certificate's key type matches the signature alg
S         */
S        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )
S        {
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "sig_alg doesn't match cert key" ) );
S            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
S        }
S
S        i++;
S    }
S    else
S#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
S        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
S    }
S
S    if( i + 2 > ssl->in_hslen )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
S    }
S
S    sig_len = ( ssl->in_msg[i] << 8 ) | ssl->in_msg[i+1];
S    i += 2;
S
S    if( i + sig_len != ssl->in_hslen )
S    {
S        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
S        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
S    }
S
S    if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,
S                           md_alg, hash_start, hashlen,
S                           ssl->in_msg + i, sig_len ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_verify", ret );
S        return( ret );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse certificate verify" ) );
S
S    return( ret );
S}
S#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&
S          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&
S          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED */
S
S#if defined(MBEDTLS_SSL_SESSION_TICKETS)
Sstatic int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )
S{
S    int ret;
S    size_t tlen;
S    uint32_t lifetime;
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write new session ticket" ) );
S
S    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
S    ssl->out_msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;
S
S    /*
S     * struct {
S     *     uint32 ticket_lifetime_hint;
S     *     opaque ticket<0..2^16-1>;
S     * } NewSessionTicket;
S     *
S     * 4  .  7   ticket_lifetime_hint (0 = unspecified)
S     * 8  .  9   ticket_len (n)
S     * 10 .  9+n ticket content
S     */
S
S    if( ( ret = ssl->conf->f_ticket_write( ssl->conf->p_ticket,
S                                ssl->session_negotiate,
S                                ssl->out_msg + 10,
S                                ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN,
S                                &tlen, &lifetime ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_write", ret );
S        tlen = 0;
S    }
S
S    ssl->out_msg[4] = ( lifetime >> 24 ) & 0xFF;
S    ssl->out_msg[5] = ( lifetime >> 16 ) & 0xFF;
S    ssl->out_msg[6] = ( lifetime >>  8 ) & 0xFF;
S    ssl->out_msg[7] = ( lifetime       ) & 0xFF;
S
S    ssl->out_msg[8] = (unsigned char)( ( tlen >> 8 ) & 0xFF );
S    ssl->out_msg[9] = (unsigned char)( ( tlen      ) & 0xFF );
S
S    ssl->out_msglen = 10 + tlen;
S
S    /*
S     * Morally equivalent to updating ssl->state, but NewSessionTicket and
S     * ChangeCipherSpec share the same state.
S     */
S    ssl->handshake->new_session_ticket = 0;
S
S    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
S    {
S        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
S        return( ret );
S    }
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write new session ticket" ) );
S
S    return( 0 );
S}
S#endif /* MBEDTLS_SSL_SESSION_TICKETS */
S
S/*
S * SSL handshake -- server side -- single step
S */
Sint mbedtls_ssl_handshake_server_step( mbedtls_ssl_context *ssl )
S{
S    int ret = 0;
S
S    if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )
S        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
S
S    MBEDTLS_SSL_DEBUG_MSG( 2, ( "server state: %d", ssl->state ) );
S
S    if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
S        return( ret );
S
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
S        ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )
S    {
S        if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
S            return( ret );
S    }
S#endif
S
S    switch( ssl->state )
S    {
S        case MBEDTLS_SSL_HELLO_REQUEST:
S            ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
S            break;
S
S        /*
S         *  <==   ClientHello
S         */
S        case MBEDTLS_SSL_CLIENT_HELLO:
S            ret = ssl_parse_client_hello( ssl );
S            break;
S
S#if defined(MBEDTLS_SSL_PROTO_DTLS)
S        case MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT:
S            return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );
S#endif
S
S        /*
S         *  ==>   ServerHello
S         *        Certificate
S         *      ( ServerKeyExchange  )
S         *      ( CertificateRequest )
S         *        ServerHelloDone
S         */
S        case MBEDTLS_SSL_SERVER_HELLO:
S            ret = ssl_write_server_hello( ssl );
S            break;
S
S        case MBEDTLS_SSL_SERVER_CERTIFICATE:
S            ret = mbedtls_ssl_write_certificate( ssl );
S            break;
S
S        case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
S            ret = ssl_write_server_key_exchange( ssl );
S            break;
S
S        case MBEDTLS_SSL_CERTIFICATE_REQUEST:
S            ret = ssl_write_certificate_request( ssl );
S            break;
S
S        case MBEDTLS_SSL_SERVER_HELLO_DONE:
S            ret = ssl_write_server_hello_done( ssl );
S            break;
S
S        /*
S         *  <== ( Certificate/Alert  )
S         *        ClientKeyExchange
S         *      ( CertificateVerify  )
S         *        ChangeCipherSpec
S         *        Finished
S         */
S        case MBEDTLS_SSL_CLIENT_CERTIFICATE:
S            ret = mbedtls_ssl_parse_certificate( ssl );
S            break;
S
S        case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:
S            ret = ssl_parse_client_key_exchange( ssl );
S            break;
S
S        case MBEDTLS_SSL_CERTIFICATE_VERIFY:
S            ret = ssl_parse_certificate_verify( ssl );
S            break;
S
S        case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:
S            ret = mbedtls_ssl_parse_change_cipher_spec( ssl );
S            break;
S
S        case MBEDTLS_SSL_CLIENT_FINISHED:
S            ret = mbedtls_ssl_parse_finished( ssl );
S            break;
S
S        /*
S         *  ==> ( NewSessionTicket )
S         *        ChangeCipherSpec
S         *        Finished
S         */
S        case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:
S#if defined(MBEDTLS_SSL_SESSION_TICKETS)
S            if( ssl->handshake->new_session_ticket != 0 )
S                ret = ssl_write_new_session_ticket( ssl );
S            else
S#endif
S                ret = mbedtls_ssl_write_change_cipher_spec( ssl );
S            break;
S
S        case MBEDTLS_SSL_SERVER_FINISHED:
S            ret = mbedtls_ssl_write_finished( ssl );
S            break;
S
S        case MBEDTLS_SSL_FLUSH_BUFFERS:
S            MBEDTLS_SSL_DEBUG_MSG( 2, ( "handshake: done" ) );
S            ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
S            break;
S
S        case MBEDTLS_SSL_HANDSHAKE_WRAPUP:
S            mbedtls_ssl_handshake_wrapup( ssl );
S            break;
S
S        default:
S            MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid state %d", ssl->state ) );
S            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
S    }
S
S    return( ret );
S}
N#endif /* MBEDTLS_SSL_SRV_C */
