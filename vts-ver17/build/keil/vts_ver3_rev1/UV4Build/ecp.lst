L 1 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\library\ecp.c"
N/*
N *  Elliptic curves over GF(p): generic functions
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N/*
N * References:
N *
N * SEC1 http://www.secg.org/index.php?action=secg,docs_secg
N * GECC = Guide to Elliptic Curve Cryptography - Hankerson, Menezes, Vanstone
N * FIPS 186-3 http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf
N * RFC 4492 for the related TLS structures and constants
N *
N * [Curve25519] http://cr.yp.to/ecdh/curve25519-20060209.pdf
N *
N * [2] CORON, Jean-S'ebastien. Resistance against differential power analysis
N *     for elliptic curve cryptosystems. In : Cryptographic Hardware and
N *     Embedded Systems. Springer Berlin Heidelberg, 1999. p. 292-302.
N *     <http://link.springer.com/chapter/10.1007/3-540-48059-5_25>
N *
N * [3] HEDABOU, Mustapha, PINEL, Pierre, et B'EN'ETEAU, Lucien. A comb method to
N *     render ECC resistant against Side Channel Attacks. IACR Cryptology
N *     ePrint Archive, 2004, vol. 2004, p. 342.
N *     <http://eprint.iacr.org/2004/342.pdf>
N */
N
N#if !defined(MBEDTLS_CONFIG_FILE)
X#if !0L
N#include "mbedtls/config.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls/config.h" 1
N/**
N * \file config.h
N *
N * \brief Configuration options (set of defines)
N *
N *  This set of compile-time options may be used to enable
N *  or disable features selectively, and reduce the global
N *  memory footprint.
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N#ifdef _RTE_
N#include "mbedTLS_config.h"
L 1 ".\RTE\Security\mbedTLS_config.h" 1
N/*
N *  Configuration template
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N/*
N * This set of compile-time options may be used to enable
N * or disable features selectively, and reduce the global
N * memory footprint.
N */
N#ifndef MBEDTLS_CONFIG_H
N#define MBEDTLS_CONFIG_H
N
N/* System support */
N//#define MBEDTLS_HAVE_ASM
N//#define MBEDTLS_HAVE_TIME
N//#define MBEDTLS_HAVE_TIME_DATE
N//#define MBEDTLS_PLATFORM_MEMORY
N//#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
N
N/* mbed TLS feature support */
N//#define MBEDTLS_AES_ROM_TABLES
N//#define MBEDTLS_CAMELLIA_SMALL_MEMORY
N//#define MBEDTLS_CIPHER_MODE_CBC
N//#define MBEDTLS_CIPHER_MODE_CFB
N//#define MBEDTLS_CIPHER_MODE_CTR
N//#define MBEDTLS_CIPHER_PADDING_PKCS7
N//#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
N//#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
N//#define MBEDTLS_CIPHER_PADDING_ZEROS
N//#define MBEDTLS_REMOVE_ARC4_CIPHERSUITES
N//#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
N//#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
N//#define MBEDTLS_ECP_DP_BP256R1_ENABLED
N//#define MBEDTLS_ECP_DP_BP384R1_ENABLED
N//#define MBEDTLS_ECP_DP_BP512R1_ENABLED
N//#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
N//#define MBEDTLS_ECP_NIST_OPTIM
N//#define MBEDTLS_ECDSA_DETERMINISTIC
N//#define MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
N//#define MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
N//#define MBEDTLS_PK_PARSE_EC_EXTENDED
N//#define MBEDTLS_ERROR_STRERROR_DUMMY
N//#define MBEDTLS_GENPRIME
N//#define MBEDTLS_FS_IO
N//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
N//#define MBEDTLS_NO_PLATFORM_ENTROPY
N//#define MBEDTLS_ENTROPY_FORCE_SHA256
N//#define MBEDTLS_MEMORY_DEBUG
N//#define MBEDTLS_MEMORY_BACKTRACE
N//#define MBEDTLS_PK_RSA_ALT_SUPPORT
N//#define MBEDTLS_PKCS1_V15
N//#define MBEDTLS_PKCS1_V21
N//#define MBEDTLS_RSA_NO_CRT
N//#define MBEDTLS_SELF_TEST
N//#define MBEDTLS_SHA256_SMALLER
N//#define MBEDTLS_SSL_AEAD_RANDOM_IV
N//#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
N//#define MBEDTLS_SSL_DEBUG_ALL
N//#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
N//#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
N//#define MBEDTLS_SSL_FALLBACK_SCSV
N//#define MBEDTLS_SSL_HW_RECORD_ACCEL
N//#define MBEDTLS_SSL_CBC_RECORD_SPLITTING
N//#define MBEDTLS_SSL_RENEGOTIATION
N//#define MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
N//#define MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE
N//#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
N//#define MBEDTLS_SSL_PROTO_SSL3
N//#define MBEDTLS_SSL_PROTO_TLS1
N//#define MBEDTLS_SSL_PROTO_TLS1_1
N//#define MBEDTLS_SSL_PROTO_TLS1_2
N//#define MBEDTLS_SSL_PROTO_DTLS
N//#define MBEDTLS_SSL_ALPN
N//#define MBEDTLS_SSL_DTLS_ANTI_REPLAY
N//#define MBEDTLS_SSL_DTLS_HELLO_VERIFY
N//#define MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
N//#define MBEDTLS_SSL_DTLS_BADMAC_LIMIT
N//#define MBEDTLS_SSL_SESSION_TICKETS
N//#define MBEDTLS_SSL_EXPORT_KEYS
N//#define MBEDTLS_SSL_SERVER_NAME_INDICATION
N//#define MBEDTLS_SSL_TRUNCATED_HMAC
N//#define MBEDTLS_VERSION_FEATURES
N//#define MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3
N//#define MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
N//#define MBEDTLS_X509_CHECK_KEY_USAGE
N//#define MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
N//#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
N
N/* mbed TLS modules */
N//#define MBEDTLS_AES_C
N//#define MBEDTLS_ARC4_C
N//#define MBEDTLS_ASN1_PARSE_C
N//#define MBEDTLS_ASN1_WRITE_C
N//#define MBEDTLS_BASE64_C
N//#define MBEDTLS_BIGNUM_C
N//#define MBEDTLS_BLOWFISH_C
N//#define MBEDTLS_CAMELLIA_C
N//#define MBEDTLS_CCM_C
N//#define MBEDTLS_CERTS_C
N//#define MBEDTLS_CIPHER_C
N//#define MBEDTLS_CTR_DRBG_C
N//#define MBEDTLS_DEBUG_C
N//#define MBEDTLS_DES_C
N//#define MBEDTLS_DHM_C
N//#define MBEDTLS_ECDH_C
N//#define MBEDTLS_ECDSA_C
N//#define MBEDTLS_ECJPAKE_C
N//#define MBEDTLS_ECP_C
N//#define MBEDTLS_ENTROPY_C
N//#define MBEDTLS_ERROR_C
N//#define MBEDTLS_GCM_C
N//#define MBEDTLS_HAVEGE_C
N//#define MBEDTLS_HMAC_DRBG_C
N//#define MBEDTLS_MD_C
N//#define MBEDTLS_MD2_C
N//#define MBEDTLS_MD4_C
N//#define MBEDTLS_MD5_C
N//#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
N//#define MBEDTLS_NET_C
N//#define MBEDTLS_OID_C
N//#define MBEDTLS_PEM_PARSE_C
N//#define MBEDTLS_PEM_WRITE_C
N//#define MBEDTLS_PK_C
N//#define MBEDTLS_PK_PARSE_C
N//#define MBEDTLS_PK_WRITE_C
N//#define MBEDTLS_PKCS5_C
N//#define MBEDTLS_PKCS11_C
N//#define MBEDTLS_PKCS12_C
N//#define MBEDTLS_PLATFORM_C
N//#define MBEDTLS_RIPEMD160_C
N//#define MBEDTLS_RSA_C
N//#define MBEDTLS_SHA1_C
N//#define MBEDTLS_SHA256_C
N//#define MBEDTLS_SHA512_C
N//#define MBEDTLS_SSL_CACHE_C
N//#define MBEDTLS_SSL_COOKIE_C
N//#define MBEDTLS_SSL_TICKET_C
N//#define MBEDTLS_SSL_CLI_C
N//#define MBEDTLS_SSL_SRV_C
N//#define MBEDTLS_SSL_TLS_C
N//#define MBEDTLS_THREADING_C
N//#define MBEDTLS_TIMING_C
N//#define MBEDTLS_VERSION_C
N//#define MBEDTLS_X509_USE_C
N//#define MBEDTLS_X509_CRT_PARSE_C
N//#define MBEDTLS_X509_CRL_PARSE_C
N//#define MBEDTLS_X509_CSR_PARSE_C
N//#define MBEDTLS_X509_CREATE_C
N//#define MBEDTLS_X509_CRT_WRITE_C
N//#define MBEDTLS_X509_CSR_WRITE_C
N//#define MBEDTLS_XTEA_C
N
N#include "check_config.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls\check_config.h" 1
N/**
N * \file check_config.h
N *
N * \brief Consistency checks for configuration options
N *
N *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
N *  SPDX-License-Identifier: Apache-2.0
N *
N *  Licensed under the Apache License, Version 2.0 (the "License"); you may
N *  not use this file except in compliance with the License.
N *  You may obtain a copy of the License at
N *
N *  http://www.apache.org/licenses/LICENSE-2.0
N *
N *  Unless required by applicable law or agreed to in writing, software
N *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N *  See the License for the specific language governing permissions and
N *  limitations under the License.
N *
N *  This file is part of mbed TLS (https://tls.mbed.org)
N */
N
N/*
N * It is recommended to include this file from your config.h
N * in order to catch dependency issues early.
N */
N
N#ifndef MBEDTLS_CHECK_CONFIG_H
N#define MBEDTLS_CHECK_CONFIG_H
N
N/*
N * We assume CHAR_BIT is 8 in many places. In practice, this is true on our
N * target platforms, so not an issue, but let's just be extra sure.
N */
N#include <limits.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision: 190986 $
N * Checkin $Date: 2015-02-04 14:26:49 +0000 (Wed, 04 Feb 2015) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5060002
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
S  #define CHAR_MIN (-128)
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 127
S      /* maximum value for an object of type char */
N#else
N  #define CHAR_MIN 0
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 255
N      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MIN  (~0x7fffffffffffffffL)
N#else
N  #define LONG_MIN  (~0x7fffffffL)
N#endif
N    /* minimum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MAX  0x7fffffffffffffffL
N#else
N  #define LONG_MAX  0x7fffffffL
N#endif
N    /* maximum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define ULONG_MAX 0xffffffffffffffffUL
N#else
N  #define ULONG_MAX 0xffffffffUL
N#endif
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 37 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls\check_config.h" 2
N#if CHAR_BIT != 8
X#if 8 != 8
S#error "mbed TLS requires a platform with 8-bit chars"
N#endif
N
N#if defined(_WIN32)
X#if 0L
S#if !defined(MBEDTLS_PLATFORM_C)
S#error "MBEDTLS_PLATFORM_C is required on Windows"
S#endif
S
S/* Fix the config here. Not convenient to put an #ifdef _WIN32 in config.h as
S * it would confuse config.pl. */
S#if !defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) && \
S    !defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO)
X#if !defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) &&     !defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO)
S#define MBEDTLS_PLATFORM_SNPRINTF_ALT
S#endif
N#endif /* _WIN32 */
N
N#if defined(TARGET_LIKE_MBED) && \
N    ( defined(MBEDTLS_NET_C) || defined(MBEDTLS_TIMING_C) )
X#if 0L &&     ( 0L || 0L )
S#error "The NET and TIMING modules are not available for mbed OS - please use the network and timing functions provided by mbed OS"
N#endif
N
N#if defined(MBEDTLS_DEPRECATED_WARNING) && \
N    !defined(__GNUC__) && !defined(__clang__)
X#if 0L &&     !0L && !0L
S#error "MBEDTLS_DEPRECATED_WARNING only works with GCC and Clang"
N#endif
N
N#if defined(MBEDTLS_HAVE_TIME_DATE) && !defined(MBEDTLS_HAVE_TIME)
X#if 0L && !0L
S#error "MBEDTLS_HAVE_TIME_DATE without MBEDTLS_HAVE_TIME does not make sense"
N#endif
N
N#if defined(MBEDTLS_AESNI_C) && !defined(MBEDTLS_HAVE_ASM)
X#if 0L && !0L
S#error "MBEDTLS_AESNI_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_CTR_DRBG_C) && !defined(MBEDTLS_AES_C)
X#if 0L && !0L
S#error "MBEDTLS_CTR_DRBG_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_DHM_C) && !defined(MBEDTLS_BIGNUM_C)
X#if 0L && !0L
S#error "MBEDTLS_DHM_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECDH_C) && !defined(MBEDTLS_ECP_C)
X#if 0L && !0L
S#error "MBEDTLS_ECDH_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECDSA_C) &&            \
N    ( !defined(MBEDTLS_ECP_C) ||           \
N      !defined(MBEDTLS_ASN1_PARSE_C) ||    \
N      !defined(MBEDTLS_ASN1_WRITE_C) )
X#if 0L &&                ( !0L ||                 !0L ||          !0L )
S#error "MBEDTLS_ECDSA_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECJPAKE_C) &&           \
N    ( !defined(MBEDTLS_ECP_C) || !defined(MBEDTLS_MD_C) )
X#if 0L &&               ( !0L || !0L )
S#error "MBEDTLS_ECJPAKE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECDSA_DETERMINISTIC) && !defined(MBEDTLS_HMAC_DRBG_C)
X#if 0L && !0L
S#error "MBEDTLS_ECDSA_DETERMINISTIC defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ECP_C) && ( !defined(MBEDTLS_BIGNUM_C) || (   \
N    !defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)   &&                  \
N    !defined(MBEDTLS_ECP_DP_BP384R1_ENABLED)   &&                  \
N    !defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)   &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) &&                  \
N    !defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED) ) )
X#if 0L && ( !0L || (       !0L &&                      !0L &&                      !0L &&                      !0L &&                      !0L &&                      !0L   &&                      !0L   &&                      !0L   &&                      !0L &&                      !0L &&                      !0L ) )
S#error "MBEDTLS_ECP_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_ENTROPY_C) && (!defined(MBEDTLS_SHA512_C) &&      \
N                                    !defined(MBEDTLS_SHA256_C))
X#if 0L && (!0L &&                                          !0L)
S#error "MBEDTLS_ENTROPY_C defined, but not all prerequisites"
N#endif
N#if defined(MBEDTLS_ENTROPY_C) && defined(MBEDTLS_SHA512_C) &&         \
N    defined(MBEDTLS_CTR_DRBG_ENTROPY_LEN) && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 64)
X#if 0L && 0L &&             0L && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 64)
S#error "MBEDTLS_CTR_DRBG_ENTROPY_LEN value too high"
N#endif
N#if defined(MBEDTLS_ENTROPY_C) &&                                            \
N    ( !defined(MBEDTLS_SHA512_C) || defined(MBEDTLS_ENTROPY_FORCE_SHA256) ) \
N    && defined(MBEDTLS_CTR_DRBG_ENTROPY_LEN) && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 32)
X#if 0L &&                                                ( !0L || 0L )     && 0L && (MBEDTLS_CTR_DRBG_ENTROPY_LEN > 32)
S#error "MBEDTLS_CTR_DRBG_ENTROPY_LEN value too high"
N#endif
N#if defined(MBEDTLS_ENTROPY_C) && \
N    defined(MBEDTLS_ENTROPY_FORCE_SHA256) && !defined(MBEDTLS_SHA256_C)
X#if 0L &&     0L && !0L
S#error "MBEDTLS_ENTROPY_FORCE_SHA256 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_GCM_C) && (                                        \
N        !defined(MBEDTLS_AES_C) && !defined(MBEDTLS_CAMELLIA_C) )
X#if 0L && (                                                !0L && !0L )
S#error "MBEDTLS_GCM_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_HAVEGE_C) && !defined(MBEDTLS_TIMING_C)
X#if 0L && !0L
S#error "MBEDTLS_HAVEGE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_HMAC_DRBG_C) && !defined(MBEDTLS_MD_C)
X#if 0L && !0L
S#error "MBEDTLS_HMAC_DRBG_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) )
X#if 0L &&                     ( !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) )
X#if 0L &&                     ( !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED) && !defined(MBEDTLS_DHM_C)
X#if 0L && !0L
S#error "MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) &&                     \
N    !defined(MBEDTLS_ECDH_C)
X#if 0L &&                         !0L
S#error "MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) &&                   \
N    ( !defined(MBEDTLS_DHM_C) || !defined(MBEDTLS_RSA_C) ||           \
N      !defined(MBEDTLS_X509_CRT_PARSE_C) || !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                       ( !0L || !0L ||                 !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_RSA_C) ||          \
N      !defined(MBEDTLS_X509_CRT_PARSE_C) || !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                     ( !0L || !0L ||                !0L || !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) &&                 \
N    ( !defined(MBEDTLS_ECDH_C) || !defined(MBEDTLS_ECDSA_C) ||          \
N      !defined(MBEDTLS_X509_CRT_PARSE_C) )
X#if 0L &&                     ( !0L || !0L ||                !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED) &&                   \
N    ( !defined(MBEDTLS_RSA_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) || \
N      !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                       ( !0L || !0L ||       !0L )
S#error "MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) &&                       \
N    ( !defined(MBEDTLS_RSA_C) || !defined(MBEDTLS_X509_CRT_PARSE_C) || \
N      !defined(MBEDTLS_PKCS1_V15) )
X#if 0L &&                           ( !0L || !0L ||       !0L )
S#error "MBEDTLS_KEY_EXCHANGE_RSA_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED) &&                    \
N    ( !defined(MBEDTLS_ECJPAKE_C) || !defined(MBEDTLS_SHA256_C) ||      \
N      !defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) )
X#if 0L &&                        ( !0L || !0L ||            !0L )
S#error "MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_MEMORY_BUFFER_ALLOC_C) &&                          \
N    ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
X#if 0L &&                              ( !0L || !0L )
S#error "MBEDTLS_MEMORY_BUFFER_ALLOC_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PADLOCK_C) && !defined(MBEDTLS_HAVE_ASM)
X#if 0L && !0L
S#error "MBEDTLS_PADLOCK_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PEM_PARSE_C) && !defined(MBEDTLS_BASE64_C)
X#if 0L && !0L
S#error "MBEDTLS_PEM_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PEM_WRITE_C) && !defined(MBEDTLS_BASE64_C)
X#if 0L && !0L
S#error "MBEDTLS_PEM_WRITE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PK_C) && \
N    ( !defined(MBEDTLS_RSA_C) && !defined(MBEDTLS_ECP_C) )
X#if 0L &&     ( !0L && !0L )
S#error "MBEDTLS_PK_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PK_PARSE_C) && !defined(MBEDTLS_PK_C)
X#if 0L && !0L
S#error "MBEDTLS_PK_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PK_WRITE_C) && !defined(MBEDTLS_PK_C)
X#if 0L && !0L
S#error "MBEDTLS_PK_WRITE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PKCS11_C) && !defined(MBEDTLS_PK_C)
X#if 0L && !0L
S#error "MBEDTLS_PKCS11_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_EXIT_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_EXIT_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_EXIT_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_EXIT_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_EXIT_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_EXIT) ||\
N        defined(MBEDTLS_PLATFORM_EXIT_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_EXIT_MACRO and MBEDTLS_PLATFORM_STD_EXIT/MBEDTLS_PLATFORM_EXIT_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FPRINTF_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_FPRINTF_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FPRINTF_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_FPRINTF_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FPRINTF_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_FPRINTF) ||\
N        defined(MBEDTLS_PLATFORM_FPRINTF_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_FPRINTF_MACRO and MBEDTLS_PLATFORM_STD_FPRINTF/MBEDTLS_PLATFORM_FPRINTF_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FREE_MACRO) &&\
N    ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
X#if 0L &&    ( !0L || !0L )
S#error "MBEDTLS_PLATFORM_FREE_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FREE_MACRO) &&\
N    defined(MBEDTLS_PLATFORM_STD_FREE)
X#if 0L &&    0L
S#error "MBEDTLS_PLATFORM_FREE_MACRO and MBEDTLS_PLATFORM_STD_FREE cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_FREE_MACRO) && !defined(MBEDTLS_PLATFORM_CALLOC_MACRO)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_CALLOC_MACRO must be defined if MBEDTLS_PLATFORM_FREE_MACRO is"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_CALLOC_MACRO) &&\
N    ( !defined(MBEDTLS_PLATFORM_C) || !defined(MBEDTLS_PLATFORM_MEMORY) )
X#if 0L &&    ( !0L || !0L )
S#error "MBEDTLS_PLATFORM_CALLOC_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_CALLOC_MACRO) &&\
N    defined(MBEDTLS_PLATFORM_STD_CALLOC)
X#if 0L &&    0L
S#error "MBEDTLS_PLATFORM_CALLOC_MACRO and MBEDTLS_PLATFORM_STD_CALLOC cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_CALLOC_MACRO) && !defined(MBEDTLS_PLATFORM_FREE_MACRO)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_FREE_MACRO must be defined if MBEDTLS_PLATFORM_CALLOC_MACRO is"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_MEMORY) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_MEMORY defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_PRINTF_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_PRINTF_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_PRINTF_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_PRINTF_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_PRINTF_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_PRINTF) ||\
N        defined(MBEDTLS_PLATFORM_PRINTF_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_PRINTF_MACRO and MBEDTLS_PLATFORM_STD_PRINTF/MBEDTLS_PLATFORM_PRINTF_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_SNPRINTF_ALT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO) && !defined(MBEDTLS_PLATFORM_C)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_SNPRINTF_MACRO defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_SNPRINTF_MACRO) &&\
N    ( defined(MBEDTLS_PLATFORM_STD_SNPRINTF) ||\
N        defined(MBEDTLS_PLATFORM_SNPRINTF_ALT) )
X#if 0L &&    ( 0L ||        0L )
S#error "MBEDTLS_PLATFORM_SNPRINTF_MACRO and MBEDTLS_PLATFORM_STD_SNPRINTF/MBEDTLS_PLATFORM_SNPRINTF_ALT cannot be defined simultaneously"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_MEM_HDR) &&\
N    !defined(MBEDTLS_PLATFORM_NO_STD_FUNCTIONS)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_MEM_HDR defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_CALLOC) && !defined(MBEDTLS_PLATFORM_MEMORY)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_STD_CALLOC defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_CALLOC) && !defined(MBEDTLS_PLATFORM_MEMORY)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_STD_CALLOC defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_FREE) && !defined(MBEDTLS_PLATFORM_MEMORY)
X#if 0L && !0L
S#error "MBEDTLS_PLATFORM_STD_FREE defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_EXIT) &&\
N    !defined(MBEDTLS_PLATFORM_EXIT_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_EXIT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_FPRINTF) &&\
N    !defined(MBEDTLS_PLATFORM_FPRINTF_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_FPRINTF defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_PRINTF) &&\
N    !defined(MBEDTLS_PLATFORM_PRINTF_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_PRINTF defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_PLATFORM_STD_SNPRINTF) &&\
N    !defined(MBEDTLS_PLATFORM_SNPRINTF_ALT)
X#if 0L &&    !0L
S#error "MBEDTLS_PLATFORM_STD_SNPRINTF defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_RSA_C) && ( !defined(MBEDTLS_BIGNUM_C) ||         \
N    !defined(MBEDTLS_OID_C) )
X#if 0L && ( !0L ||             !0L )
S#error "MBEDTLS_RSA_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT) &&                        \
N    ( !defined(MBEDTLS_RSA_C) || !defined(MBEDTLS_PKCS1_V21) )
X#if 0L &&                            ( !0L || !0L )
S#error "MBEDTLS_X509_RSASSA_PSS_SUPPORT defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_SSL3) && ( !defined(MBEDTLS_MD5_C) ||     \
N    !defined(MBEDTLS_SHA1_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_PROTO_SSL3 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_TLS1) && ( !defined(MBEDTLS_MD5_C) ||     \
N    !defined(MBEDTLS_SHA1_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_PROTO_TLS1 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_TLS1_1) && ( !defined(MBEDTLS_MD5_C) ||     \
N    !defined(MBEDTLS_SHA1_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_PROTO_TLS1_1 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && ( !defined(MBEDTLS_SHA1_C) &&     \
N    !defined(MBEDTLS_SHA256_C) && !defined(MBEDTLS_SHA512_C) )
X#if 0L && ( !0L &&         !0L && !0L )
S#error "MBEDTLS_SSL_PROTO_TLS1_2 defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_PROTO_DTLS)     && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1)  && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if 0L     &&     !0L  &&     !0L
S#error "MBEDTLS_SSL_PROTO_DTLS defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_CLI_C) && !defined(MBEDTLS_SSL_TLS_C)
X#if 0L && !0L
S#error "MBEDTLS_SSL_CLI_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && ( !defined(MBEDTLS_CIPHER_C) ||     \
N    !defined(MBEDTLS_MD_C) )
X#if 0L && ( !0L ||         !0L )
S#error "MBEDTLS_SSL_TLS_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_SRV_C) && !defined(MBEDTLS_SSL_TLS_C)
X#if 0L && !0L
S#error "MBEDTLS_SSL_SRV_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (!defined(MBEDTLS_SSL_PROTO_SSL3) && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1) && !defined(MBEDTLS_SSL_PROTO_TLS1_1) && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2))
X#if 0L && (!0L &&     !0L && !0L &&     !0L)
S#error "MBEDTLS_SSL_TLS_C defined, but no protocols are active"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (defined(MBEDTLS_SSL_PROTO_SSL3) && \
N    defined(MBEDTLS_SSL_PROTO_TLS1_1) && !defined(MBEDTLS_SSL_PROTO_TLS1))
X#if 0L && (0L &&     0L && !0L)
S#error "Illegal protocol selection"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (defined(MBEDTLS_SSL_PROTO_TLS1) && \
N    defined(MBEDTLS_SSL_PROTO_TLS1_2) && !defined(MBEDTLS_SSL_PROTO_TLS1_1))
X#if 0L && (0L &&     0L && !0L)
S#error "Illegal protocol selection"
N#endif
N
N#if defined(MBEDTLS_SSL_TLS_C) && (defined(MBEDTLS_SSL_PROTO_SSL3) && \
N    defined(MBEDTLS_SSL_PROTO_TLS1_2) && (!defined(MBEDTLS_SSL_PROTO_TLS1) || \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1)))
X#if 0L && (0L &&     0L && (!0L ||     !0L))
S#error "Illegal protocol selection"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && !defined(MBEDTLS_SSL_PROTO_DTLS)
X#if 0L && !0L
S#error "MBEDTLS_SSL_DTLS_HELLO_VERIFY  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && \
N    !defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
X#if 0L &&     !0L
S#error "MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY) &&                              \
N    ( !defined(MBEDTLS_SSL_TLS_C) || !defined(MBEDTLS_SSL_PROTO_DTLS) )
X#if 0L &&                                  ( !0L || !0L )
S#error "MBEDTLS_SSL_DTLS_ANTI_REPLAY  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT) &&                              \
N    ( !defined(MBEDTLS_SSL_TLS_C) || !defined(MBEDTLS_SSL_PROTO_DTLS) )
X#if 0L &&                                  ( !0L || !0L )
S#error "MBEDTLS_SSL_DTLS_BADMAC_LIMIT  defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC) &&   \
N    !defined(MBEDTLS_SSL_PROTO_TLS1)   &&      \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1) &&      \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if 0L &&       !0L   &&          !0L &&          !0L
S#error "MBEDTLS_SSL_ENCRYPT_THEN_MAC defined, but not all prerequsites"
N#endif
N
N#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET) && \
N    !defined(MBEDTLS_SSL_PROTO_TLS1)   &&          \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_1) &&          \
N    !defined(MBEDTLS_SSL_PROTO_TLS1_2)
X#if 0L &&     !0L   &&              !0L &&              !0L
S#error "MBEDTLS_SSL_EXTENDED_MASTER_SECRET defined, but not all prerequsites"
N#endif
N
N#if defined(MBEDTLS_SSL_TICKET_C) && !defined(MBEDTLS_CIPHER_C)
X#if 0L && !0L
S#error "MBEDTLS_SSL_TICKET_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING) && \
N    !defined(MBEDTLS_SSL_PROTO_SSL3) && !defined(MBEDTLS_SSL_PROTO_TLS1)
X#if 0L &&     !0L && !0L
S#error "MBEDTLS_SSL_CBC_RECORD_SPLITTING defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION) && \
N        !defined(MBEDTLS_X509_CRT_PARSE_C)
X#if 0L &&         !0L
S#error "MBEDTLS_SSL_SERVER_NAME_INDICATION defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_THREADING_PTHREAD)
X#if 0L
S#if !defined(MBEDTLS_THREADING_C) || defined(MBEDTLS_THREADING_IMPL)
S#error "MBEDTLS_THREADING_PTHREAD defined, but not all prerequisites"
S#endif
S#define MBEDTLS_THREADING_IMPL
N#endif
N
N#if defined(MBEDTLS_THREADING_ALT)
X#if 0L
S#if !defined(MBEDTLS_THREADING_C) || defined(MBEDTLS_THREADING_IMPL)
S#error "MBEDTLS_THREADING_ALT defined, but not all prerequisites"
S#endif
S#define MBEDTLS_THREADING_IMPL
N#endif
N
N#if defined(MBEDTLS_THREADING_C) && !defined(MBEDTLS_THREADING_IMPL)
X#if 0L && !0L
S#error "MBEDTLS_THREADING_C defined, single threading implementation required"
N#endif
N#undef MBEDTLS_THREADING_IMPL
N
N#if defined(MBEDTLS_VERSION_FEATURES) && !defined(MBEDTLS_VERSION_C)
X#if 0L && !0L
S#error "MBEDTLS_VERSION_FEATURES defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_USE_C) && ( !defined(MBEDTLS_BIGNUM_C) ||  \
N    !defined(MBEDTLS_OID_C) || !defined(MBEDTLS_ASN1_PARSE_C) ||      \
N    !defined(MBEDTLS_PK_PARSE_C) )
X#if 0L && ( !0L ||      !0L || !0L ||          !0L )
S#error "MBEDTLS_X509_USE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CREATE_C) && ( !defined(MBEDTLS_BIGNUM_C) ||  \
N    !defined(MBEDTLS_OID_C) || !defined(MBEDTLS_ASN1_WRITE_C) ||       \
N    !defined(MBEDTLS_PK_WRITE_C) )
X#if 0L && ( !0L ||      !0L || !0L ||           !0L )
S#error "MBEDTLS_X509_CREATE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CRT_PARSE_C) && ( !defined(MBEDTLS_X509_USE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CRT_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CRL_PARSE_C) && ( !defined(MBEDTLS_X509_USE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CRL_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CSR_PARSE_C) && ( !defined(MBEDTLS_X509_USE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CSR_PARSE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CRT_WRITE_C) && ( !defined(MBEDTLS_X509_CREATE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CRT_WRITE_C defined, but not all prerequisites"
N#endif
N
N#if defined(MBEDTLS_X509_CSR_WRITE_C) && ( !defined(MBEDTLS_X509_CREATE_C) )
X#if 0L && ( !0L )
S#error "MBEDTLS_X509_CSR_WRITE_C defined, but not all prerequisites"
N#endif
N
N/*
N * Avoid warning from -pedantic. This is a convenient place for this
N * workaround since this is included by every single file before the
N * #if defined(MBEDTLS_xxx_C) that results in emtpy translation units.
N */
Ntypedef int mbedtls_iso_c_forbids_empty_translation_units;
N
N#endif /* MBEDTLS_CHECK_CONFIG_H */
L 186 ".\RTE\Security\mbedTLS_config.h" 2
N
N#endif /* MBEDTLS_CONFIG_H */
L 30 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\include\mbedtls/config.h" 2
N#endif
N
N#ifndef MBEDTLS_CONFIG_H
S#define MBEDTLS_CONFIG_H
S
S#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
S#define _CRT_SECURE_NO_DEPRECATE 1
S#endif
S
S/**
S * \name SECTION: System support
S *
S * This section sets system specific settings.
S * \{
S */
S
S/**
S * \def MBEDTLS_HAVE_ASM
S *
S * The compiler has support for asm().
S *
S * Requires support for asm() in compiler.
S *
S * Used in:
S *      library/timing.c
S *      library/padlock.c
S *      include/mbedtls/bn_mul.h
S *
S * Comment to disable the use of assembly code.
S */
S#define MBEDTLS_HAVE_ASM
S
S/**
S * \def MBEDTLS_HAVE_SSE2
S *
S * CPU supports SSE2 instruction set.
S *
S * Uncomment if the CPU supports SSE2 (IA-32 specific).
S */
S//#define MBEDTLS_HAVE_SSE2
S
S/**
S * \def MBEDTLS_HAVE_TIME
S *
S * System has time.h and time().
S * The time does not need to be correct, only time differences are used,
S * by contrast with MBEDTLS_HAVE_TIME_DATE
S *
S * Comment if your system does not support time functions
S */
S#define MBEDTLS_HAVE_TIME
S
S/**
S * \def MBEDTLS_HAVE_TIME_DATE
S *
S * System has time.h and time(), gmtime() and the clock is correct.
S * The time needs to be correct (not necesarily very accurate, but at least
S * the date should be correct). This is used to verify the validity period of
S * X.509 certificates.
S *
S * Comment if your system does not have a correct clock.
S */
S#define MBEDTLS_HAVE_TIME_DATE
S
S/**
S * \def MBEDTLS_PLATFORM_MEMORY
S *
S * Enable the memory allocation layer.
S *
S * By default mbed TLS uses the system-provided calloc() and free().
S * This allows different allocators (self-implemented or provided) to be
S * provided to the platform abstraction layer.
S *
S * Enabling MBEDTLS_PLATFORM_MEMORY without the
S * MBEDTLS_PLATFORM_{FREE,CALLOC}_MACROs will provide
S * "mbedtls_platform_set_calloc_free()" allowing you to set an alternative calloc() and
S * free() function pointer at runtime.
S *
S * Enabling MBEDTLS_PLATFORM_MEMORY and specifying
S * MBEDTLS_PLATFORM_{CALLOC,FREE}_MACROs will allow you to specify the
S * alternate function at compile time.
S *
S * Requires: MBEDTLS_PLATFORM_C
S *
S * Enable this layer to allow use of alternative memory allocators.
S */
S//#define MBEDTLS_PLATFORM_MEMORY
S
S/**
S * \def MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
S *
S * Do not assign standard functions in the platform layer (e.g. calloc() to
S * MBEDTLS_PLATFORM_STD_CALLOC and printf() to MBEDTLS_PLATFORM_STD_PRINTF)
S *
S * This makes sure there are no linking errors on platforms that do not support
S * these functions. You will HAVE to provide alternatives, either at runtime
S * via the platform_set_xxx() functions or at compile time by setting
S * the MBEDTLS_PLATFORM_STD_XXX defines, or enabling a
S * MBEDTLS_PLATFORM_XXX_MACRO.
S *
S * Requires: MBEDTLS_PLATFORM_C
S *
S * Uncomment to prevent default assignment of standard functions in the
S * platform layer.
S */
S//#define MBEDTLS_PLATFORM_NO_STD_FUNCTIONS
S
S/**
S * \def MBEDTLS_PLATFORM_EXIT_ALT
S *
S * MBEDTLS_PLATFORM_XXX_ALT: Uncomment a macro to let mbed TLS support the
S * function in the platform abstraction layer.
S *
S * Example: In case you uncomment MBEDTLS_PLATFORM_PRINTF_ALT, mbed TLS will
S * provide a function "mbedtls_platform_set_printf()" that allows you to set an
S * alternative printf function pointer.
S *
S * All these define require MBEDTLS_PLATFORM_C to be defined!
S *
S * \note MBEDTLS_PLATFORM_SNPRINTF_ALT is required on Windows;
S * it will be enabled automatically by check_config.h
S *
S * \warning MBEDTLS_PLATFORM_XXX_ALT cannot be defined at the same time as
S * MBEDTLS_PLATFORM_XXX_MACRO!
S *
S * Uncomment a macro to enable alternate implementation of specific base
S * platform function
S */
S//#define MBEDTLS_PLATFORM_EXIT_ALT
S//#define MBEDTLS_PLATFORM_FPRINTF_ALT
S//#define MBEDTLS_PLATFORM_PRINTF_ALT
S//#define MBEDTLS_PLATFORM_SNPRINTF_ALT
S
S/**
S * \def MBEDTLS_DEPRECATED_WARNING
S *
S * Mark deprecated functions so that they generate a warning if used.
S * Functions deprecated in one version will usually be removed in the next
S * version. You can enable this to help you prepare the transition to a new
S * major version by making sure your code is not using these functions.
S *
S * This only works with GCC and Clang. With other compilers, you may want to
S * use MBEDTLS_DEPRECATED_REMOVED
S *
S * Uncomment to get warnings on using deprecated functions.
S */
S//#define MBEDTLS_DEPRECATED_WARNING
S
S/**
S * \def MBEDTLS_DEPRECATED_REMOVED
S *
S * Remove deprecated functions so that they generate an error if used.
S * Functions deprecated in one version will usually be removed in the next
S * version. You can enable this to help you prepare the transition to a new
S * major version by making sure your code is not using these functions.
S *
S * Uncomment to get errors on using deprecated functions.
S */
S//#define MBEDTLS_DEPRECATED_REMOVED
S
S/* \} name SECTION: System support */
S
S/**
S * \name SECTION: mbed TLS feature support
S *
S * This section sets support for features that are or are not needed
S * within the modules that are enabled.
S * \{
S */
S
S/**
S * \def MBEDTLS_TIMING_ALT
S *
S * Uncomment to provide your own alternate implementation for mbedtls_timing_hardclock(),
S * mbedtls_timing_get_timer(), mbedtls_set_alarm(), mbedtls_set/get_delay()
S *
S * Only works if you have MBEDTLS_TIMING_C enabled.
S *
S * You will need to provide a header "timing_alt.h" and an implementation at
S * compile time.
S */
S//#define MBEDTLS_TIMING_ALT
S
S/**
S * \def MBEDTLS_AES_ALT
S *
S * MBEDTLS__MODULE_NAME__ALT: Uncomment a macro to let mbed TLS use your
S * alternate core implementation of a symmetric crypto or hash module (e.g.
S * platform specific assembly optimized implementations). Keep in mind that
S * the function prototypes should remain the same.
S *
S * This replaces the whole module. If you only want to replace one of the
S * functions, use one of the MBEDTLS__FUNCTION_NAME__ALT flags.
S *
S * Example: In case you uncomment MBEDTLS_AES_ALT, mbed TLS will no longer
S * provide the "struct mbedtls_aes_context" definition and omit the base function
S * declarations and implementations. "aes_alt.h" will be included from
S * "aes.h" to include the new function definitions.
S *
S * Uncomment a macro to enable alternate implementation of the corresponding
S * module.
S */
S//#define MBEDTLS_AES_ALT
S//#define MBEDTLS_ARC4_ALT
S//#define MBEDTLS_BLOWFISH_ALT
S//#define MBEDTLS_CAMELLIA_ALT
S//#define MBEDTLS_DES_ALT
S//#define MBEDTLS_XTEA_ALT
S//#define MBEDTLS_MD2_ALT
S//#define MBEDTLS_MD4_ALT
S//#define MBEDTLS_MD5_ALT
S//#define MBEDTLS_RIPEMD160_ALT
S//#define MBEDTLS_SHA1_ALT
S//#define MBEDTLS_SHA256_ALT
S//#define MBEDTLS_SHA512_ALT
S
S/**
S * \def MBEDTLS_MD2_PROCESS_ALT
S *
S * MBEDTLS__FUNCTION_NAME__ALT: Uncomment a macro to let mbed TLS use you
S * alternate core implementation of symmetric crypto or hash function. Keep in
S * mind that function prototypes should remain the same.
S *
S * This replaces only one function. The header file from mbed TLS is still
S * used, in contrast to the MBEDTLS__MODULE_NAME__ALT flags.
S *
S * Example: In case you uncomment MBEDTLS_SHA256_PROCESS_ALT, mbed TLS will
S * no longer provide the mbedtls_sha1_process() function, but it will still provide
S * the other function (using your mbedtls_sha1_process() function) and the definition
S * of mbedtls_sha1_context, so your implementation of mbedtls_sha1_process must be compatible
S * with this definition.
S *
S * Note: if you use the AES_xxx_ALT macros, then is is recommended to also set
S * MBEDTLS_AES_ROM_TABLES in order to help the linker garbage-collect the AES
S * tables.
S *
S * Uncomment a macro to enable alternate implementation of the corresponding
S * function.
S */
S//#define MBEDTLS_MD2_PROCESS_ALT
S//#define MBEDTLS_MD4_PROCESS_ALT
S//#define MBEDTLS_MD5_PROCESS_ALT
S//#define MBEDTLS_RIPEMD160_PROCESS_ALT
S//#define MBEDTLS_SHA1_PROCESS_ALT
S//#define MBEDTLS_SHA256_PROCESS_ALT
S//#define MBEDTLS_SHA512_PROCESS_ALT
S//#define MBEDTLS_DES_SETKEY_ALT
S//#define MBEDTLS_DES_CRYPT_ECB_ALT
S//#define MBEDTLS_DES3_CRYPT_ECB_ALT
S//#define MBEDTLS_AES_SETKEY_ENC_ALT
S//#define MBEDTLS_AES_SETKEY_DEC_ALT
S//#define MBEDTLS_AES_ENCRYPT_ALT
S//#define MBEDTLS_AES_DECRYPT_ALT
S
S/**
S * \def MBEDTLS_ENTROPY_HARDWARE_ALT
S *
S * Uncomment this macro to let mbed TLS use your own implementation of a
S * hardware entropy collector.
S *
S * Your function must be called \c mbedtls_hardware_poll(), have the same
S * prototype as declared in entropy_poll.h, and accept NULL as first argument.
S *
S * Uncomment to use your own hardware entropy collector.
S */
S//#define MBEDTLS_ENTROPY_HARDWARE_ALT
S
S/**
S * \def MBEDTLS_AES_ROM_TABLES
S *
S * Store the AES tables in ROM.
S *
S * Uncomment this macro to store the AES tables in ROM.
S */
S//#define MBEDTLS_AES_ROM_TABLES
S
S/**
S * \def MBEDTLS_CAMELLIA_SMALL_MEMORY
S *
S * Use less ROM for the Camellia implementation (saves about 768 bytes).
S *
S * Uncomment this macro to use less memory for Camellia.
S */
S//#define MBEDTLS_CAMELLIA_SMALL_MEMORY
S
S/**
S * \def MBEDTLS_CIPHER_MODE_CBC
S *
S * Enable Cipher Block Chaining mode (CBC) for symmetric ciphers.
S */
S#define MBEDTLS_CIPHER_MODE_CBC
S
S/**
S * \def MBEDTLS_CIPHER_MODE_CFB
S *
S * Enable Cipher Feedback mode (CFB) for symmetric ciphers.
S */
S#define MBEDTLS_CIPHER_MODE_CFB
S
S/**
S * \def MBEDTLS_CIPHER_MODE_CTR
S *
S * Enable Counter Block Cipher mode (CTR) for symmetric ciphers.
S */
S#define MBEDTLS_CIPHER_MODE_CTR
S
S/**
S * \def MBEDTLS_CIPHER_NULL_CIPHER
S *
S * Enable NULL cipher.
S * Warning: Only do so when you know what you are doing. This allows for
S * encryption or channels without any security!
S *
S * Requires MBEDTLS_ENABLE_WEAK_CIPHERSUITES as well to enable
S * the following ciphersuites:
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_NULL_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_NULL_SHA
S *      MBEDTLS_TLS_RSA_WITH_NULL_SHA256
S *      MBEDTLS_TLS_RSA_WITH_NULL_SHA
S *      MBEDTLS_TLS_RSA_WITH_NULL_MD5
S *      MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_NULL_SHA
S *      MBEDTLS_TLS_PSK_WITH_NULL_SHA384
S *      MBEDTLS_TLS_PSK_WITH_NULL_SHA256
S *      MBEDTLS_TLS_PSK_WITH_NULL_SHA
S *
S * Uncomment this macro to enable the NULL cipher and ciphersuites
S */
S//#define MBEDTLS_CIPHER_NULL_CIPHER
S
S/**
S * \def MBEDTLS_CIPHER_PADDING_PKCS7
S *
S * MBEDTLS_CIPHER_PADDING_XXX: Uncomment or comment macros to add support for
S * specific padding modes in the cipher layer with cipher modes that support
S * padding (e.g. CBC)
S *
S * If you disable all padding modes, only full blocks can be used with CBC.
S *
S * Enable padding modes in the cipher layer.
S */
S#define MBEDTLS_CIPHER_PADDING_PKCS7
S#define MBEDTLS_CIPHER_PADDING_ONE_AND_ZEROS
S#define MBEDTLS_CIPHER_PADDING_ZEROS_AND_LEN
S#define MBEDTLS_CIPHER_PADDING_ZEROS
S
S/**
S * \def MBEDTLS_ENABLE_WEAK_CIPHERSUITES
S *
S * Enable weak ciphersuites in SSL / TLS.
S * Warning: Only do so when you know what you are doing. This allows for
S * channels with virtually no security at all!
S *
S * This enables the following ciphersuites:
S *      MBEDTLS_TLS_RSA_WITH_DES_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_DES_CBC_SHA
S *
S * Uncomment this macro to enable weak ciphersuites
S */
S//#define MBEDTLS_ENABLE_WEAK_CIPHERSUITES
S
S/**
S * \def MBEDTLS_REMOVE_ARC4_CIPHERSUITES
S *
S * Remove RC4 ciphersuites by default in SSL / TLS.
S * This flag removes the ciphersuites based on RC4 from the default list as
S * returned by mbedtls_ssl_list_ciphersuites(). However, it is still possible to
S * enable (some of) them with mbedtls_ssl_conf_ciphersuites() by including them
S * explicitly.
S *
S * Uncomment this macro to remove RC4 ciphersuites by default.
S */
S#define MBEDTLS_REMOVE_ARC4_CIPHERSUITES
S
S/**
S * \def MBEDTLS_ECP_DP_SECP192R1_ENABLED
S *
S * MBEDTLS_ECP_XXXX_ENABLED: Enables specific curves within the Elliptic Curve
S * module.  By default all supported curves are enabled.
S *
S * Comment macros to disable the curve and functions for it
S */
S#define MBEDTLS_ECP_DP_SECP192R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP224R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP256R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP384R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP521R1_ENABLED
S#define MBEDTLS_ECP_DP_SECP192K1_ENABLED
S#define MBEDTLS_ECP_DP_SECP224K1_ENABLED
S#define MBEDTLS_ECP_DP_SECP256K1_ENABLED
S#define MBEDTLS_ECP_DP_BP256R1_ENABLED
S#define MBEDTLS_ECP_DP_BP384R1_ENABLED
S#define MBEDTLS_ECP_DP_BP512R1_ENABLED
S#define MBEDTLS_ECP_DP_CURVE25519_ENABLED
S
S/**
S * \def MBEDTLS_ECP_NIST_OPTIM
S *
S * Enable specific 'modulo p' routines for each NIST prime.
S * Depending on the prime and architecture, makes operations 4 to 8 times
S * faster on the corresponding curve.
S *
S * Comment this macro to disable NIST curves optimisation.
S */
S#define MBEDTLS_ECP_NIST_OPTIM
S
S/**
S * \def MBEDTLS_ECDSA_DETERMINISTIC
S *
S * Enable deterministic ECDSA (RFC 6979).
S * Standard ECDSA is "fragile" in the sense that lack of entropy when signing
S * may result in a compromise of the long-term signing key. This is avoided by
S * the deterministic variant.
S *
S * Requires: MBEDTLS_HMAC_DRBG_C
S *
S * Comment this macro to disable deterministic ECDSA.
S */
S#define MBEDTLS_ECDSA_DETERMINISTIC
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
S *
S * Enable the PSK based ciphersuite modes in SSL / TLS.
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
S *
S * Enable the DHE-PSK based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_DHM_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
S *
S * Enable the ECDHE-PSK based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
S *
S * Enable the RSA-PSK based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
S *
S * Enable the RSA-only based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_MD5
S */
S#define MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
S *
S * Enable the DHE-RSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_DHM_C, MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
S *
S * Enable the ECDHE-RSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_RSA_C, MBEDTLS_PKCS1_V15,
S *           MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
S *
S * Enable the ECDHE-ECDSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_ECDSA_C, MBEDTLS_X509_CRT_PARSE_C,
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
S *
S * Enable the ECDH-ECDSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
S *
S * Enable the ECDH-RSA based ciphersuite modes in SSL / TLS.
S *
S * Requires: MBEDTLS_ECDH_C, MBEDTLS_X509_CRT_PARSE_C
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
S */
S#define MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
S
S/**
S * \def MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
S *
S * Enable the ECJPAKE based ciphersuite modes in SSL / TLS.
S *
S * \warning This is currently experimental. EC J-PAKE support is based on the
S * Thread v1.0.0 specification; incompatible changes to the specification
S * might still happen. For this reason, this is disabled by default.
S *
S * Requires: MBEDTLS_ECJPAKE_C
S *           MBEDTLS_SHA256_C
S *           MBEDTLS_ECP_DP_SECP256R1_ENABLED
S *
S * This enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECJPAKE_WITH_AES_128_CCM_8
S */
S//#define MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED
S
S/**
S * \def MBEDTLS_PK_PARSE_EC_EXTENDED
S *
S * Enhance support for reading EC keys using variants of SEC1 not allowed by
S * RFC 5915 and RFC 5480.
S *
S * Currently this means parsing the SpecifiedECDomain choice of EC
S * parameters (only known groups are supported, not arbitrary domains, to
S * avoid validation issues).
S *
S * Disable if you only need to support RFC 5915 + 5480 key formats.
S */
S#define MBEDTLS_PK_PARSE_EC_EXTENDED
S
S/**
S * \def MBEDTLS_ERROR_STRERROR_DUMMY
S *
S * Enable a dummy error function to make use of mbedtls_strerror() in
S * third party libraries easier when MBEDTLS_ERROR_C is disabled
S * (no effect when MBEDTLS_ERROR_C is enabled).
S *
S * You can safely disable this if MBEDTLS_ERROR_C is enabled, or if you're
S * not using mbedtls_strerror() or error_strerror() in your application.
S *
S * Disable if you run into name conflicts and want to really remove the
S * mbedtls_strerror()
S */
S#define MBEDTLS_ERROR_STRERROR_DUMMY
S
S/**
S * \def MBEDTLS_GENPRIME
S *
S * Enable the prime-number generation code.
S *
S * Requires: MBEDTLS_BIGNUM_C
S */
S#define MBEDTLS_GENPRIME
S
S/**
S * \def MBEDTLS_FS_IO
S *
S * Enable functions that use the filesystem.
S */
S#define MBEDTLS_FS_IO
S
S/**
S * \def MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
S *
S * Do not add default entropy sources. These are the platform specific,
S * mbedtls_timing_hardclock and HAVEGE based poll functions.
S *
S * This is useful to have more control over the added entropy sources in an
S * application.
S *
S * Uncomment this macro to prevent loading of default entropy functions.
S */
S//#define MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES
S
S/**
S * \def MBEDTLS_NO_PLATFORM_ENTROPY
S *
S * Do not use built-in platform entropy functions.
S * This is useful if your platform does not support
S * standards like the /dev/urandom or Windows CryptoAPI.
S *
S * Uncomment this macro to disable the built-in platform entropy functions.
S */
S//#define MBEDTLS_NO_PLATFORM_ENTROPY
S
S/**
S * \def MBEDTLS_ENTROPY_FORCE_SHA256
S *
S * Force the entropy accumulator to use a SHA-256 accumulator instead of the
S * default SHA-512 based one (if both are available).
S *
S * Requires: MBEDTLS_SHA256_C
S *
S * On 32-bit systems SHA-256 can be much faster than SHA-512. Use this option
S * if you have performance concerns.
S *
S * This option is only useful if both MBEDTLS_SHA256_C and
S * MBEDTLS_SHA512_C are defined. Otherwise the available hash module is used.
S */
S//#define MBEDTLS_ENTROPY_FORCE_SHA256
S
S/**
S * \def MBEDTLS_MEMORY_DEBUG
S *
S * Enable debugging of buffer allocator memory issues. Automatically prints
S * (to stderr) all (fatal) messages on memory allocation issues. Enables
S * function for 'debug output' of allocated memory.
S *
S * Requires: MBEDTLS_MEMORY_BUFFER_ALLOC_C
S *
S * Uncomment this macro to let the buffer allocator print out error messages.
S */
S//#define MBEDTLS_MEMORY_DEBUG
S
S/**
S * \def MBEDTLS_MEMORY_BACKTRACE
S *
S * Include backtrace information with each allocated block.
S *
S * Requires: MBEDTLS_MEMORY_BUFFER_ALLOC_C
S *           GLIBC-compatible backtrace() an backtrace_symbols() support
S *
S * Uncomment this macro to include backtrace information
S */
S//#define MBEDTLS_MEMORY_BACKTRACE
S
S/**
S * \def MBEDTLS_PK_RSA_ALT_SUPPORT
S *
S * Support external private RSA keys (eg from a HSM) in the PK layer.
S *
S * Comment this macro to disable support for external private RSA keys.
S */
S#define MBEDTLS_PK_RSA_ALT_SUPPORT
S
S/**
S * \def MBEDTLS_PKCS1_V15
S *
S * Enable support for PKCS#1 v1.5 encoding.
S *
S * Requires: MBEDTLS_RSA_C
S *
S * This enables support for PKCS#1 v1.5 operations.
S */
S#define MBEDTLS_PKCS1_V15
S
S/**
S * \def MBEDTLS_PKCS1_V21
S *
S * Enable support for PKCS#1 v2.1 encoding.
S *
S * Requires: MBEDTLS_MD_C, MBEDTLS_RSA_C
S *
S * This enables support for RSAES-OAEP and RSASSA-PSS operations.
S */
S#define MBEDTLS_PKCS1_V21
S
S/**
S * \def MBEDTLS_RSA_NO_CRT
S *
S * Do not use the Chinese Remainder Theorem for the RSA private operation.
S *
S * Uncomment this macro to disable the use of CRT in RSA.
S *
S */
S//#define MBEDTLS_RSA_NO_CRT
S
S/**
S * \def MBEDTLS_SELF_TEST
S *
S * Enable the checkup functions (*_self_test).
S */
S#define MBEDTLS_SELF_TEST
S
S/**
S * \def MBEDTLS_SHA256_SMALLER
S *
S * Enable an implementation of SHA-256 that has lower ROM footprint but also
S * lower performance.
S *
S * The default implementation is meant to be a reasonnable compromise between
S * performance and size. This version optimizes more aggressively for size at
S * the expense of performance. Eg on Cortex-M4 it reduces the size of
S * mbedtls_sha256_process() from ~2KB to ~0.5KB for a performance hit of about
S * 30%.
S *
S * Uncomment to enable the smaller implementation of SHA256.
S */
S//#define MBEDTLS_SHA256_SMALLER
S
S/**
S * \def MBEDTLS_SSL_AEAD_RANDOM_IV
S *
S * Generate a random IV rather than using the record sequence number as a
S * nonce for ciphersuites using and AEAD algorithm (GCM or CCM).
S *
S * Using the sequence number is generally recommended.
S *
S * Uncomment this macro to always use random IVs with AEAD ciphersuites.
S */
S//#define MBEDTLS_SSL_AEAD_RANDOM_IV
S
S/**
S * \def MBEDTLS_SSL_ALL_ALERT_MESSAGES
S *
S * Enable sending of alert messages in case of encountered errors as per RFC.
S * If you choose not to send the alert messages, mbed TLS can still communicate
S * with other servers, only debugging of failures is harder.
S *
S * The advantage of not sending alert messages, is that no information is given
S * about reasons for failures thus preventing adversaries of gaining intel.
S *
S * Enable sending of all alert messages
S */
S#define MBEDTLS_SSL_ALL_ALERT_MESSAGES
S
S/**
S * \def MBEDTLS_SSL_DEBUG_ALL
S *
S * Enable the debug messages in SSL module for all issues.
S * Debug messages have been disabled in some places to prevent timing
S * attacks due to (unbalanced) debugging function calls.
S *
S * If you need all error reporting you should enable this during debugging,
S * but remove this for production servers that should log as well.
S *
S * Uncomment this macro to report all debug messages on errors introducing
S * a timing side-channel.
S *
S */
S//#define MBEDTLS_SSL_DEBUG_ALL
S
S/** \def MBEDTLS_SSL_ENCRYPT_THEN_MAC
S *
S * Enable support for Encrypt-then-MAC, RFC 7366.
S *
S * This allows peers that both support it to use a more robust protection for
S * ciphersuites using CBC, providing deep resistance against timing attacks
S * on the padding or underlying cipher.
S *
S * This only affects CBC ciphersuites, and is useless if none is defined.
S *
S * Requires: MBEDTLS_SSL_PROTO_TLS1    or
S *           MBEDTLS_SSL_PROTO_TLS1_1  or
S *           MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Comment this macro to disable support for Encrypt-then-MAC
S */
S#define MBEDTLS_SSL_ENCRYPT_THEN_MAC
S
S/** \def MBEDTLS_SSL_EXTENDED_MASTER_SECRET
S *
S * Enable support for Extended Master Secret, aka Session Hash
S * (draft-ietf-tls-session-hash-02).
S *
S * This was introduced as "the proper fix" to the Triple Handshake familiy of
S * attacks, but it is recommended to always use it (even if you disable
S * renegotiation), since it actually fixes a more fundamental issue in the
S * original SSL/TLS design, and has implications beyond Triple Handshake.
S *
S * Requires: MBEDTLS_SSL_PROTO_TLS1    or
S *           MBEDTLS_SSL_PROTO_TLS1_1  or
S *           MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Comment this macro to disable support for Extended Master Secret.
S */
S#define MBEDTLS_SSL_EXTENDED_MASTER_SECRET
S
S/**
S * \def MBEDTLS_SSL_FALLBACK_SCSV
S *
S * Enable support for FALLBACK_SCSV (draft-ietf-tls-downgrade-scsv-00).
S *
S * For servers, it is recommended to always enable this, unless you support
S * only one version of TLS, or know for sure that none of your clients
S * implements a fallback strategy.
S *
S * For clients, you only need this if you're using a fallback strategy, which
S * is not recommended in the first place, unless you absolutely need it to
S * interoperate with buggy (version-intolerant) servers.
S *
S * Comment this macro to disable support for FALLBACK_SCSV
S */
S#define MBEDTLS_SSL_FALLBACK_SCSV
S
S/**
S * \def MBEDTLS_SSL_HW_RECORD_ACCEL
S *
S * Enable hooking functions in SSL module for hardware acceleration of
S * individual records.
S *
S * Uncomment this macro to enable hooking functions.
S */
S//#define MBEDTLS_SSL_HW_RECORD_ACCEL
S
S/**
S * \def MBEDTLS_SSL_CBC_RECORD_SPLITTING
S *
S * Enable 1/n-1 record splitting for CBC mode in SSLv3 and TLS 1.0.
S *
S * This is a countermeasure to the BEAST attack, which also minimizes the risk
S * of interoperability issues compared to sending 0-length records.
S *
S * Comment this macro to disable 1/n-1 record splitting.
S */
S#define MBEDTLS_SSL_CBC_RECORD_SPLITTING
S
S/**
S * \def MBEDTLS_SSL_RENEGOTIATION
S *
S * Disable support for TLS renegotiation.
S *
S * The two main uses of renegotiation are (1) refresh keys on long-lived
S * connections and (2) client authentication after the initial handshake.
S * If you don't need renegotiation, it's probably better to disable it, since
S * it has been associated with security issues in the past and is easy to
S * misuse/misunderstand.
S *
S * Comment this to disable support for renegotiation.
S */
S#define MBEDTLS_SSL_RENEGOTIATION
S
S/**
S * \def MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
S *
S * Enable support for receiving and parsing SSLv2 Client Hello messages for the
S * SSL Server module (MBEDTLS_SSL_SRV_C).
S *
S * Uncomment this macro to enable support for SSLv2 Client Hello messages.
S */
S//#define MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO
S
S/**
S * \def MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE
S *
S * Pick the ciphersuite according to the client's preferences rather than ours
S * in the SSL Server module (MBEDTLS_SSL_SRV_C).
S *
S * Uncomment this macro to respect client's ciphersuite order
S */
S//#define MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE
S
S/**
S * \def MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
S *
S * Enable support for RFC 6066 max_fragment_length extension in SSL.
S *
S * Comment this macro to disable support for the max_fragment_length extension
S */
S#define MBEDTLS_SSL_MAX_FRAGMENT_LENGTH
S
S/**
S * \def MBEDTLS_SSL_PROTO_SSL3
S *
S * Enable support for SSL 3.0.
S *
S * Requires: MBEDTLS_MD5_C
S *           MBEDTLS_SHA1_C
S *
S * Comment this macro to disable support for SSL 3.0
S */
S#define MBEDTLS_SSL_PROTO_SSL3
S
S/**
S * \def MBEDTLS_SSL_PROTO_TLS1
S *
S * Enable support for TLS 1.0.
S *
S * Requires: MBEDTLS_MD5_C
S *           MBEDTLS_SHA1_C
S *
S * Comment this macro to disable support for TLS 1.0
S */
S#define MBEDTLS_SSL_PROTO_TLS1
S
S/**
S * \def MBEDTLS_SSL_PROTO_TLS1_1
S *
S * Enable support for TLS 1.1 (and DTLS 1.0 if DTLS is enabled).
S *
S * Requires: MBEDTLS_MD5_C
S *           MBEDTLS_SHA1_C
S *
S * Comment this macro to disable support for TLS 1.1 / DTLS 1.0
S */
S#define MBEDTLS_SSL_PROTO_TLS1_1
S
S/**
S * \def MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Enable support for TLS 1.2 (and DTLS 1.2 if DTLS is enabled).
S *
S * Requires: MBEDTLS_SHA1_C or MBEDTLS_SHA256_C or MBEDTLS_SHA512_C
S *           (Depends on ciphersuites)
S *
S * Comment this macro to disable support for TLS 1.2 / DTLS 1.2
S */
S#define MBEDTLS_SSL_PROTO_TLS1_2
S
S/**
S * \def MBEDTLS_SSL_PROTO_DTLS
S *
S * Enable support for DTLS (all available versions).
S *
S * Enable this and MBEDTLS_SSL_PROTO_TLS1_1 to enable DTLS 1.0,
S * and/or this and MBEDTLS_SSL_PROTO_TLS1_2 to enable DTLS 1.2.
S *
S * Requires: MBEDTLS_SSL_PROTO_TLS1_1
S *        or MBEDTLS_SSL_PROTO_TLS1_2
S *
S * Comment this macro to disable support for DTLS
S */
S#define MBEDTLS_SSL_PROTO_DTLS
S
S/**
S * \def MBEDTLS_SSL_ALPN
S *
S * Enable support for RFC 7301 Application Layer Protocol Negotiation.
S *
S * Comment this macro to disable support for ALPN.
S */
S#define MBEDTLS_SSL_ALPN
S
S/**
S * \def MBEDTLS_SSL_DTLS_ANTI_REPLAY
S *
S * Enable support for the anti-replay mechanism in DTLS.
S *
S * Requires: MBEDTLS_SSL_TLS_C
S *           MBEDTLS_SSL_PROTO_DTLS
S *
S * \warning Disabling this is often a security risk!
S * See mbedtls_ssl_conf_dtls_anti_replay() for details.
S *
S * Comment this to disable anti-replay in DTLS.
S */
S#define MBEDTLS_SSL_DTLS_ANTI_REPLAY
S
S/**
S * \def MBEDTLS_SSL_DTLS_HELLO_VERIFY
S *
S * Enable support for HelloVerifyRequest on DTLS servers.
S *
S * This feature is highly recommended to prevent DTLS servers being used as
S * amplifiers in DoS attacks against other hosts. It should always be enabled
S * unless you know for sure amplification cannot be a problem in the
S * environment in which your server operates.
S *
S * \warning Disabling this can ba a security risk! (see above)
S *
S * Requires: MBEDTLS_SSL_PROTO_DTLS
S *
S * Comment this to disable support for HelloVerifyRequest.
S */
S#define MBEDTLS_SSL_DTLS_HELLO_VERIFY
S
S/**
S * \def MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
S *
S * Enable server-side support for clients that reconnect from the same port.
S *
S * Some clients unexpectedly close the connection and try to reconnect using the
S * same source port. This needs special support from the server to handle the
S * new connection securely, as described in section 4.2.8 of RFC 6347. This
S * flag enables that support.
S *
S * Requires: MBEDTLS_SSL_DTLS_HELLO_VERIFY
S *
S * Comment this to disable support for clients reusing the source port.
S */
S#define MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE
S
S/**
S * \def MBEDTLS_SSL_DTLS_BADMAC_LIMIT
S *
S * Enable support for a limit of records with bad MAC.
S *
S * See mbedtls_ssl_conf_dtls_badmac_limit().
S *
S * Requires: MBEDTLS_SSL_PROTO_DTLS
S */
S#define MBEDTLS_SSL_DTLS_BADMAC_LIMIT
S
S/**
S * \def MBEDTLS_SSL_SESSION_TICKETS
S *
S * Enable support for RFC 5077 session tickets in SSL.
S * Client-side, provides full support for session tickets (maintainance of a
S * session store remains the responsibility of the application, though).
S * Server-side, you also need to provide callbacks for writing and parsing
S * tickets, including authenticated encryption and key management. Example
S * callbacks are provided by MBEDTLS_SSL_TICKET_C.
S *
S * Comment this macro to disable support for SSL session tickets
S */
S#define MBEDTLS_SSL_SESSION_TICKETS
S
S/**
S * \def MBEDTLS_SSL_EXPORT_KEYS
S *
S * Enable support for exporting key block and master secret.
S * This is required for certain users of TLS, e.g. EAP-TLS.
S *
S * Comment this macro to disable support for key export
S */
S#define MBEDTLS_SSL_EXPORT_KEYS
S
S/**
S * \def MBEDTLS_SSL_SERVER_NAME_INDICATION
S *
S * Enable support for RFC 6066 server name indication (SNI) in SSL.
S *
S * Requires: MBEDTLS_X509_CRT_PARSE_C
S *
S * Comment this macro to disable support for server name indication in SSL
S */
S#define MBEDTLS_SSL_SERVER_NAME_INDICATION
S
S/**
S * \def MBEDTLS_SSL_TRUNCATED_HMAC
S *
S * Enable support for RFC 6066 truncated HMAC in SSL.
S *
S * Comment this macro to disable support for truncated HMAC in SSL
S */
S#define MBEDTLS_SSL_TRUNCATED_HMAC
S
S/**
S * \def MBEDTLS_THREADING_ALT
S *
S * Provide your own alternate threading implementation.
S *
S * Requires: MBEDTLS_THREADING_C
S *
S * Uncomment this to allow your own alternate threading implementation.
S */
S//#define MBEDTLS_THREADING_ALT
S
S/**
S * \def MBEDTLS_THREADING_PTHREAD
S *
S * Enable the pthread wrapper layer for the threading layer.
S *
S * Requires: MBEDTLS_THREADING_C
S *
S * Uncomment this to enable pthread mutexes.
S */
S//#define MBEDTLS_THREADING_PTHREAD
S
S/**
S * \def MBEDTLS_VERSION_FEATURES
S *
S * Allow run-time checking of compile-time enabled features. Thus allowing users
S * to check at run-time if the library is for instance compiled with threading
S * support via mbedtls_version_check_feature().
S *
S * Requires: MBEDTLS_VERSION_C
S *
S * Comment this to disable run-time checking and save ROM space
S */
S#define MBEDTLS_VERSION_FEATURES
S
S/**
S * \def MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3
S *
S * If set, the X509 parser will not break-off when parsing an X509 certificate
S * and encountering an extension in a v1 or v2 certificate.
S *
S * Uncomment to prevent an error.
S */
S//#define MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3
S
S/**
S * \def MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
S *
S * If set, the X509 parser will not break-off when parsing an X509 certificate
S * and encountering an unknown critical extension.
S *
S * \warning Depending on your PKI use, enabling this can be a security risk!
S *
S * Uncomment to prevent an error.
S */
S//#define MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION
S
S/**
S * \def MBEDTLS_X509_CHECK_KEY_USAGE
S *
S * Enable verification of the keyUsage extension (CA and leaf certificates).
S *
S * Disabling this avoids problems with mis-issued and/or misused
S * (intermediate) CA and leaf certificates.
S *
S * \warning Depending on your PKI use, disabling this can be a security risk!
S *
S * Comment to skip keyUsage checking for both CA and leaf certificates.
S */
S#define MBEDTLS_X509_CHECK_KEY_USAGE
S
S/**
S * \def MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
S *
S * Enable verification of the extendedKeyUsage extension (leaf certificates).
S *
S * Disabling this avoids problems with mis-issued and/or misused certificates.
S *
S * \warning Depending on your PKI use, disabling this can be a security risk!
S *
S * Comment to skip extendedKeyUsage checking for certificates.
S */
S#define MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE
S
S/**
S * \def MBEDTLS_X509_RSASSA_PSS_SUPPORT
S *
S * Enable parsing and verification of X.509 certificates, CRLs and CSRS
S * signed with RSASSA-PSS (aka PKCS#1 v2.1).
S *
S * Comment this macro to disallow using RSASSA-PSS in certificates.
S */
S#define MBEDTLS_X509_RSASSA_PSS_SUPPORT
S
S/**
S * \def MBEDTLS_ZLIB_SUPPORT
S *
S * If set, the SSL/TLS module uses ZLIB to support compression and
S * decompression of packet data.
S *
S * \warning TLS-level compression MAY REDUCE SECURITY! See for example the
S * CRIME attack. Before enabling this option, you should examine with care if
S * CRIME or similar exploits may be a applicable to your use case.
S *
S * \note Currently compression can't be used with DTLS.
S *
S * Used in: library/ssl_tls.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This feature requires zlib library and headers to be present.
S *
S * Uncomment to enable use of ZLIB
S */
S//#define MBEDTLS_ZLIB_SUPPORT
S/* \} name SECTION: mbed TLS feature support */
S
S/**
S * \name SECTION: mbed TLS modules
S *
S * This section enables or disables entire modules in mbed TLS
S * \{
S */
S
S/**
S * \def MBEDTLS_AESNI_C
S *
S * Enable AES-NI support on x86-64.
S *
S * Module:  library/aesni.c
S * Caller:  library/aes.c
S *
S * Requires: MBEDTLS_HAVE_ASM
S *
S * This modules adds support for the AES-NI instructions on x86-64
S */
S#define MBEDTLS_AESNI_C
S
S/**
S * \def MBEDTLS_AES_C
S *
S * Enable the AES block cipher.
S *
S * Module:  library/aes.c
S * Caller:  library/ssl_tls.c
S *          library/pem.c
S *          library/ctr_drbg.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_AES_128_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_AES_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_AES_256_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_AES_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_AES_128_CBC_SHA
S *
S * PEM_PARSE uses AES for decrypting encrypted keys.
S */
S#define MBEDTLS_AES_C
S
S/**
S * \def MBEDTLS_ARC4_C
S *
S * Enable the ARCFOUR stream cipher.
S *
S * Module:  library/arc4.c
S * Caller:  library/ssl_tls.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_RSA_WITH_RC4_128_MD5
S *      MBEDTLS_TLS_RSA_PSK_WITH_RC4_128_SHA
S *      MBEDTLS_TLS_PSK_WITH_RC4_128_SHA
S */
S#define MBEDTLS_ARC4_C
S
S/**
S * \def MBEDTLS_ASN1_PARSE_C
S *
S * Enable the generic ASN1 parser.
S *
S * Module:  library/asn1.c
S * Caller:  library/x509.c
S *          library/dhm.c
S *          library/pkcs12.c
S *          library/pkcs5.c
S *          library/pkparse.c
S */
S#define MBEDTLS_ASN1_PARSE_C
S
S/**
S * \def MBEDTLS_ASN1_WRITE_C
S *
S * Enable the generic ASN1 writer.
S *
S * Module:  library/asn1write.c
S * Caller:  library/ecdsa.c
S *          library/pkwrite.c
S *          library/x509_create.c
S *          library/x509write_crt.c
S *          library/mbedtls_x509write_csr.c
S */
S#define MBEDTLS_ASN1_WRITE_C
S
S/**
S * \def MBEDTLS_BASE64_C
S *
S * Enable the Base64 module.
S *
S * Module:  library/base64.c
S * Caller:  library/pem.c
S *
S * This module is required for PEM support (required by X.509).
S */
S#define MBEDTLS_BASE64_C
S
S/**
S * \def MBEDTLS_BIGNUM_C
S *
S * Enable the multi-precision integer library.
S *
S * Module:  library/bignum.c
S * Caller:  library/dhm.c
S *          library/ecp.c
S *          library/ecdsa.c
S *          library/rsa.c
S *          library/ssl_tls.c
S *
S * This module is required for RSA, DHM and ECC (ECDH, ECDSA) support.
S */
S#define MBEDTLS_BIGNUM_C
S
S/**
S * \def MBEDTLS_BLOWFISH_C
S *
S * Enable the Blowfish block cipher.
S *
S * Module:  library/blowfish.c
S */
S#define MBEDTLS_BLOWFISH_C
S
S/**
S * \def MBEDTLS_CAMELLIA_C
S *
S * Enable the Camellia block cipher.
S *
S * Module:  library/camellia.c
S * Caller:  library/ssl_tls.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
S *      MBEDTLS_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
S */
S#define MBEDTLS_CAMELLIA_C
S
S/**
S * \def MBEDTLS_CCM_C
S *
S * Enable the Counter with CBC-MAC (CCM) mode for 128-bit block cipher.
S *
S * Module:  library/ccm.c
S *
S * Requires: MBEDTLS_AES_C or MBEDTLS_CAMELLIA_C
S *
S * This module enables the AES-CCM ciphersuites, if other requisites are
S * enabled as well.
S */
S#define MBEDTLS_CCM_C
S
S/**
S * \def MBEDTLS_CERTS_C
S *
S * Enable the test certificates.
S *
S * Module:  library/certs.c
S * Caller:
S *
S * This module is used for testing (ssl_client/server).
S */
S#define MBEDTLS_CERTS_C
S
S/**
S * \def MBEDTLS_CIPHER_C
S *
S * Enable the generic cipher layer.
S *
S * Module:  library/cipher.c
S * Caller:  library/ssl_tls.c
S *
S * Uncomment to enable generic cipher wrappers.
S */
S#define MBEDTLS_CIPHER_C
S
S/**
S * \def MBEDTLS_CTR_DRBG_C
S *
S * Enable the CTR_DRBG AES-256-based random generator.
S *
S * Module:  library/ctr_drbg.c
S * Caller:
S *
S * Requires: MBEDTLS_AES_C
S *
S * This module provides the CTR_DRBG AES-256 random number generator.
S */
S#define MBEDTLS_CTR_DRBG_C
S
S/**
S * \def MBEDTLS_DEBUG_C
S *
S * Enable the debug functions.
S *
S * Module:  library/debug.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *
S * This module provides debugging functions.
S */
S#define MBEDTLS_DEBUG_C
S
S/**
S * \def MBEDTLS_DES_C
S *
S * Enable the DES block cipher.
S *
S * Module:  library/des.c
S * Caller:  library/pem.c
S *          library/ssl_tls.c
S *
S * This module enables the following ciphersuites (if other requisites are
S * enabled as well):
S *      MBEDTLS_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
S *      MBEDTLS_TLS_PSK_WITH_3DES_EDE_CBC_SHA
S *
S * PEM_PARSE uses DES/3DES for decrypting encrypted keys.
S */
S#define MBEDTLS_DES_C
S
S/**
S * \def MBEDTLS_DHM_C
S *
S * Enable the Diffie-Hellman-Merkle module.
S *
S * Module:  library/dhm.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This module is used by the following key exchanges:
S *      DHE-RSA, DHE-PSK
S */
S#define MBEDTLS_DHM_C
S
S/**
S * \def MBEDTLS_ECDH_C
S *
S * Enable the elliptic curve Diffie-Hellman library.
S *
S * Module:  library/ecdh.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This module is used by the following key exchanges:
S *      ECDHE-ECDSA, ECDHE-RSA, DHE-PSK
S *
S * Requires: MBEDTLS_ECP_C
S */
S#define MBEDTLS_ECDH_C
S
S/**
S * \def MBEDTLS_ECDSA_C
S *
S * Enable the elliptic curve DSA library.
S *
S * Module:  library/ecdsa.c
S * Caller:
S *
S * This module is used by the following key exchanges:
S *      ECDHE-ECDSA
S *
S * Requires: MBEDTLS_ECP_C, MBEDTLS_ASN1_WRITE_C, MBEDTLS_ASN1_PARSE_C
S */
S#define MBEDTLS_ECDSA_C
S
S/**
S * \def MBEDTLS_ECJPAKE_C
S *
S * Enable the elliptic curve J-PAKE library.
S *
S * \warning This is currently experimental. EC J-PAKE support is based on the
S * Thread v1.0.0 specification; incompatible changes to the specification
S * might still happen. For this reason, this is disabled by default.
S *
S * Module:  library/ecjpake.c
S * Caller:
S *
S * This module is used by the following key exchanges:
S *      ECJPAKE
S *
S * Requires: MBEDTLS_ECP_C, MBEDTLS_MD_C
S */
S//#define MBEDTLS_ECJPAKE_C
S
S/**
S * \def MBEDTLS_ECP_C
S *
S * Enable the elliptic curve over GF(p) library.
S *
S * Module:  library/ecp.c
S * Caller:  library/ecdh.c
S *          library/ecdsa.c
S *          library/ecjpake.c
S *
S * Requires: MBEDTLS_BIGNUM_C and at least one MBEDTLS_ECP_DP_XXX_ENABLED
S */
S#define MBEDTLS_ECP_C
S
S/**
S * \def MBEDTLS_ENTROPY_C
S *
S * Enable the platform-specific entropy code.
S *
S * Module:  library/entropy.c
S * Caller:
S *
S * Requires: MBEDTLS_SHA512_C or MBEDTLS_SHA256_C
S *
S * This module provides a generic entropy pool
S */
S#define MBEDTLS_ENTROPY_C
S
S/**
S * \def MBEDTLS_ERROR_C
S *
S * Enable error code to error string conversion.
S *
S * Module:  library/error.c
S * Caller:
S *
S * This module enables mbedtls_strerror().
S */
S#define MBEDTLS_ERROR_C
S
S/**
S * \def MBEDTLS_GCM_C
S *
S * Enable the Galois/Counter Mode (GCM) for AES.
S *
S * Module:  library/gcm.c
S *
S * Requires: MBEDTLS_AES_C or MBEDTLS_CAMELLIA_C
S *
S * This module enables the AES-GCM and CAMELLIA-GCM ciphersuites, if other
S * requisites are enabled as well.
S */
S#define MBEDTLS_GCM_C
S
S/**
S * \def MBEDTLS_HAVEGE_C
S *
S * Enable the HAVEGE random generator.
S *
S * Warning: the HAVEGE random generator is not suitable for virtualized
S *          environments
S *
S * Warning: the HAVEGE random generator is dependent on timing and specific
S *          processor traits. It is therefore not advised to use HAVEGE as
S *          your applications primary random generator or primary entropy pool
S *          input. As a secondary input to your entropy pool, it IS able add
S *          the (limited) extra entropy it provides.
S *
S * Module:  library/havege.c
S * Caller:
S *
S * Requires: MBEDTLS_TIMING_C
S *
S * Uncomment to enable the HAVEGE random generator.
S */
S//#define MBEDTLS_HAVEGE_C
S
S/**
S * \def MBEDTLS_HMAC_DRBG_C
S *
S * Enable the HMAC_DRBG random generator.
S *
S * Module:  library/hmac_drbg.c
S * Caller:
S *
S * Requires: MBEDTLS_MD_C
S *
S * Uncomment to enable the HMAC_DRBG random number geerator.
S */
S#define MBEDTLS_HMAC_DRBG_C
S
S/**
S * \def MBEDTLS_MD_C
S *
S * Enable the generic message digest layer.
S *
S * Module:  library/mbedtls_md.c
S * Caller:
S *
S * Uncomment to enable generic message digest wrappers.
S */
S#define MBEDTLS_MD_C
S
S/**
S * \def MBEDTLS_MD2_C
S *
S * Enable the MD2 hash algorithm.
S *
S * Module:  library/mbedtls_md2.c
S * Caller:
S *
S * Uncomment to enable support for (rare) MD2-signed X.509 certs.
S */
S//#define MBEDTLS_MD2_C
S
S/**
S * \def MBEDTLS_MD4_C
S *
S * Enable the MD4 hash algorithm.
S *
S * Module:  library/mbedtls_md4.c
S * Caller:
S *
S * Uncomment to enable support for (rare) MD4-signed X.509 certs.
S */
S//#define MBEDTLS_MD4_C
S
S/**
S * \def MBEDTLS_MD5_C
S *
S * Enable the MD5 hash algorithm.
S *
S * Module:  library/mbedtls_md5.c
S * Caller:  library/mbedtls_md.c
S *          library/pem.c
S *          library/ssl_tls.c
S *
S * This module is required for SSL/TLS and X.509.
S * PEM_PARSE uses MD5 for decrypting encrypted keys.
S */
S#define MBEDTLS_MD5_C
S
S/**
S * \def MBEDTLS_MEMORY_BUFFER_ALLOC_C
S *
S * Enable the buffer allocator implementation that makes use of a (stack)
S * based buffer to 'allocate' dynamic memory. (replaces calloc() and free()
S * calls)
S *
S * Module:  library/memory_buffer_alloc.c
S *
S * Requires: MBEDTLS_PLATFORM_C
S *           MBEDTLS_PLATFORM_MEMORY (to use it within mbed TLS)
S *
S * Enable this module to enable the buffer memory allocator.
S */
S//#define MBEDTLS_MEMORY_BUFFER_ALLOC_C
S
S/**
S * \def MBEDTLS_NET_C
S *
S * Enable the TCP/IP networking routines.
S *
S * Module:  library/net.c
S *
S * This module provides TCP/IP networking routines.
S */
S#define MBEDTLS_NET_C
S
S/**
S * \def MBEDTLS_OID_C
S *
S * Enable the OID database.
S *
S * Module:  library/oid.c
S * Caller:  library/asn1write.c
S *          library/pkcs5.c
S *          library/pkparse.c
S *          library/pkwrite.c
S *          library/rsa.c
S *          library/x509.c
S *          library/x509_create.c
S *          library/mbedtls_x509_crl.c
S *          library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *          library/x509write_crt.c
S *          library/mbedtls_x509write_csr.c
S *
S * This modules translates between OIDs and internal values.
S */
S#define MBEDTLS_OID_C
S
S/**
S * \def MBEDTLS_PADLOCK_C
S *
S * Enable VIA Padlock support on x86.
S *
S * Module:  library/padlock.c
S * Caller:  library/aes.c
S *
S * Requires: MBEDTLS_HAVE_ASM
S *
S * This modules adds support for the VIA PadLock on x86.
S */
S#define MBEDTLS_PADLOCK_C
S
S/**
S * \def MBEDTLS_PEM_PARSE_C
S *
S * Enable PEM decoding / parsing.
S *
S * Module:  library/pem.c
S * Caller:  library/dhm.c
S *          library/pkparse.c
S *          library/mbedtls_x509_crl.c
S *          library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *
S * Requires: MBEDTLS_BASE64_C
S *
S * This modules adds support for decoding / parsing PEM files.
S */
S#define MBEDTLS_PEM_PARSE_C
S
S/**
S * \def MBEDTLS_PEM_WRITE_C
S *
S * Enable PEM encoding / writing.
S *
S * Module:  library/pem.c
S * Caller:  library/pkwrite.c
S *          library/x509write_crt.c
S *          library/mbedtls_x509write_csr.c
S *
S * Requires: MBEDTLS_BASE64_C
S *
S * This modules adds support for encoding / writing PEM files.
S */
S#define MBEDTLS_PEM_WRITE_C
S
S/**
S * \def MBEDTLS_PK_C
S *
S * Enable the generic public (asymetric) key layer.
S *
S * Module:  library/pk.c
S * Caller:  library/ssl_tls.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * Requires: MBEDTLS_RSA_C or MBEDTLS_ECP_C
S *
S * Uncomment to enable generic public key wrappers.
S */
S#define MBEDTLS_PK_C
S
S/**
S * \def MBEDTLS_PK_PARSE_C
S *
S * Enable the generic public (asymetric) key parser.
S *
S * Module:  library/pkparse.c
S * Caller:  library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *
S * Requires: MBEDTLS_PK_C
S *
S * Uncomment to enable generic public key parse functions.
S */
S#define MBEDTLS_PK_PARSE_C
S
S/**
S * \def MBEDTLS_PK_WRITE_C
S *
S * Enable the generic public (asymetric) key writer.
S *
S * Module:  library/pkwrite.c
S * Caller:  library/x509write.c
S *
S * Requires: MBEDTLS_PK_C
S *
S * Uncomment to enable generic public key write functions.
S */
S#define MBEDTLS_PK_WRITE_C
S
S/**
S * \def MBEDTLS_PKCS5_C
S *
S * Enable PKCS#5 functions.
S *
S * Module:  library/pkcs5.c
S *
S * Requires: MBEDTLS_MD_C
S *
S * This module adds support for the PKCS#5 functions.
S */
S#define MBEDTLS_PKCS5_C
S
S/**
S * \def MBEDTLS_PKCS11_C
S *
S * Enable wrapper for PKCS#11 smartcard support.
S *
S * Module:  library/pkcs11.c
S * Caller:  library/pk.c
S *
S * Requires: MBEDTLS_PK_C
S *
S * This module enables SSL/TLS PKCS #11 smartcard support.
S * Requires the presence of the PKCS#11 helper library (libpkcs11-helper)
S */
S//#define MBEDTLS_PKCS11_C
S
S/**
S * \def MBEDTLS_PKCS12_C
S *
S * Enable PKCS#12 PBE functions.
S * Adds algorithms for parsing PKCS#8 encrypted private keys
S *
S * Module:  library/pkcs12.c
S * Caller:  library/pkparse.c
S *
S * Requires: MBEDTLS_ASN1_PARSE_C, MBEDTLS_CIPHER_C, MBEDTLS_MD_C
S * Can use:  MBEDTLS_ARC4_C
S *
S * This module enables PKCS#12 functions.
S */
S#define MBEDTLS_PKCS12_C
S
S/**
S * \def MBEDTLS_PLATFORM_C
S *
S * Enable the platform abstraction layer that allows you to re-assign
S * functions like calloc(), free(), snprintf(), printf(), fprintf(), exit().
S *
S * Enabling MBEDTLS_PLATFORM_C enables to use of MBEDTLS_PLATFORM_XXX_ALT
S * or MBEDTLS_PLATFORM_XXX_MACRO directives, allowing the functions mentioned
S * above to be specified at runtime or compile time respectively.
S *
S * \note This abstraction layer must be enabled on Windows (including MSYS2)
S * as other module rely on it for a fixed snprintf implementation.
S *
S * Module:  library/platform.c
S * Caller:  Most other .c files
S *
S * This module enables abstraction of common (libc) functions.
S */
S#define MBEDTLS_PLATFORM_C
S
S/**
S * \def MBEDTLS_RIPEMD160_C
S *
S * Enable the RIPEMD-160 hash algorithm.
S *
S * Module:  library/mbedtls_ripemd160.c
S * Caller:  library/mbedtls_md.c
S *
S */
S#define MBEDTLS_RIPEMD160_C
S
S/**
S * \def MBEDTLS_RSA_C
S *
S * Enable the RSA public-key cryptosystem.
S *
S * Module:  library/rsa.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *          library/x509.c
S *
S * This module is used by the following key exchanges:
S *      RSA, DHE-RSA, ECDHE-RSA, RSA-PSK
S *
S * Requires: MBEDTLS_BIGNUM_C, MBEDTLS_OID_C
S */
S#define MBEDTLS_RSA_C
S
S/**
S * \def MBEDTLS_SHA1_C
S *
S * Enable the SHA1 cryptographic hash algorithm.
S *
S * Module:  library/mbedtls_sha1.c
S * Caller:  library/mbedtls_md.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *          library/x509write_crt.c
S *
S * This module is required for SSL/TLS and SHA1-signed certificates.
S */
S#define MBEDTLS_SHA1_C
S
S/**
S * \def MBEDTLS_SHA256_C
S *
S * Enable the SHA-224 and SHA-256 cryptographic hash algorithms.
S *
S * Module:  library/mbedtls_sha256.c
S * Caller:  library/entropy.c
S *          library/mbedtls_md.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *
S * This module adds support for SHA-224 and SHA-256.
S * This module is required for the SSL/TLS 1.2 PRF function.
S */
S#define MBEDTLS_SHA256_C
S
S/**
S * \def MBEDTLS_SHA512_C
S *
S * Enable the SHA-384 and SHA-512 cryptographic hash algorithms.
S *
S * Module:  library/mbedtls_sha512.c
S * Caller:  library/entropy.c
S *          library/mbedtls_md.c
S *          library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * This module adds support for SHA-384 and SHA-512.
S */
S#define MBEDTLS_SHA512_C
S
S/**
S * \def MBEDTLS_SSL_CACHE_C
S *
S * Enable simple SSL cache implementation.
S *
S * Module:  library/ssl_cache.c
S * Caller:
S *
S * Requires: MBEDTLS_SSL_CACHE_C
S */
S#define MBEDTLS_SSL_CACHE_C
S
S/**
S * \def MBEDTLS_SSL_COOKIE_C
S *
S * Enable basic implementation of DTLS cookies for hello verification.
S *
S * Module:  library/ssl_cookie.c
S * Caller:
S */
S#define MBEDTLS_SSL_COOKIE_C
S
S/**
S * \def MBEDTLS_SSL_TICKET_C
S *
S * Enable an implementation of TLS server-side callbacks for session tickets.
S *
S * Module:  library/ssl_ticket.c
S * Caller:
S *
S * Requires: MBEDTLS_CIPHER_C
S */
S#define MBEDTLS_SSL_TICKET_C
S
S/**
S * \def MBEDTLS_SSL_CLI_C
S *
S * Enable the SSL/TLS client code.
S *
S * Module:  library/ssl_cli.c
S * Caller:
S *
S * Requires: MBEDTLS_SSL_TLS_C
S *
S * This module is required for SSL/TLS client support.
S */
S#define MBEDTLS_SSL_CLI_C
S
S/**
S * \def MBEDTLS_SSL_SRV_C
S *
S * Enable the SSL/TLS server code.
S *
S * Module:  library/ssl_srv.c
S * Caller:
S *
S * Requires: MBEDTLS_SSL_TLS_C
S *
S * This module is required for SSL/TLS server support.
S */
S#define MBEDTLS_SSL_SRV_C
S
S/**
S * \def MBEDTLS_SSL_TLS_C
S *
S * Enable the generic SSL/TLS code.
S *
S * Module:  library/ssl_tls.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *
S * Requires: MBEDTLS_CIPHER_C, MBEDTLS_MD_C
S *           and at least one of the MBEDTLS_SSL_PROTO_XXX defines
S *
S * This module is required for SSL/TLS.
S */
S#define MBEDTLS_SSL_TLS_C
S
S/**
S * \def MBEDTLS_THREADING_C
S *
S * Enable the threading abstraction layer.
S * By default mbed TLS assumes it is used in a non-threaded environment or that
S * contexts are not shared between threads. If you do intend to use contexts
S * between threads, you will need to enable this layer to prevent race
S * conditions.
S *
S * Module:  library/threading.c
S *
S * This allows different threading implementations (self-implemented or
S * provided).
S *
S * You will have to enable either MBEDTLS_THREADING_ALT or
S * MBEDTLS_THREADING_PTHREAD.
S *
S * Enable this layer to allow use of mutexes within mbed TLS
S */
S//#define MBEDTLS_THREADING_C
S
S/**
S * \def MBEDTLS_TIMING_C
S *
S * Enable the portable timing interface.
S *
S * Module:  library/timing.c
S * Caller:  library/havege.c
S *
S * This module is used by the HAVEGE random number generator.
S */
S#define MBEDTLS_TIMING_C
S
S/**
S * \def MBEDTLS_VERSION_C
S *
S * Enable run-time version information.
S *
S * Module:  library/version.c
S *
S * This module provides run-time version information.
S */
S#define MBEDTLS_VERSION_C
S
S/**
S * \def MBEDTLS_X509_USE_C
S *
S * Enable X.509 core for using certificates.
S *
S * Module:  library/x509.c
S * Caller:  library/mbedtls_x509_crl.c
S *          library/mbedtls_x509_crt.c
S *          library/mbedtls_x509_csr.c
S *
S * Requires: MBEDTLS_ASN1_PARSE_C, MBEDTLS_BIGNUM_C, MBEDTLS_OID_C,
S *           MBEDTLS_PK_PARSE_C
S *
S * This module is required for the X.509 parsing modules.
S */
S#define MBEDTLS_X509_USE_C
S
S/**
S * \def MBEDTLS_X509_CRT_PARSE_C
S *
S * Enable X.509 certificate parsing.
S *
S * Module:  library/mbedtls_x509_crt.c
S * Caller:  library/ssl_cli.c
S *          library/ssl_srv.c
S *          library/ssl_tls.c
S *
S * Requires: MBEDTLS_X509_USE_C
S *
S * This module is required for X.509 certificate parsing.
S */
S#define MBEDTLS_X509_CRT_PARSE_C
S
S/**
S * \def MBEDTLS_X509_CRL_PARSE_C
S *
S * Enable X.509 CRL parsing.
S *
S * Module:  library/mbedtls_x509_crl.c
S * Caller:  library/mbedtls_x509_crt.c
S *
S * Requires: MBEDTLS_X509_USE_C
S *
S * This module is required for X.509 CRL parsing.
S */
S#define MBEDTLS_X509_CRL_PARSE_C
S
S/**
S * \def MBEDTLS_X509_CSR_PARSE_C
S *
S * Enable X.509 Certificate Signing Request (CSR) parsing.
S *
S * Module:  library/mbedtls_x509_csr.c
S * Caller:  library/x509_crt_write.c
S *
S * Requires: MBEDTLS_X509_USE_C
S *
S * This module is used for reading X.509 certificate request.
S */
S#define MBEDTLS_X509_CSR_PARSE_C
S
S/**
S * \def MBEDTLS_X509_CREATE_C
S *
S * Enable X.509 core for creating certificates.
S *
S * Module:  library/x509_create.c
S *
S * Requires: MBEDTLS_BIGNUM_C, MBEDTLS_OID_C, MBEDTLS_PK_WRITE_C
S *
S * This module is the basis for creating X.509 certificates and CSRs.
S */
S#define MBEDTLS_X509_CREATE_C
S
S/**
S * \def MBEDTLS_X509_CRT_WRITE_C
S *
S * Enable creating X.509 certificates.
S *
S * Module:  library/x509_crt_write.c
S *
S * Requires: MBEDTLS_X509_CREATE_C
S *
S * This module is required for X.509 certificate creation.
S */
S#define MBEDTLS_X509_CRT_WRITE_C
S
S/**
S * \def MBEDTLS_X509_CSR_WRITE_C
S *
S * Enable creating X.509 Certificate Signing Requests (CSR).
S *
S * Module:  library/x509_csr_write.c
S *
S * Requires: MBEDTLS_X509_CREATE_C
S *
S * This module is required for X.509 certificate request writing.
S */
S#define MBEDTLS_X509_CSR_WRITE_C
S
S/**
S * \def MBEDTLS_XTEA_C
S *
S * Enable the XTEA block cipher.
S *
S * Module:  library/xtea.c
S * Caller:
S */
S#define MBEDTLS_XTEA_C
S
S/* \} name SECTION: mbed TLS modules */
S
S/**
S * \name SECTION: Module configuration options
S *
S * This section allows for the setting of module specific sizes and
S * configuration options. The default values are already present in the
S * relevant header files and should suffice for the regular use cases.
S *
S * Our advice is to enable options and change their values here
S * only if you have a good reason and know the consequences.
S *
S * Please check the respective header file for documentation on these
S * parameters (to prevent duplicate documentation).
S * \{
S */
S
S/* MPI / BIGNUM options */
S//#define MBEDTLS_MPI_WINDOW_SIZE            6 /**< Maximum windows size used. */
S//#define MBEDTLS_MPI_MAX_SIZE            1024 /**< Maximum number of bytes for usable MPIs. */
S
S/* CTR_DRBG options */
S//#define MBEDTLS_CTR_DRBG_ENTROPY_LEN               48 /**< Amount of entropy used per seed by default (48 with SHA-512, 32 with SHA-256) */
S//#define MBEDTLS_CTR_DRBG_RESEED_INTERVAL        10000 /**< Interval before reseed is performed by default */
S//#define MBEDTLS_CTR_DRBG_MAX_INPUT                256 /**< Maximum number of additional input bytes */
S//#define MBEDTLS_CTR_DRBG_MAX_REQUEST             1024 /**< Maximum number of requested bytes per call */
S//#define MBEDTLS_CTR_DRBG_MAX_SEED_INPUT           384 /**< Maximum size of (re)seed buffer */
S
S/* HMAC_DRBG options */
S//#define MBEDTLS_HMAC_DRBG_RESEED_INTERVAL   10000 /**< Interval before reseed is performed by default */
S//#define MBEDTLS_HMAC_DRBG_MAX_INPUT           256 /**< Maximum number of additional input bytes */
S//#define MBEDTLS_HMAC_DRBG_MAX_REQUEST        1024 /**< Maximum number of requested bytes per call */
S//#define MBEDTLS_HMAC_DRBG_MAX_SEED_INPUT      384 /**< Maximum size of (re)seed buffer */
S
S/* ECP options */
S//#define MBEDTLS_ECP_MAX_BITS             521 /**< Maximum bit size of groups */
S//#define MBEDTLS_ECP_WINDOW_SIZE            6 /**< Maximum window size used */
S//#define MBEDTLS_ECP_FIXED_POINT_OPTIM      1 /**< Enable fixed-point speed-up */
S
S/* Entropy options */
S//#define MBEDTLS_ENTROPY_MAX_SOURCES                20 /**< Maximum number of sources supported */
S//#define MBEDTLS_ENTROPY_MAX_GATHER                128 /**< Maximum amount requested from entropy sources */
S
S/* Memory buffer allocator options */
S//#define MBEDTLS_MEMORY_ALIGN_MULTIPLE      4 /**< Align on multiples of this value */
S
S/* Platform options */
S//#define MBEDTLS_PLATFORM_STD_MEM_HDR   <stdlib.h> /**< Header to include if MBEDTLS_PLATFORM_NO_STD_FUNCTIONS is defined. Don't define if no header is needed. */
S//#define MBEDTLS_PLATFORM_STD_CALLOC        calloc /**< Default allocator to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_FREE            free /**< Default free to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_EXIT            exit /**< Default exit to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_FPRINTF      fprintf /**< Default fprintf to use, can be undefined */
S//#define MBEDTLS_PLATFORM_STD_PRINTF        printf /**< Default printf to use, can be undefined */
S/* Note: your snprintf must correclty zero-terminate the buffer! */
S//#define MBEDTLS_PLATFORM_STD_SNPRINTF    snprintf /**< Default snprintf to use, can be undefined */
S
S/* To Use Function Macros MBEDTLS_PLATFORM_C must be enabled */
S/* MBEDTLS_PLATFORM_XXX_MACRO and MBEDTLS_PLATFORM_XXX_ALT cannot both be defined */
S//#define MBEDTLS_PLATFORM_CALLOC_MACRO        calloc /**< Default allocator macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_FREE_MACRO            free /**< Default free macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_EXIT_MACRO            exit /**< Default exit macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_FPRINTF_MACRO      fprintf /**< Default fprintf macro to use, can be undefined */
S//#define MBEDTLS_PLATFORM_PRINTF_MACRO        printf /**< Default printf macro to use, can be undefined */
S/* Note: your snprintf must correclty zero-terminate the buffer! */
S//#define MBEDTLS_PLATFORM_SNPRINTF_MACRO    snprintf /**< Default snprintf macro to use, can be undefined */
S
S/* SSL Cache options */
S//#define MBEDTLS_SSL_CACHE_DEFAULT_TIMEOUT       86400 /**< 1 day  */
S//#define MBEDTLS_SSL_CACHE_DEFAULT_MAX_ENTRIES      50 /**< Maximum entries in cache */
S
S/* SSL options */
S//#define MBEDTLS_SSL_MAX_CONTENT_LEN             16384 /**< Maxium fragment length in bytes, determines the size of each of the two internal I/O buffers */
S//#define MBEDTLS_SSL_DEFAULT_TICKET_LIFETIME     86400 /**< Lifetime of session tickets (if enabled) */
S//#define MBEDTLS_PSK_MAX_LEN               32 /**< Max size of TLS pre-shared keys, in bytes (default 256 bits) */
S//#define MBEDTLS_SSL_COOKIE_TIMEOUT        60 /**< Default expiration delay of DTLS cookies, in seconds if HAVE_TIME, or in number of cookies issued */
S
S/**
S * Complete list of ciphersuites to use, in order of preference.
S *
S * \warning No dependency checking is done on that field! This option can only
S * be used to restrict the set of available ciphersuites. It is your
S * responsibility to make sure the needed modules are active.
S *
S * Use this to save a few hundred bytes of ROM (default ordering of all
S * available ciphersuites) and a few to a few hundred bytes of RAM.
S *
S * The value below is only an example, not the default.
S */
S//#define MBEDTLS_SSL_CIPHERSUITES MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
S
S/* X509 options */
S//#define MBEDTLS_X509_MAX_INTERMEDIATE_CA   8   /**< Maximum number of intermediate CAs in a verification chain. */
S
S/* \} name SECTION: Module configuration options */
S
S#if defined(TARGET_LIKE_MBED)
S#include "mbedtls/target_config.h"
S#endif
S
S/*
S * Allow user to override any previous default.
S *
S * Use two macro names for that, as:
S * - with yotta the prefix YOTTA_CFG_ is forced
S * - without yotta is looks weird to have a YOTTA prefix.
S */
S#if defined(YOTTA_CFG_MBEDTLS_USER_CONFIG_FILE)
S#include YOTTA_CFG_MBEDTLS_USER_CONFIG_FILE
S#elif defined(MBEDTLS_USER_CONFIG_FILE)
S#include MBEDTLS_USER_CONFIG_FILE
S#endif
S
S#include "check_config.h"
S
N#endif /* MBEDTLS_CONFIG_H */
L 45 "C:\Keil_v5\ARM\PACK\ARM\mbedTLS\1.1.1\library\ecp.c" 2
N#else
S#include MBEDTLS_CONFIG_FILE
N#endif
N
N#if defined(MBEDTLS_ECP_C)
X#if 0L
S
S#include "mbedtls/ecp.h"
S
S#include <string.h>
S
S#if defined(MBEDTLS_PLATFORM_C)
S#include "mbedtls/platform.h"
S#else
S#include <stdlib.h>
S#include <stdio.h>
S#define mbedtls_printf     printf
S#define mbedtls_calloc    calloc
S#define mbedtls_free       free
S#endif
S
S#if ( defined(__ARMCC_VERSION) || defined(_MSC_VER) ) && \
S    !defined(inline) && !defined(__cplusplus)
X#if ( defined(__ARMCC_VERSION) || defined(_MSC_VER) ) &&     !defined(inline) && !defined(__cplusplus)
S#define inline __inline
S#endif
S
S/* Implementation that should never be optimized out by the compiler */
Sstatic void mbedtls_zeroize( void *v, size_t n ) {
S    volatile unsigned char *p = v; while( n-- ) *p++ = 0;
S}
S
S#if defined(MBEDTLS_SELF_TEST)
S/*
S * Counts of point addition and doubling, and field multiplications.
S * Used to test resistance of point multiplication to simple timing attacks.
S */
Sstatic unsigned long add_count, dbl_count, mul_count;
S#endif
S
S#if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED) ||   \
S    defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED) ||   \
S    defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) ||   \
S    defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED) ||   \
S    defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED) ||   \
S    defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)   ||   \
S    defined(MBEDTLS_ECP_DP_BP384R1_ENABLED)   ||   \
S    defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)   ||   \
S    defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) ||   \
S    defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) ||   \
S    defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
X#if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED) ||       defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED) ||       defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED) ||       defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED) ||       defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED) ||       defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)   ||       defined(MBEDTLS_ECP_DP_BP384R1_ENABLED)   ||       defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)   ||       defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED) ||       defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED) ||       defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
S#define ECP_SHORTWEIERSTRASS
S#endif
S
S#if defined(MBEDTLS_ECP_DP_CURVE25519_ENABLED)
S#define ECP_MONTGOMERY
S#endif
S
S/*
S * Curve types: internal for now, might be exposed later
S */
Stypedef enum
S{
S    ECP_TYPE_NONE = 0,
S    ECP_TYPE_SHORT_WEIERSTRASS,    /* y^2 = x^3 + a x + b      */
S    ECP_TYPE_MONTGOMERY,           /* y^2 = x^3 + a x^2 + x    */
S} ecp_curve_type;
S
S/*
S * List of supported curves:
S *  - internal ID
S *  - TLS NamedCurve ID (RFC 4492 sec. 5.1.1, RFC 7071 sec. 2)
S *  - size in bits
S *  - readable name
S *
S * Curves are listed in order: largest curves first, and for a given size,
S * fastest curves first. This provides the default order for the SSL module.
S *
S * Reminder: update profiles in x509_crt.c when adding a new curves!
S */
Sstatic const mbedtls_ecp_curve_info ecp_supported_curves[] =
S{
S#if defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED)
S    { MBEDTLS_ECP_DP_SECP521R1,    25,     521,    "secp521r1"         },
S#endif
S#if defined(MBEDTLS_ECP_DP_BP512R1_ENABLED)
S    { MBEDTLS_ECP_DP_BP512R1,      28,     512,    "brainpoolP512r1"   },
S#endif
S#if defined(MBEDTLS_ECP_DP_SECP384R1_ENABLED)
S    { MBEDTLS_ECP_DP_SECP384R1,    24,     384,    "secp384r1"         },
S#endif
S#if defined(MBEDTLS_ECP_DP_BP384R1_ENABLED)
S    { MBEDTLS_ECP_DP_BP384R1,      27,     384,    "brainpoolP384r1"   },
S#endif
S#if defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED)
S    { MBEDTLS_ECP_DP_SECP256R1,    23,     256,    "secp256r1"         },
S#endif
S#if defined(MBEDTLS_ECP_DP_SECP256K1_ENABLED)
S    { MBEDTLS_ECP_DP_SECP256K1,    22,     256,    "secp256k1"         },
S#endif
S#if defined(MBEDTLS_ECP_DP_BP256R1_ENABLED)
S    { MBEDTLS_ECP_DP_BP256R1,      26,     256,    "brainpoolP256r1"   },
S#endif
S#if defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED)
S    { MBEDTLS_ECP_DP_SECP224R1,    21,     224,    "secp224r1"         },
S#endif
S#if defined(MBEDTLS_ECP_DP_SECP224K1_ENABLED)
S    { MBEDTLS_ECP_DP_SECP224K1,    20,     224,    "secp224k1"         },
S#endif
S#if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
S    { MBEDTLS_ECP_DP_SECP192R1,    19,     192,    "secp192r1"         },
S#endif
S#if defined(MBEDTLS_ECP_DP_SECP192K1_ENABLED)
S    { MBEDTLS_ECP_DP_SECP192K1,    18,     192,    "secp192k1"         },
S#endif
S    { MBEDTLS_ECP_DP_NONE,          0,     0,      NULL                },
S};
S
S#define ECP_NB_CURVES   sizeof( ecp_supported_curves ) /    \
S                        sizeof( ecp_supported_curves[0] )
X#define ECP_NB_CURVES   sizeof( ecp_supported_curves ) /                            sizeof( ecp_supported_curves[0] )
S
Sstatic mbedtls_ecp_group_id ecp_supported_grp_id[ECP_NB_CURVES];
S
S/*
S * List of supported curves and associated info
S */
Sconst mbedtls_ecp_curve_info *mbedtls_ecp_curve_list( void )
S{
S    return( ecp_supported_curves );
S}
S
S/*
S * List of supported curves, group ID only
S */
Sconst mbedtls_ecp_group_id *mbedtls_ecp_grp_id_list( void )
S{
S    static int init_done = 0;
S
S    if( ! init_done )
S    {
S        size_t i = 0;
S        const mbedtls_ecp_curve_info *curve_info;
S
S        for( curve_info = mbedtls_ecp_curve_list();
S             curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
S             curve_info++ )
S        {
S            ecp_supported_grp_id[i++] = curve_info->grp_id;
S        }
S        ecp_supported_grp_id[i] = MBEDTLS_ECP_DP_NONE;
S
S        init_done = 1;
S    }
S
S    return( ecp_supported_grp_id );
S}
S
S/*
S * Get the curve info for the internal identifier
S */
Sconst mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_grp_id( mbedtls_ecp_group_id grp_id )
S{
S    const mbedtls_ecp_curve_info *curve_info;
S
S    for( curve_info = mbedtls_ecp_curve_list();
S         curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
S         curve_info++ )
S    {
S        if( curve_info->grp_id == grp_id )
S            return( curve_info );
S    }
S
S    return( NULL );
S}
S
S/*
S * Get the curve info from the TLS identifier
S */
Sconst mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_tls_id( uint16_t tls_id )
S{
S    const mbedtls_ecp_curve_info *curve_info;
S
S    for( curve_info = mbedtls_ecp_curve_list();
S         curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
S         curve_info++ )
S    {
S        if( curve_info->tls_id == tls_id )
S            return( curve_info );
S    }
S
S    return( NULL );
S}
S
S/*
S * Get the curve info from the name
S */
Sconst mbedtls_ecp_curve_info *mbedtls_ecp_curve_info_from_name( const char *name )
S{
S    const mbedtls_ecp_curve_info *curve_info;
S
S    for( curve_info = mbedtls_ecp_curve_list();
S         curve_info->grp_id != MBEDTLS_ECP_DP_NONE;
S         curve_info++ )
S    {
S        if( strcmp( curve_info->name, name ) == 0 )
S            return( curve_info );
S    }
S
S    return( NULL );
S}
S
S/*
S * Get the type of a curve
S */
Sstatic inline ecp_curve_type ecp_get_type( const mbedtls_ecp_group *grp )
S{
S    if( grp->G.X.p == NULL )
S        return( ECP_TYPE_NONE );
S
S    if( grp->G.Y.p == NULL )
S        return( ECP_TYPE_MONTGOMERY );
S    else
S        return( ECP_TYPE_SHORT_WEIERSTRASS );
S}
S
S/*
S * Initialize (the components of) a point
S */
Svoid mbedtls_ecp_point_init( mbedtls_ecp_point *pt )
S{
S    if( pt == NULL )
S        return;
S
S    mbedtls_mpi_init( &pt->X );
S    mbedtls_mpi_init( &pt->Y );
S    mbedtls_mpi_init( &pt->Z );
S}
S
S/*
S * Initialize (the components of) a group
S */
Svoid mbedtls_ecp_group_init( mbedtls_ecp_group *grp )
S{
S    if( grp == NULL )
S        return;
S
S    memset( grp, 0, sizeof( mbedtls_ecp_group ) );
S}
S
S/*
S * Initialize (the components of) a key pair
S */
Svoid mbedtls_ecp_keypair_init( mbedtls_ecp_keypair *key )
S{
S    if( key == NULL )
S        return;
S
S    mbedtls_ecp_group_init( &key->grp );
S    mbedtls_mpi_init( &key->d );
S    mbedtls_ecp_point_init( &key->Q );
S}
S
S/*
S * Unallocate (the components of) a point
S */
Svoid mbedtls_ecp_point_free( mbedtls_ecp_point *pt )
S{
S    if( pt == NULL )
S        return;
S
S    mbedtls_mpi_free( &( pt->X ) );
S    mbedtls_mpi_free( &( pt->Y ) );
S    mbedtls_mpi_free( &( pt->Z ) );
S}
S
S/*
S * Unallocate (the components of) a group
S */
Svoid mbedtls_ecp_group_free( mbedtls_ecp_group *grp )
S{
S    size_t i;
S
S    if( grp == NULL )
S        return;
S
S    if( grp->h != 1 )
S    {
S        mbedtls_mpi_free( &grp->P );
S        mbedtls_mpi_free( &grp->A );
S        mbedtls_mpi_free( &grp->B );
S        mbedtls_ecp_point_free( &grp->G );
S        mbedtls_mpi_free( &grp->N );
S    }
S
S    if( grp->T != NULL )
S    {
S        for( i = 0; i < grp->T_size; i++ )
S            mbedtls_ecp_point_free( &grp->T[i] );
S        mbedtls_free( grp->T );
S    }
S
S    mbedtls_zeroize( grp, sizeof( mbedtls_ecp_group ) );
S}
S
S/*
S * Unallocate (the components of) a key pair
S */
Svoid mbedtls_ecp_keypair_free( mbedtls_ecp_keypair *key )
S{
S    if( key == NULL )
S        return;
S
S    mbedtls_ecp_group_free( &key->grp );
S    mbedtls_mpi_free( &key->d );
S    mbedtls_ecp_point_free( &key->Q );
S}
S
S/*
S * Copy the contents of a point
S */
Sint mbedtls_ecp_copy( mbedtls_ecp_point *P, const mbedtls_ecp_point *Q )
S{
S    int ret;
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->X, &Q->X ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Y, &Q->Y ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &P->Z, &Q->Z ) );
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Copy the contents of a group object
S */
Sint mbedtls_ecp_group_copy( mbedtls_ecp_group *dst, const mbedtls_ecp_group *src )
S{
S    return mbedtls_ecp_group_load( dst, src->id );
S}
S
S/*
S * Set point to zero
S */
Sint mbedtls_ecp_set_zero( mbedtls_ecp_point *pt )
S{
S    int ret;
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->X , 1 ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Y , 1 ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z , 0 ) );
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Tell if a point is zero
S */
Sint mbedtls_ecp_is_zero( mbedtls_ecp_point *pt )
S{
S    return( mbedtls_mpi_cmp_int( &pt->Z, 0 ) == 0 );
S}
S
S/*
S * Compare two points lazyly
S */
Sint mbedtls_ecp_point_cmp( const mbedtls_ecp_point *P,
S                           const mbedtls_ecp_point *Q )
S{
S    if( mbedtls_mpi_cmp_mpi( &P->X, &Q->X ) == 0 &&
S        mbedtls_mpi_cmp_mpi( &P->Y, &Q->Y ) == 0 &&
S        mbedtls_mpi_cmp_mpi( &P->Z, &Q->Z ) == 0 )
S    {
S        return( 0 );
S    }
S
S    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S}
S
S/*
S * Import a non-zero point from ASCII strings
S */
Sint mbedtls_ecp_point_read_string( mbedtls_ecp_point *P, int radix,
S                           const char *x, const char *y )
S{
S    int ret;
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &P->X, radix, x ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &P->Y, radix, y ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->Z, 1 ) );
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Export a point into unsigned binary data (SEC1 2.3.3)
S */
Sint mbedtls_ecp_point_write_binary( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *P,
S                            int format, size_t *olen,
S                            unsigned char *buf, size_t buflen )
S{
S    int ret = 0;
S    size_t plen;
S
S    if( format != MBEDTLS_ECP_PF_UNCOMPRESSED &&
S        format != MBEDTLS_ECP_PF_COMPRESSED )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    /*
S     * Common case: P == 0
S     */
S    if( mbedtls_mpi_cmp_int( &P->Z, 0 ) == 0 )
S    {
S        if( buflen < 1 )
S            return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
S
S        buf[0] = 0x00;
S        *olen = 1;
S
S        return( 0 );
S    }
S
S    plen = mbedtls_mpi_size( &grp->P );
S
S    if( format == MBEDTLS_ECP_PF_UNCOMPRESSED )
S    {
S        *olen = 2 * plen + 1;
S
S        if( buflen < *olen )
S            return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
S
S        buf[0] = 0x04;
S        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->Y, buf + 1 + plen, plen ) );
S    }
S    else if( format == MBEDTLS_ECP_PF_COMPRESSED )
S    {
S        *olen = plen + 1;
S
S        if( buflen < *olen )
S            return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
S
S        buf[0] = 0x02 + mbedtls_mpi_get_bit( &P->Y, 0 );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &P->X, buf + 1, plen ) );
S    }
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Import a point from unsigned binary data (SEC1 2.3.4)
S */
Sint mbedtls_ecp_point_read_binary( const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt,
S                           const unsigned char *buf, size_t ilen )
S{
S    int ret;
S    size_t plen;
S
S    if( ilen < 1 )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    if( buf[0] == 0x00 )
S    {
S        if( ilen == 1 )
S            return( mbedtls_ecp_set_zero( pt ) );
S        else
S            return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S    }
S
S    plen = mbedtls_mpi_size( &grp->P );
S
S    if( buf[0] != 0x04 )
S        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
S
S    if( ilen != 2 * plen + 1 )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->X, buf + 1, plen ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &pt->Y, buf + 1 + plen, plen ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Import a point from a TLS ECPoint record (RFC 4492)
S *      struct {
S *          opaque point <1..2^8-1>;
S *      } ECPoint;
S */
Sint mbedtls_ecp_tls_read_point( const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt,
S                        const unsigned char **buf, size_t buf_len )
S{
S    unsigned char data_len;
S    const unsigned char *buf_start;
S
S    /*
S     * We must have at least two bytes (1 for length, at least one for data)
S     */
S    if( buf_len < 2 )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    data_len = *(*buf)++;
S    if( data_len < 1 || data_len > buf_len - 1 )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    /*
S     * Save buffer start for read_binary and update buf
S     */
S    buf_start = *buf;
S    *buf += data_len;
S
S    return mbedtls_ecp_point_read_binary( grp, pt, buf_start, data_len );
S}
S
S/*
S * Export a point as a TLS ECPoint record (RFC 4492)
S *      struct {
S *          opaque point <1..2^8-1>;
S *      } ECPoint;
S */
Sint mbedtls_ecp_tls_write_point( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt,
S                         int format, size_t *olen,
S                         unsigned char *buf, size_t blen )
S{
S    int ret;
S
S    /*
S     * buffer length must be at least one, for our length byte
S     */
S    if( blen < 1 )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    if( ( ret = mbedtls_ecp_point_write_binary( grp, pt, format,
S                    olen, buf + 1, blen - 1) ) != 0 )
S        return( ret );
S
S    /*
S     * write length to the first byte and update total length
S     */
S    buf[0] = (unsigned char) *olen;
S    ++*olen;
S
S    return( 0 );
S}
S
S/*
S * Set a group from an ECParameters record (RFC 4492)
S */
Sint mbedtls_ecp_tls_read_group( mbedtls_ecp_group *grp, const unsigned char **buf, size_t len )
S{
S    uint16_t tls_id;
S    const mbedtls_ecp_curve_info *curve_info;
S
S    /*
S     * We expect at least three bytes (see below)
S     */
S    if( len < 3 )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    /*
S     * First byte is curve_type; only named_curve is handled
S     */
S    if( *(*buf)++ != MBEDTLS_ECP_TLS_NAMED_CURVE )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    /*
S     * Next two bytes are the namedcurve value
S     */
S    tls_id = *(*buf)++;
S    tls_id <<= 8;
S    tls_id |= *(*buf)++;
S
S    if( ( curve_info = mbedtls_ecp_curve_info_from_tls_id( tls_id ) ) == NULL )
S        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
S
S    return mbedtls_ecp_group_load( grp, curve_info->grp_id );
S}
S
S/*
S * Write the ECParameters record corresponding to a group (RFC 4492)
S */
Sint mbedtls_ecp_tls_write_group( const mbedtls_ecp_group *grp, size_t *olen,
S                         unsigned char *buf, size_t blen )
S{
S    const mbedtls_ecp_curve_info *curve_info;
S
S    if( ( curve_info = mbedtls_ecp_curve_info_from_grp_id( grp->id ) ) == NULL )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    /*
S     * We are going to write 3 bytes (see below)
S     */
S    *olen = 3;
S    if( blen < *olen )
S        return( MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL );
S
S    /*
S     * First byte is curve_type, always named_curve
S     */
S    *buf++ = MBEDTLS_ECP_TLS_NAMED_CURVE;
S
S    /*
S     * Next two bytes are the namedcurve value
S     */
S    buf[0] = curve_info->tls_id >> 8;
S    buf[1] = curve_info->tls_id & 0xFF;
S
S    return( 0 );
S}
S
S/*
S * Wrapper around fast quasi-modp functions, with fall-back to mbedtls_mpi_mod_mpi.
S * See the documentation of struct mbedtls_ecp_group.
S *
S * This function is in the critial loop for mbedtls_ecp_mul, so pay attention to perf.
S */
Sstatic int ecp_modp( mbedtls_mpi *N, const mbedtls_ecp_group *grp )
S{
S    int ret;
S
S    if( grp->modp == NULL )
S        return( mbedtls_mpi_mod_mpi( N, N, &grp->P ) );
S
S    /* N->s < 0 is a much faster test, which fails only if N is 0 */
S    if( ( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 ) ||
S        mbedtls_mpi_bitlen( N ) > 2 * grp->pbits )
S    {
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S    }
S
S    MBEDTLS_MPI_CHK( grp->modp( N ) );
S
S    /* N->s < 0 is a much faster test, which fails only if N is 0 */
S    while( N->s < 0 && mbedtls_mpi_cmp_int( N, 0 ) != 0 )
S        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( N, N, &grp->P ) );
S
S    while( mbedtls_mpi_cmp_mpi( N, &grp->P ) >= 0 )
S        /* we known P, N and the result are positive */
S        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( N, N, &grp->P ) );
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Fast mod-p functions expect their argument to be in the 0..p^2 range.
S *
S * In order to guarantee that, we need to ensure that operands of
S * mbedtls_mpi_mul_mpi are in the 0..p range. So, after each operation we will
S * bring the result back to this range.
S *
S * The following macros are shortcuts for doing that.
S */
S
S/*
S * Reduce a mbedtls_mpi mod p in-place, general case, to use after mbedtls_mpi_mul_mpi
S */
S#if defined(MBEDTLS_SELF_TEST)
S#define INC_MUL_COUNT   mul_count++;
S#else
S#define INC_MUL_COUNT
S#endif
S
S#define MOD_MUL( N )    do { MBEDTLS_MPI_CHK( ecp_modp( &N, grp ) ); INC_MUL_COUNT } \
S                        while( 0 )
X#define MOD_MUL( N )    do { MBEDTLS_MPI_CHK( ecp_modp( &N, grp ) ); INC_MUL_COUNT }                         while( 0 )
S
S/*
S * Reduce a mbedtls_mpi mod p in-place, to use after mbedtls_mpi_sub_mpi
S * N->s < 0 is a very fast test, which fails only if N is 0
S */
S#define MOD_SUB( N )                                \
S    while( N.s < 0 && mbedtls_mpi_cmp_int( &N, 0 ) != 0 )   \
S        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &N, &N, &grp->P ) )
X#define MOD_SUB( N )                                    while( N.s < 0 && mbedtls_mpi_cmp_int( &N, 0 ) != 0 )           MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &N, &N, &grp->P ) )
S
S/*
S * Reduce a mbedtls_mpi mod p in-place, to use after mbedtls_mpi_add_mpi and mbedtls_mpi_mul_int.
S * We known P, N and the result are positive, so sub_abs is correct, and
S * a bit faster.
S */
S#define MOD_ADD( N )                                \
S    while( mbedtls_mpi_cmp_mpi( &N, &grp->P ) >= 0 )        \
S        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &N, &N, &grp->P ) )
X#define MOD_ADD( N )                                    while( mbedtls_mpi_cmp_mpi( &N, &grp->P ) >= 0 )                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &N, &N, &grp->P ) )
S
S#if defined(ECP_SHORTWEIERSTRASS)
S/*
S * For curves in short Weierstrass form, we do all the internal operations in
S * Jacobian coordinates.
S *
S * For multiplication, we'll use a comb method with coutermeasueres against
S * SPA, hence timing attacks.
S */
S
S/*
S * Normalize jacobian coordinates so that Z == 0 || Z == 1  (GECC 3.2.1)
S * Cost: 1N := 1I + 3M + 1S
S */
Sstatic int ecp_normalize_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt )
S{
S    int ret;
S    mbedtls_mpi Zi, ZZi;
S
S    if( mbedtls_mpi_cmp_int( &pt->Z, 0 ) == 0 )
S        return( 0 );
S
S    mbedtls_mpi_init( &Zi ); mbedtls_mpi_init( &ZZi );
S
S    /*
S     * X = X / Z^2  mod p
S     */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &Zi,      &pt->Z,     &grp->P ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,        &Zi     ) ); MOD_MUL( ZZi );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ZZi    ) ); MOD_MUL( pt->X );
S
S    /*
S     * Y = Y / Z^3  mod p
S     */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ZZi    ) ); MOD_MUL( pt->Y );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &Zi     ) ); MOD_MUL( pt->Y );
S
S    /*
S     * Z = 1
S     */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
S
Scleanup:
S
S    mbedtls_mpi_free( &Zi ); mbedtls_mpi_free( &ZZi );
S
S    return( ret );
S}
S
S/*
S * Normalize jacobian coordinates of an array of (pointers to) points,
S * using Montgomery's trick to perform only one inversion mod P.
S * (See for example Cohen's "A Course in Computational Algebraic Number
S * Theory", Algorithm 10.3.4.)
S *
S * Warning: fails (returning an error) if one of the points is zero!
S * This should never happen, see choice of w in ecp_mul_comb().
S *
S * Cost: 1N(t) := 1I + (6t - 3)M + 1S
S */
Sstatic int ecp_normalize_jac_many( const mbedtls_ecp_group *grp,
S                                   mbedtls_ecp_point *T[], size_t t_len )
S{
S    int ret;
S    size_t i;
S    mbedtls_mpi *c, u, Zi, ZZi;
S
S    if( t_len < 2 )
S        return( ecp_normalize_jac( grp, *T ) );
S
S    if( ( c = mbedtls_calloc( t_len, sizeof( mbedtls_mpi ) ) ) == NULL )
S        return( MBEDTLS_ERR_ECP_ALLOC_FAILED );
S
S    mbedtls_mpi_init( &u ); mbedtls_mpi_init( &Zi ); mbedtls_mpi_init( &ZZi );
S
S    /*
S     * c[i] = Z_0 * ... * Z_i
S     */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &c[0], &T[0]->Z ) );
S    for( i = 1; i < t_len; i++ )
S    {
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &c[i], &c[i-1], &T[i]->Z ) );
S        MOD_MUL( c[i] );
S    }
S
S    /*
S     * u = 1 / (Z_0 * ... * Z_n) mod P
S     */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &u, &c[t_len-1], &grp->P ) );
S
S    for( i = t_len - 1; ; i-- )
S    {
S        /*
S         * Zi = 1 / Z_i mod p
S         * u = 1 / (Z_0 * ... * Z_i) mod P
S         */
S        if( i == 0 ) {
S            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Zi, &u ) );
S        }
S        else
S        {
S            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Zi, &u, &c[i-1]  ) ); MOD_MUL( Zi );
S            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &u,  &u, &T[i]->Z ) ); MOD_MUL( u );
S        }
S
S        /*
S         * proceed as in normalize()
S         */
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ZZi,     &Zi,      &Zi  ) ); MOD_MUL( ZZi );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->X, &T[i]->X, &ZZi ) ); MOD_MUL( T[i]->X );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &ZZi ) ); MOD_MUL( T[i]->Y );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T[i]->Y, &T[i]->Y, &Zi  ) ); MOD_MUL( T[i]->Y );
S
S        /*
S         * Post-precessing: reclaim some memory by shrinking coordinates
S         * - not storing Z (always 1)
S         * - shrinking other coordinates, but still keeping the same number of
S         *   limbs as P, as otherwise it will too likely be regrown too fast.
S         */
S        MBEDTLS_MPI_CHK( mbedtls_mpi_shrink( &T[i]->X, grp->P.n ) );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_shrink( &T[i]->Y, grp->P.n ) );
S        mbedtls_mpi_free( &T[i]->Z );
S
S        if( i == 0 )
S            break;
S    }
S
Scleanup:
S
S    mbedtls_mpi_free( &u ); mbedtls_mpi_free( &Zi ); mbedtls_mpi_free( &ZZi );
S    for( i = 0; i < t_len; i++ )
S        mbedtls_mpi_free( &c[i] );
S    mbedtls_free( c );
S
S    return( ret );
S}
S
S/*
S * Conditional point inversion: Q -> -Q = (Q.X, -Q.Y, Q.Z) without leak.
S * "inv" must be 0 (don't invert) or 1 (invert) or the result will be invalid
S */
Sstatic int ecp_safe_invert_jac( const mbedtls_ecp_group *grp,
S                            mbedtls_ecp_point *Q,
S                            unsigned char inv )
S{
S    int ret;
S    unsigned char nonzero;
S    mbedtls_mpi mQY;
S
S    mbedtls_mpi_init( &mQY );
S
S    /* Use the fact that -Q.Y mod P = P - Q.Y unless Q.Y == 0 */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &mQY, &grp->P, &Q->Y ) );
S    nonzero = mbedtls_mpi_cmp_int( &Q->Y, 0 ) != 0;
S    MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &Q->Y, &mQY, inv & nonzero ) );
S
Scleanup:
S    mbedtls_mpi_free( &mQY );
S
S    return( ret );
S}
S
S/*
S * Point doubling R = 2 P, Jacobian coordinates
S *
S * Based on http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2 .
S *
S * We follow the variable naming fairly closely. The formula variations that trade a MUL for a SQR
S * (plus a few ADDs) aren't useful as our bignum implementation doesn't distinguish squaring.
S *
S * Standard optimizations are applied when curve parameter A is one of { 0, -3 }.
S *
S * Cost: 1D := 3M + 4S          (A ==  0)
S *             4M + 4S          (A == -3)
S *             3M + 6S + 1a     otherwise
S */
Sstatic int ecp_double_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
S                           const mbedtls_ecp_point *P )
S{
S    int ret;
S    mbedtls_mpi M, S, T, U;
S
S#if defined(MBEDTLS_SELF_TEST)
S    dbl_count++;
S#endif
S
S    mbedtls_mpi_init( &M ); mbedtls_mpi_init( &S ); mbedtls_mpi_init( &T ); mbedtls_mpi_init( &U );
S
S    /* Special case for A = -3 */
S    if( grp->A.p == NULL )
S    {
S        /* M = 3(X + Z^2)(X - Z^2) */
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T,  &P->X,  &S      ) ); MOD_ADD( T );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U,  &P->X,  &S      ) ); MOD_SUB( U );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &U      ) ); MOD_MUL( S );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
S    }
S    else
S    {
S        /* M = 3.X^2 */
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &P->X   ) ); MOD_MUL( S );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &M,  &S,     3       ) ); MOD_ADD( M );
S
S        /* Optimize away for "koblitz" curves with A = 0 */
S        if( mbedtls_mpi_cmp_int( &grp->A, 0 ) != 0 )
S        {
S            /* M += A.Z^4 */
S            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->Z,  &P->Z   ) ); MOD_MUL( S );
S            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &S,     &S      ) ); MOD_MUL( T );
S            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &T,     &grp->A ) ); MOD_MUL( S );
S            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &M,  &M,     &S      ) ); MOD_ADD( M );
S        }
S    }
S
S    /* S = 4.X.Y^2 */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &P->Y,  &P->Y   ) ); MOD_MUL( T );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T,  1               ) ); MOD_ADD( T );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &P->X,  &T      ) ); MOD_MUL( S );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &S,  1               ) ); MOD_ADD( S );
S
S    /* U = 8.Y^4 */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &T,     &T      ) ); MOD_MUL( U );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
S
S    /* T = M^2 - 2.S */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T,  &M,     &M      ) ); MOD_MUL( T );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T,  &T,     &S      ) ); MOD_SUB( T );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T,  &T,     &S      ) ); MOD_SUB( T );
S
S    /* S = M(S - T) - U */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S,  &S,     &T      ) ); MOD_SUB( S );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S,  &S,     &M      ) ); MOD_MUL( S );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S,  &S,     &U      ) ); MOD_SUB( S );
S
S    /* U = 2.Y.Z */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &U,  &P->Y,  &P->Z   ) ); MOD_MUL( U );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &U,  1               ) ); MOD_ADD( U );
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->X, &T ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Y, &S ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Z, &U ) );
S
Scleanup:
S    mbedtls_mpi_free( &M ); mbedtls_mpi_free( &S ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &U );
S
S    return( ret );
S}
S
S/*
S * Addition: R = P + Q, mixed affine-Jacobian coordinates (GECC 3.22)
S *
S * The coordinates of Q must be normalized (= affine),
S * but those of P don't need to. R is not normalized.
S *
S * Special cases: (1) P or Q is zero, (2) R is zero, (3) P == Q.
S * None of these cases can happen as intermediate step in ecp_mul_comb():
S * - at each step, P, Q and R are multiples of the base point, the factor
S *   being less than its order, so none of them is zero;
S * - Q is an odd multiple of the base point, P an even multiple,
S *   due to the choice of precomputed points in the modified comb method.
S * So branches for these cases do not leak secret information.
S *
S * We accept Q->Z being unset (saving memory in tables) as meaning 1.
S *
S * Cost: 1A := 8M + 3S
S */
Sstatic int ecp_add_mixed( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
S                          const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q )
S{
S    int ret;
S    mbedtls_mpi T1, T2, T3, T4, X, Y, Z;
S
S#if defined(MBEDTLS_SELF_TEST)
S    add_count++;
S#endif
S
S    /*
S     * Trivial cases: P == 0 or Q == 0 (case 1)
S     */
S    if( mbedtls_mpi_cmp_int( &P->Z, 0 ) == 0 )
S        return( mbedtls_ecp_copy( R, Q ) );
S
S    if( Q->Z.p != NULL && mbedtls_mpi_cmp_int( &Q->Z, 0 ) == 0 )
S        return( mbedtls_ecp_copy( R, P ) );
S
S    /*
S     * Make sure Q coordinates are normalized
S     */
S    if( Q->Z.p != NULL && mbedtls_mpi_cmp_int( &Q->Z, 1 ) != 0 )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    mbedtls_mpi_init( &T1 ); mbedtls_mpi_init( &T2 ); mbedtls_mpi_init( &T3 ); mbedtls_mpi_init( &T4 );
S    mbedtls_mpi_init( &X ); mbedtls_mpi_init( &Y ); mbedtls_mpi_init( &Z );
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &P->Z,  &P->Z ) );  MOD_MUL( T1 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T1,    &P->Z ) );  MOD_MUL( T2 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T1,  &T1,    &Q->X ) );  MOD_MUL( T1 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T2,  &T2,    &Q->Y ) );  MOD_MUL( T2 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T1,  &T1,    &P->X ) );  MOD_SUB( T1 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T2,  &T2,    &P->Y ) );  MOD_SUB( T2 );
S
S    /* Special cases (2) and (3) */
S    if( mbedtls_mpi_cmp_int( &T1, 0 ) == 0 )
S    {
S        if( mbedtls_mpi_cmp_int( &T2, 0 ) == 0 )
S        {
S            ret = ecp_double_jac( grp, R, P );
S            goto cleanup;
S        }
S        else
S        {
S            ret = mbedtls_ecp_set_zero( R );
S            goto cleanup;
S        }
S    }
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &Z,   &P->Z,  &T1   ) );  MOD_MUL( Z  );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T1,    &T1   ) );  MOD_MUL( T3 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T3,    &T1   ) );  MOD_MUL( T4 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &P->X ) );  MOD_MUL( T3 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1,  &T3,    2     ) );  MOD_ADD( T1 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &X,   &T2,    &T2   ) );  MOD_MUL( X  );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T1   ) );  MOD_SUB( X  );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X,   &X,     &T4   ) );  MOD_SUB( X  );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T3,  &T3,    &X    ) );  MOD_SUB( T3 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T3,  &T3,    &T2   ) );  MOD_MUL( T3 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T4,  &T4,    &P->Y ) );  MOD_MUL( T4 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &Y,   &T3,    &T4   ) );  MOD_SUB( Y  );
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->X, &X ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Y, &Y ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R->Z, &Z ) );
S
Scleanup:
S
S    mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 ); mbedtls_mpi_free( &T3 ); mbedtls_mpi_free( &T4 );
S    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
S
S    return( ret );
S}
S
S/*
S * Randomize jacobian coordinates:
S * (X, Y, Z) -> (l^2 X, l^3 Y, l Z) for random l
S * This is sort of the reverse operation of ecp_normalize_jac().
S *
S * This countermeasure was first suggested in [2].
S */
Sstatic int ecp_randomize_jac( const mbedtls_ecp_group *grp, mbedtls_ecp_point *pt,
S                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
S{
S    int ret;
S    mbedtls_mpi l, ll;
S    size_t p_size = ( grp->pbits + 7 ) / 8;
S    int count = 0;
S
S    mbedtls_mpi_init( &l ); mbedtls_mpi_init( &ll );
S
S    /* Generate l such that 1 < l < p */
S    do
S    {
S        mbedtls_mpi_fill_random( &l, p_size, f_rng, p_rng );
S
S        while( mbedtls_mpi_cmp_mpi( &l, &grp->P ) >= 0 )
S            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &l, 1 ) );
S
S        if( count++ > 10 )
S            return( MBEDTLS_ERR_ECP_RANDOM_FAILED );
S    }
S    while( mbedtls_mpi_cmp_int( &l, 1 ) <= 0 );
S
S    /* Z = l * Z */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Z,   &pt->Z,     &l  ) ); MOD_MUL( pt->Z );
S
S    /* X = l^2 * X */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &l,         &l  ) ); MOD_MUL( ll );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->X,   &pt->X,     &ll ) ); MOD_MUL( pt->X );
S
S    /* Y = l^3 * Y */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ll,      &ll,        &l  ) ); MOD_MUL( ll );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &pt->Y,   &pt->Y,     &ll ) ); MOD_MUL( pt->Y );
S
Scleanup:
S    mbedtls_mpi_free( &l ); mbedtls_mpi_free( &ll );
S
S    return( ret );
S}
S
S/*
S * Check and define parameters used by the comb method (see below for details)
S */
S#if MBEDTLS_ECP_WINDOW_SIZE < 2 || MBEDTLS_ECP_WINDOW_SIZE > 7
S#error "MBEDTLS_ECP_WINDOW_SIZE out of bounds"
S#endif
S
S/* d = ceil( n / w ) */
S#define COMB_MAX_D      ( MBEDTLS_ECP_MAX_BITS + 1 ) / 2
S
S/* number of precomputed points */
S#define COMB_MAX_PRE    ( 1 << ( MBEDTLS_ECP_WINDOW_SIZE - 1 ) )
S
S/*
S * Compute the representation of m that will be used with our comb method.
S *
S * The basic comb method is described in GECC 3.44 for example. We use a
S * modified version that provides resistance to SPA by avoiding zero
S * digits in the representation as in [3]. We modify the method further by
S * requiring that all K_i be odd, which has the small cost that our
S * representation uses one more K_i, due to carries.
S *
S * Also, for the sake of compactness, only the seven low-order bits of x[i]
S * are used to represent K_i, and the msb of x[i] encodes the the sign (s_i in
S * the paper): it is set if and only if if s_i == -1;
S *
S * Calling conventions:
S * - x is an array of size d + 1
S * - w is the size, ie number of teeth, of the comb, and must be between
S *   2 and 7 (in practice, between 2 and MBEDTLS_ECP_WINDOW_SIZE)
S * - m is the MPI, expected to be odd and such that bitlength(m) <= w * d
S *   (the result will be incorrect if these assumptions are not satisfied)
S */
Sstatic void ecp_comb_fixed( unsigned char x[], size_t d,
S                            unsigned char w, const mbedtls_mpi *m )
S{
S    size_t i, j;
S    unsigned char c, cc, adjust;
S
S    memset( x, 0, d+1 );
S
S    /* First get the classical comb values (except for x_d = 0) */
S    for( i = 0; i < d; i++ )
S        for( j = 0; j < w; j++ )
S            x[i] |= mbedtls_mpi_get_bit( m, i + d * j ) << j;
S
S    /* Now make sure x_1 .. x_d are odd */
S    c = 0;
S    for( i = 1; i <= d; i++ )
S    {
S        /* Add carry and update it */
S        cc   = x[i] & c;
S        x[i] = x[i] ^ c;
S        c = cc;
S
S        /* Adjust if needed, avoiding branches */
S        adjust = 1 - ( x[i] & 0x01 );
S        c   |= x[i] & ( x[i-1] * adjust );
S        x[i] = x[i] ^ ( x[i-1] * adjust );
S        x[i-1] |= adjust << 7;
S    }
S}
S
S/*
S * Precompute points for the comb method
S *
S * If i = i_{w-1} ... i_1 is the binary representation of i, then
S * T[i] = i_{w-1} 2^{(w-1)d} P + ... + i_1 2^d P + P
S *
S * T must be able to hold 2^{w - 1} elements
S *
S * Cost: d(w-1) D + (2^{w-1} - 1) A + 1 N(w-1) + 1 N(2^{w-1} - 1)
S */
Sstatic int ecp_precompute_comb( const mbedtls_ecp_group *grp,
S                                mbedtls_ecp_point T[], const mbedtls_ecp_point *P,
S                                unsigned char w, size_t d )
S{
S    int ret;
S    unsigned char i, k;
S    size_t j;
S    mbedtls_ecp_point *cur, *TT[COMB_MAX_PRE - 1];
S
S    /*
S     * Set T[0] = P and
S     * T[2^{l-1}] = 2^{dl} P for l = 1 .. w-1 (this is not the final value)
S     */
S    MBEDTLS_MPI_CHK( mbedtls_ecp_copy( &T[0], P ) );
S
S    k = 0;
S    for( i = 1; i < ( 1U << ( w - 1 ) ); i <<= 1 )
S    {
S        cur = T + i;
S        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( cur, T + ( i >> 1 ) ) );
S        for( j = 0; j < d; j++ )
S            MBEDTLS_MPI_CHK( ecp_double_jac( grp, cur, cur ) );
S
S        TT[k++] = cur;
S    }
S
S    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, k ) );
S
S    /*
S     * Compute the remaining ones using the minimal number of additions
S     * Be careful to update T[2^l] only after using it!
S     */
S    k = 0;
S    for( i = 1; i < ( 1U << ( w - 1 ) ); i <<= 1 )
S    {
S        j = i;
S        while( j-- )
S        {
S            MBEDTLS_MPI_CHK( ecp_add_mixed( grp, &T[i + j], &T[j], &T[i] ) );
S            TT[k++] = &T[i + j];
S        }
S    }
S
S    MBEDTLS_MPI_CHK( ecp_normalize_jac_many( grp, TT, k ) );
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Select precomputed point: R = sign(i) * T[ abs(i) / 2 ]
S */
Sstatic int ecp_select_comb( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
S                            const mbedtls_ecp_point T[], unsigned char t_len,
S                            unsigned char i )
S{
S    int ret;
S    unsigned char ii, j;
S
S    /* Ignore the "sign" bit and scale down */
S    ii =  ( i & 0x7Fu ) >> 1;
S
S    /* Read the whole table to thwart cache-based timing attacks */
S    for( j = 0; j < t_len; j++ )
S    {
S        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &R->X, &T[j].X, j == ii ) );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &R->Y, &T[j].Y, j == ii ) );
S    }
S
S    /* Safely invert result if i is "negative" */
S    MBEDTLS_MPI_CHK( ecp_safe_invert_jac( grp, R, i >> 7 ) );
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Core multiplication algorithm for the (modified) comb method.
S * This part is actually common with the basic comb method (GECC 3.44)
S *
S * Cost: d A + d D + 1 R
S */
Sstatic int ecp_mul_comb_core( const mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
S                              const mbedtls_ecp_point T[], unsigned char t_len,
S                              const unsigned char x[], size_t d,
S                              int (*f_rng)(void *, unsigned char *, size_t),
S                              void *p_rng )
S{
S    int ret;
S    mbedtls_ecp_point Txi;
S    size_t i;
S
S    mbedtls_ecp_point_init( &Txi );
S
S    /* Start with a non-zero point and randomize its coordinates */
S    i = d;
S    MBEDTLS_MPI_CHK( ecp_select_comb( grp, R, T, t_len, x[i] ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->Z, 1 ) );
S    if( f_rng != 0 )
S        MBEDTLS_MPI_CHK( ecp_randomize_jac( grp, R, f_rng, p_rng ) );
S
S    while( i-- != 0 )
S    {
S        MBEDTLS_MPI_CHK( ecp_double_jac( grp, R, R ) );
S        MBEDTLS_MPI_CHK( ecp_select_comb( grp, &Txi, T, t_len, x[i] ) );
S        MBEDTLS_MPI_CHK( ecp_add_mixed( grp, R, R, &Txi ) );
S    }
S
Scleanup:
S    mbedtls_ecp_point_free( &Txi );
S
S    return( ret );
S}
S
S/*
S * Multiplication using the comb method,
S * for curves in short Weierstrass form
S */
Sstatic int ecp_mul_comb( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
S                         const mbedtls_mpi *m, const mbedtls_ecp_point *P,
S                         int (*f_rng)(void *, unsigned char *, size_t),
S                         void *p_rng )
S{
S    int ret;
S    unsigned char w, m_is_odd, p_eq_g, pre_len, i;
S    size_t d;
S    unsigned char k[COMB_MAX_D + 1];
S    mbedtls_ecp_point *T;
S    mbedtls_mpi M, mm;
S
S    mbedtls_mpi_init( &M );
S    mbedtls_mpi_init( &mm );
S
S    /* we need N to be odd to trnaform m in an odd number, check now */
S    if( mbedtls_mpi_get_bit( &grp->N, 0 ) != 1 )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    /*
S     * Minimize the number of multiplications, that is minimize
S     * 10 * d * w + 18 * 2^(w-1) + 11 * d + 7 * w, with d = ceil( nbits / w )
S     * (see costs of the various parts, with 1S = 1M)
S     */
S    w = grp->nbits >= 384 ? 5 : 4;
S
S    /*
S     * If P == G, pre-compute a bit more, since this may be re-used later.
S     * Just adding one avoids upping the cost of the first mul too much,
S     * and the memory cost too.
S     */
S#if MBEDTLS_ECP_FIXED_POINT_OPTIM == 1
S    p_eq_g = ( mbedtls_mpi_cmp_mpi( &P->Y, &grp->G.Y ) == 0 &&
S               mbedtls_mpi_cmp_mpi( &P->X, &grp->G.X ) == 0 );
S    if( p_eq_g )
S        w++;
S#else
S    p_eq_g = 0;
S#endif
S
S    /*
S     * Make sure w is within bounds.
S     * (The last test is useful only for very small curves in the test suite.)
S     */
S    if( w > MBEDTLS_ECP_WINDOW_SIZE )
S        w = MBEDTLS_ECP_WINDOW_SIZE;
S    if( w >= grp->nbits )
S        w = 2;
S
S    /* Other sizes that depend on w */
S    pre_len = 1U << ( w - 1 );
S    d = ( grp->nbits + w - 1 ) / w;
S
S    /*
S     * Prepare precomputed points: if P == G we want to
S     * use grp->T if already initialized, or initialize it.
S     */
S    T = p_eq_g ? grp->T : NULL;
S
S    if( T == NULL )
S    {
S        T = mbedtls_calloc( pre_len, sizeof( mbedtls_ecp_point ) );
S        if( T == NULL )
S        {
S            ret = MBEDTLS_ERR_ECP_ALLOC_FAILED;
S            goto cleanup;
S        }
S
S        MBEDTLS_MPI_CHK( ecp_precompute_comb( grp, T, P, w, d ) );
S
S        if( p_eq_g )
S        {
S            grp->T = T;
S            grp->T_size = pre_len;
S        }
S    }
S
S    /*
S     * Make sure M is odd (M = m or M = N - m, since N is odd)
S     * using the fact that m * P = - (N - m) * P
S     */
S    m_is_odd = ( mbedtls_mpi_get_bit( m, 0 ) == 1 );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &M, m ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &mm, &grp->N, m ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_assign( &M, &mm, ! m_is_odd ) );
S
S    /*
S     * Go for comb multiplication, R = M * P
S     */
S    ecp_comb_fixed( k, d, w, &M );
S    MBEDTLS_MPI_CHK( ecp_mul_comb_core( grp, R, T, pre_len, k, d, f_rng, p_rng ) );
S
S    /*
S     * Now get m * P from M * P and normalize it
S     */
S    MBEDTLS_MPI_CHK( ecp_safe_invert_jac( grp, R, ! m_is_odd ) );
S    MBEDTLS_MPI_CHK( ecp_normalize_jac( grp, R ) );
S
Scleanup:
S
S    if( T != NULL && ! p_eq_g )
S    {
S        for( i = 0; i < pre_len; i++ )
S            mbedtls_ecp_point_free( &T[i] );
S        mbedtls_free( T );
S    }
S
S    mbedtls_mpi_free( &M );
S    mbedtls_mpi_free( &mm );
S
S    if( ret != 0 )
S        mbedtls_ecp_point_free( R );
S
S    return( ret );
S}
S
S#endif /* ECP_SHORTWEIERSTRASS */
S
S#if defined(ECP_MONTGOMERY)
S/*
S * For Montgomery curves, we do all the internal arithmetic in projective
S * coordinates. Import/export of points uses only the x coordinates, which is
S * internaly represented as X / Z.
S *
S * For scalar multiplication, we'll use a Montgomery ladder.
S */
S
S/*
S * Normalize Montgomery x/z coordinates: X = X/Z, Z = 1
S * Cost: 1M + 1I
S */
Sstatic int ecp_normalize_mxz( const mbedtls_ecp_group *grp, mbedtls_ecp_point *P )
S{
S    int ret;
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &P->Z, &P->Z, &grp->P ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &P->Z ) ); MOD_MUL( P->X );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &P->Z, 1 ) );
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Randomize projective x/z coordinates:
S * (X, Z) -> (l X, l Z) for random l
S * This is sort of the reverse operation of ecp_normalize_mxz().
S *
S * This countermeasure was first suggested in [2].
S * Cost: 2M
S */
Sstatic int ecp_randomize_mxz( const mbedtls_ecp_group *grp, mbedtls_ecp_point *P,
S                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
S{
S    int ret;
S    mbedtls_mpi l;
S    size_t p_size = ( grp->pbits + 7 ) / 8;
S    int count = 0;
S
S    mbedtls_mpi_init( &l );
S
S    /* Generate l such that 1 < l < p */
S    do
S    {
S        mbedtls_mpi_fill_random( &l, p_size, f_rng, p_rng );
S
S        while( mbedtls_mpi_cmp_mpi( &l, &grp->P ) >= 0 )
S            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &l, 1 ) );
S
S        if( count++ > 10 )
S            return( MBEDTLS_ERR_ECP_RANDOM_FAILED );
S    }
S    while( mbedtls_mpi_cmp_int( &l, 1 ) <= 0 );
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->X, &P->X, &l ) ); MOD_MUL( P->X );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &P->Z, &P->Z, &l ) ); MOD_MUL( P->Z );
S
Scleanup:
S    mbedtls_mpi_free( &l );
S
S    return( ret );
S}
S
S/*
S * Double-and-add: R = 2P, S = P + Q, with d = X(P - Q),
S * for Montgomery curves in x/z coordinates.
S *
S * http://www.hyperelliptic.org/EFD/g1p/auto-code/montgom/xz/ladder/mladd-1987-m.op3
S * with
S * d =  X1
S * P = (X2, Z2)
S * Q = (X3, Z3)
S * R = (X4, Z4)
S * S = (X5, Z5)
S * and eliminating temporary variables tO, ..., t4.
S *
S * Cost: 5M + 4S
S */
Sstatic int ecp_double_add_mxz( const mbedtls_ecp_group *grp,
S                               mbedtls_ecp_point *R, mbedtls_ecp_point *S,
S                               const mbedtls_ecp_point *P, const mbedtls_ecp_point *Q,
S                               const mbedtls_mpi *d )
S{
S    int ret;
S    mbedtls_mpi A, AA, B, BB, E, C, D, DA, CB;
S
S    mbedtls_mpi_init( &A ); mbedtls_mpi_init( &AA ); mbedtls_mpi_init( &B );
S    mbedtls_mpi_init( &BB ); mbedtls_mpi_init( &E ); mbedtls_mpi_init( &C );
S    mbedtls_mpi_init( &D ); mbedtls_mpi_init( &DA ); mbedtls_mpi_init( &CB );
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &A,    &P->X,   &P->Z ) ); MOD_ADD( A    );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &AA,   &A,      &A    ) ); MOD_MUL( AA   );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &B,    &P->X,   &P->Z ) ); MOD_SUB( B    );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &BB,   &B,      &B    ) ); MOD_MUL( BB   );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &E,    &AA,     &BB   ) ); MOD_SUB( E    );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &C,    &Q->X,   &Q->Z ) ); MOD_ADD( C    );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &D,    &Q->X,   &Q->Z ) ); MOD_SUB( D    );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DA,   &D,      &A    ) ); MOD_MUL( DA   );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &CB,   &C,      &B    ) ); MOD_MUL( CB   );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &S->X, &DA,     &CB   ) ); MOD_MUL( S->X );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->X, &S->X,   &S->X ) ); MOD_MUL( S->X );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &S->Z, &DA,     &CB   ) ); MOD_SUB( S->Z );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, &S->Z,   &S->Z ) ); MOD_MUL( S->Z );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &S->Z, d,       &S->Z ) ); MOD_MUL( S->Z );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->X, &AA,     &BB   ) ); MOD_MUL( R->X );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &grp->A, &E    ) ); MOD_MUL( R->Z );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &R->Z, &BB,     &R->Z ) ); MOD_ADD( R->Z );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &R->Z, &E,      &R->Z ) ); MOD_MUL( R->Z );
S
Scleanup:
S    mbedtls_mpi_free( &A ); mbedtls_mpi_free( &AA ); mbedtls_mpi_free( &B );
S    mbedtls_mpi_free( &BB ); mbedtls_mpi_free( &E ); mbedtls_mpi_free( &C );
S    mbedtls_mpi_free( &D ); mbedtls_mpi_free( &DA ); mbedtls_mpi_free( &CB );
S
S    return( ret );
S}
S
S/*
S * Multiplication with Montgomery ladder in x/z coordinates,
S * for curves in Montgomery form
S */
Sstatic int ecp_mul_mxz( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
S                        const mbedtls_mpi *m, const mbedtls_ecp_point *P,
S                        int (*f_rng)(void *, unsigned char *, size_t),
S                        void *p_rng )
S{
S    int ret;
S    size_t i;
S    unsigned char b;
S    mbedtls_ecp_point RP;
S    mbedtls_mpi PX;
S
S    mbedtls_ecp_point_init( &RP ); mbedtls_mpi_init( &PX );
S
S    /* Save PX and read from P before writing to R, in case P == R */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &PX, &P->X ) );
S    MBEDTLS_MPI_CHK( mbedtls_ecp_copy( &RP, P ) );
S
S    /* Set R to zero in modified x/z coordinates */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->X, 1 ) );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &R->Z, 0 ) );
S    mbedtls_mpi_free( &R->Y );
S
S    /* RP.X might be sligtly larger than P, so reduce it */
S    MOD_ADD( RP.X );
S
S    /* Randomize coordinates of the starting point */
S    if( f_rng != NULL )
S        MBEDTLS_MPI_CHK( ecp_randomize_mxz( grp, &RP, f_rng, p_rng ) );
S
S    /* Loop invariant: R = result so far, RP = R + P */
S    i = mbedtls_mpi_bitlen( m ); /* one past the (zero-based) most significant bit */
S    while( i-- > 0 )
S    {
S        b = mbedtls_mpi_get_bit( m, i );
S        /*
S         *  if (b) R = 2R + P else R = 2R,
S         * which is:
S         *  if (b) double_add( RP, R, RP, R )
S         *  else   double_add( R, RP, R, RP )
S         * but using safe conditional swaps to avoid leaks
S         */
S        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->X, &RP.X, b ) );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->Z, &RP.Z, b ) );
S        MBEDTLS_MPI_CHK( ecp_double_add_mxz( grp, R, &RP, R, &RP, &PX ) );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->X, &RP.X, b ) );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_safe_cond_swap( &R->Z, &RP.Z, b ) );
S    }
S
S    MBEDTLS_MPI_CHK( ecp_normalize_mxz( grp, R ) );
S
Scleanup:
S    mbedtls_ecp_point_free( &RP ); mbedtls_mpi_free( &PX );
S
S    return( ret );
S}
S
S#endif /* ECP_MONTGOMERY */
S
S/*
S * Multiplication R = m * P
S */
Sint mbedtls_ecp_mul( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
S             const mbedtls_mpi *m, const mbedtls_ecp_point *P,
S             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
S{
S    int ret;
S
S    /* Common sanity checks */
S    if( mbedtls_mpi_cmp_int( &P->Z, 1 ) != 0 )
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
S    if( ( ret = mbedtls_ecp_check_privkey( grp, m ) ) != 0 ||
S        ( ret = mbedtls_ecp_check_pubkey( grp, P ) ) != 0 )
S        return( ret );
S
S#if defined(ECP_MONTGOMERY)
S    if( ecp_get_type( grp ) == ECP_TYPE_MONTGOMERY )
S        return( ecp_mul_mxz( grp, R, m, P, f_rng, p_rng ) );
S#endif
S#if defined(ECP_SHORTWEIERSTRASS)
S    if( ecp_get_type( grp ) == ECP_TYPE_SHORT_WEIERSTRASS )
S        return( ecp_mul_comb( grp, R, m, P, f_rng, p_rng ) );
S#endif
S    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S}
S
S#if defined(ECP_SHORTWEIERSTRASS)
S/*
S * Check that an affine point is valid as a public key,
S * short weierstrass curves (SEC1 3.2.3.1)
S */
Sstatic int ecp_check_pubkey_sw( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt )
S{
S    int ret;
S    mbedtls_mpi YY, RHS;
S
S    /* pt coordinates must be normalized for our checks */
S    if( mbedtls_mpi_cmp_int( &pt->X, 0 ) < 0 ||
S        mbedtls_mpi_cmp_int( &pt->Y, 0 ) < 0 ||
S        mbedtls_mpi_cmp_mpi( &pt->X, &grp->P ) >= 0 ||
S        mbedtls_mpi_cmp_mpi( &pt->Y, &grp->P ) >= 0 )
S        return( MBEDTLS_ERR_ECP_INVALID_KEY );
S
S    mbedtls_mpi_init( &YY ); mbedtls_mpi_init( &RHS );
S
S    /*
S     * YY = Y^2
S     * RHS = X (X^2 + A) + B = X^3 + A X + B
S     */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &YY,  &pt->Y,   &pt->Y  ) );  MOD_MUL( YY  );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &RHS, &pt->X,   &pt->X  ) );  MOD_MUL( RHS );
S
S    /* Special case for A = -3 */
S    if( grp->A.p == NULL )
S    {
S        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &RHS, &RHS, 3       ) );  MOD_SUB( RHS );
S    }
S    else
S    {
S        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &RHS, &RHS, &grp->A ) );  MOD_ADD( RHS );
S    }
S
S    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &RHS, &RHS,     &pt->X  ) );  MOD_MUL( RHS );
S    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &RHS, &RHS,     &grp->B ) );  MOD_ADD( RHS );
S
S    if( mbedtls_mpi_cmp_mpi( &YY, &RHS ) != 0 )
S        ret = MBEDTLS_ERR_ECP_INVALID_KEY;
S
Scleanup:
S
S    mbedtls_mpi_free( &YY ); mbedtls_mpi_free( &RHS );
S
S    return( ret );
S}
S#endif /* ECP_SHORTWEIERSTRASS */
S
S/*
S * R = m * P with shortcuts for m == 1 and m == -1
S * NOT constant-time - ONLY for short Weierstrass!
S */
Sstatic int mbedtls_ecp_mul_shortcuts( mbedtls_ecp_group *grp,
S                                      mbedtls_ecp_point *R,
S                                      const mbedtls_mpi *m,
S                                      const mbedtls_ecp_point *P )
S{
S    int ret;
S
S    if( mbedtls_mpi_cmp_int( m, 1 ) == 0 )
S    {
S        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );
S    }
S    else if( mbedtls_mpi_cmp_int( m, -1 ) == 0 )
S    {
S        MBEDTLS_MPI_CHK( mbedtls_ecp_copy( R, P ) );
S        if( mbedtls_mpi_cmp_int( &R->Y, 0 ) != 0 )
S            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &R->Y, &grp->P, &R->Y ) );
S    }
S    else
S    {
S        MBEDTLS_MPI_CHK( mbedtls_ecp_mul( grp, R, m, P, NULL, NULL ) );
S    }
S
Scleanup:
S    return( ret );
S}
S
S/*
S * Linear combination
S * NOT constant-time
S */
Sint mbedtls_ecp_muladd( mbedtls_ecp_group *grp, mbedtls_ecp_point *R,
S             const mbedtls_mpi *m, const mbedtls_ecp_point *P,
S             const mbedtls_mpi *n, const mbedtls_ecp_point *Q )
S{
S    int ret;
S    mbedtls_ecp_point mP;
S
S    if( ecp_get_type( grp ) != ECP_TYPE_SHORT_WEIERSTRASS )
S        return( MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE );
S
S    mbedtls_ecp_point_init( &mP );
S
S    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_shortcuts( grp, &mP, m, P ) );
S    MBEDTLS_MPI_CHK( mbedtls_ecp_mul_shortcuts( grp, R,   n, Q ) );
S
S    MBEDTLS_MPI_CHK( ecp_add_mixed( grp, R, &mP, R ) );
S    MBEDTLS_MPI_CHK( ecp_normalize_jac( grp, R ) );
S
Scleanup:
S    mbedtls_ecp_point_free( &mP );
S
S    return( ret );
S}
S
S
S#if defined(ECP_MONTGOMERY)
S/*
S * Check validity of a public key for Montgomery curves with x-only schemes
S */
Sstatic int ecp_check_pubkey_mx( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt )
S{
S    /* [Curve25519 p. 5] Just check X is the correct number of bytes */
S    if( mbedtls_mpi_size( &pt->X ) > ( grp->nbits + 7 ) / 8 )
S        return( MBEDTLS_ERR_ECP_INVALID_KEY );
S
S    return( 0 );
S}
S#endif /* ECP_MONTGOMERY */
S
S/*
S * Check that a point is valid as a public key
S */
Sint mbedtls_ecp_check_pubkey( const mbedtls_ecp_group *grp, const mbedtls_ecp_point *pt )
S{
S    /* Must use affine coordinates */
S    if( mbedtls_mpi_cmp_int( &pt->Z, 1 ) != 0 )
S        return( MBEDTLS_ERR_ECP_INVALID_KEY );
S
S#if defined(ECP_MONTGOMERY)
S    if( ecp_get_type( grp ) == ECP_TYPE_MONTGOMERY )
S        return( ecp_check_pubkey_mx( grp, pt ) );
S#endif
S#if defined(ECP_SHORTWEIERSTRASS)
S    if( ecp_get_type( grp ) == ECP_TYPE_SHORT_WEIERSTRASS )
S        return( ecp_check_pubkey_sw( grp, pt ) );
S#endif
S    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S}
S
S/*
S * Check that an mbedtls_mpi is valid as a private key
S */
Sint mbedtls_ecp_check_privkey( const mbedtls_ecp_group *grp, const mbedtls_mpi *d )
S{
S#if defined(ECP_MONTGOMERY)
S    if( ecp_get_type( grp ) == ECP_TYPE_MONTGOMERY )
S    {
S        /* see [Curve25519] page 5 */
S        if( mbedtls_mpi_get_bit( d, 0 ) != 0 ||
S            mbedtls_mpi_get_bit( d, 1 ) != 0 ||
S            mbedtls_mpi_get_bit( d, 2 ) != 0 ||
S            mbedtls_mpi_bitlen( d ) - 1 != grp->nbits ) /* mbedtls_mpi_bitlen is one-based! */
S            return( MBEDTLS_ERR_ECP_INVALID_KEY );
S        else
S            return( 0 );
S    }
S#endif /* ECP_MONTGOMERY */
S#if defined(ECP_SHORTWEIERSTRASS)
S    if( ecp_get_type( grp ) == ECP_TYPE_SHORT_WEIERSTRASS )
S    {
S        /* see SEC1 3.2 */
S        if( mbedtls_mpi_cmp_int( d, 1 ) < 0 ||
S            mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 )
S            return( MBEDTLS_ERR_ECP_INVALID_KEY );
S        else
S            return( 0 );
S    }
S#endif /* ECP_SHORTWEIERSTRASS */
S
S    return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S}
S
S/*
S * Generate a keypair with configurable base point
S */
Sint mbedtls_ecp_gen_keypair_base( mbedtls_ecp_group *grp,
S                     const mbedtls_ecp_point *G,
S                     mbedtls_mpi *d, mbedtls_ecp_point *Q,
S                     int (*f_rng)(void *, unsigned char *, size_t),
S                     void *p_rng )
S{
S    int ret;
S    size_t n_size = ( grp->nbits + 7 ) / 8;
S
S#if defined(ECP_MONTGOMERY)
S    if( ecp_get_type( grp ) == ECP_TYPE_MONTGOMERY )
S    {
S        /* [M225] page 5 */
S        size_t b;
S
S        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( d, n_size, f_rng, p_rng ) );
S
S        /* Make sure the most significant bit is nbits */
S        b = mbedtls_mpi_bitlen( d ) - 1; /* mbedtls_mpi_bitlen is one-based */
S        if( b > grp->nbits )
S            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, b - grp->nbits ) );
S        else
S            MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, grp->nbits, 1 ) );
S
S        /* Make sure the last three bits are unset */
S        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 0, 0 ) );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 1, 0 ) );
S        MBEDTLS_MPI_CHK( mbedtls_mpi_set_bit( d, 2, 0 ) );
S    }
S    else
S#endif /* ECP_MONTGOMERY */
S#if defined(ECP_SHORTWEIERSTRASS)
S    if( ecp_get_type( grp ) == ECP_TYPE_SHORT_WEIERSTRASS )
S    {
S        /* SEC1 3.2.1: Generate d such that 1 <= n < N */
S        int count = 0;
S        unsigned char rnd[MBEDTLS_ECP_MAX_BYTES];
S
S        /*
S         * Match the procedure given in RFC 6979 (deterministic ECDSA):
S         * - use the same byte ordering;
S         * - keep the leftmost nbits bits of the generated octet string;
S         * - try until result is in the desired range.
S         * This also avoids any biais, which is especially important for ECDSA.
S         */
S        do
S        {
S            MBEDTLS_MPI_CHK( f_rng( p_rng, rnd, n_size ) );
S            MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( d, rnd, n_size ) );
S            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( d, 8 * n_size - grp->nbits ) );
S
S            /*
S             * Each try has at worst a probability 1/2 of failing (the msb has
S             * a probability 1/2 of being 0, and then the result will be < N),
S             * so after 30 tries failure probability is a most 2**(-30).
S             *
S             * For most curves, 1 try is enough with overwhelming probability,
S             * since N starts with a lot of 1s in binary, but some curves
S             * such as secp224k1 are actually very close to the worst case.
S             */
S            if( ++count > 30 )
S                return( MBEDTLS_ERR_ECP_RANDOM_FAILED );
S        }
S        while( mbedtls_mpi_cmp_int( d, 1 ) < 0 ||
S               mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 );
S    }
S    else
S#endif /* ECP_SHORTWEIERSTRASS */
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S
Scleanup:
S    if( ret != 0 )
S        return( ret );
S
S    return( mbedtls_ecp_mul( grp, Q, d, G, f_rng, p_rng ) );
S}
S
S/*
S * Generate key pair, wrapper for conventional base point
S */
Sint mbedtls_ecp_gen_keypair( mbedtls_ecp_group *grp,
S                             mbedtls_mpi *d, mbedtls_ecp_point *Q,
S                             int (*f_rng)(void *, unsigned char *, size_t),
S                             void *p_rng )
S{
S    return( mbedtls_ecp_gen_keypair_base( grp, &grp->G, d, Q, f_rng, p_rng ) );
S}
S
S/*
S * Generate a keypair, prettier wrapper
S */
Sint mbedtls_ecp_gen_key( mbedtls_ecp_group_id grp_id, mbedtls_ecp_keypair *key,
S                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
S{
S    int ret;
S
S    if( ( ret = mbedtls_ecp_group_load( &key->grp, grp_id ) ) != 0 )
S        return( ret );
S
S    return( mbedtls_ecp_gen_keypair( &key->grp, &key->d, &key->Q, f_rng, p_rng ) );
S}
S
S/*
S * Check a public-private key pair
S */
Sint mbedtls_ecp_check_pub_priv( const mbedtls_ecp_keypair *pub, const mbedtls_ecp_keypair *prv )
S{
S    int ret;
S    mbedtls_ecp_point Q;
S    mbedtls_ecp_group grp;
S
S    if( pub->grp.id == MBEDTLS_ECP_DP_NONE ||
S        pub->grp.id != prv->grp.id ||
S        mbedtls_mpi_cmp_mpi( &pub->Q.X, &prv->Q.X ) ||
S        mbedtls_mpi_cmp_mpi( &pub->Q.Y, &prv->Q.Y ) ||
S        mbedtls_mpi_cmp_mpi( &pub->Q.Z, &prv->Q.Z ) )
S    {
S        return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
S    }
S
S    mbedtls_ecp_point_init( &Q );
S    mbedtls_ecp_group_init( &grp );
S
S    /* mbedtls_ecp_mul() needs a non-const group... */
S    mbedtls_ecp_group_copy( &grp, &prv->grp );
S
S    /* Also checks d is valid */
S    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &Q, &prv->d, &prv->grp.G, NULL, NULL ) );
S
S    if( mbedtls_mpi_cmp_mpi( &Q.X, &prv->Q.X ) ||
S        mbedtls_mpi_cmp_mpi( &Q.Y, &prv->Q.Y ) ||
S        mbedtls_mpi_cmp_mpi( &Q.Z, &prv->Q.Z ) )
S    {
S        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
S        goto cleanup;
S    }
S
Scleanup:
S    mbedtls_ecp_point_free( &Q );
S    mbedtls_ecp_group_free( &grp );
S
S    return( ret );
S}
S
S#if defined(MBEDTLS_SELF_TEST)
S
S/*
S * Checkup routine
S */
Sint mbedtls_ecp_self_test( int verbose )
S{
S    int ret;
S    size_t i;
S    mbedtls_ecp_group grp;
S    mbedtls_ecp_point R, P;
S    mbedtls_mpi m;
S    unsigned long add_c_prev, dbl_c_prev, mul_c_prev;
S    /* exponents especially adapted for secp192r1 */
S    const char *exponents[] =
S    {
S        "000000000000000000000000000000000000000000000001", /* one */
S        "FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22830", /* N - 1 */
S        "5EA6F389A38B8BC81E767753B15AA5569E1782E30ABE7D25", /* random */
S        "400000000000000000000000000000000000000000000000", /* one and zeros */
S        "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", /* all ones */
S        "555555555555555555555555555555555555555555555555", /* 101010... */
S    };
S
S    mbedtls_ecp_group_init( &grp );
S    mbedtls_ecp_point_init( &R );
S    mbedtls_ecp_point_init( &P );
S    mbedtls_mpi_init( &m );
S
S    /* Use secp192r1 if available, or any available curve */
S#if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
S    MBEDTLS_MPI_CHK( mbedtls_ecp_group_load( &grp, MBEDTLS_ECP_DP_SECP192R1 ) );
S#else
S    MBEDTLS_MPI_CHK( mbedtls_ecp_group_load( &grp, mbedtls_ecp_curve_list()->grp_id ) );
S#endif
S
S    if( verbose != 0 )
S        mbedtls_printf( "  ECP test #1 (constant op_count, base point G): " );
S
S    /* Do a dummy multiplication first to trigger precomputation */
S    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &m, 2 ) );
S    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &P, &m, &grp.G, NULL, NULL ) );
S
S    add_count = 0;
S    dbl_count = 0;
S    mul_count = 0;
S    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &m, 16, exponents[0] ) );
S    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &R, &m, &grp.G, NULL, NULL ) );
S
S    for( i = 1; i < sizeof( exponents ) / sizeof( exponents[0] ); i++ )
S    {
S        add_c_prev = add_count;
S        dbl_c_prev = dbl_count;
S        mul_c_prev = mul_count;
S        add_count = 0;
S        dbl_count = 0;
S        mul_count = 0;
S
S        MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &m, 16, exponents[i] ) );
S        MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &R, &m, &grp.G, NULL, NULL ) );
S
S        if( add_count != add_c_prev ||
S            dbl_count != dbl_c_prev ||
S            mul_count != mul_c_prev )
S        {
S            if( verbose != 0 )
S                mbedtls_printf( "failed (%u)\n", (unsigned int) i );
S
S            ret = 1;
S            goto cleanup;
S        }
S    }
S
S    if( verbose != 0 )
S        mbedtls_printf( "passed\n" );
S
S    if( verbose != 0 )
S        mbedtls_printf( "  ECP test #2 (constant op_count, other point): " );
S    /* We computed P = 2G last time, use it */
S
S    add_count = 0;
S    dbl_count = 0;
S    mul_count = 0;
S    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &m, 16, exponents[0] ) );
S    MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &R, &m, &P, NULL, NULL ) );
S
S    for( i = 1; i < sizeof( exponents ) / sizeof( exponents[0] ); i++ )
S    {
S        add_c_prev = add_count;
S        dbl_c_prev = dbl_count;
S        mul_c_prev = mul_count;
S        add_count = 0;
S        dbl_count = 0;
S        mul_count = 0;
S
S        MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &m, 16, exponents[i] ) );
S        MBEDTLS_MPI_CHK( mbedtls_ecp_mul( &grp, &R, &m, &P, NULL, NULL ) );
S
S        if( add_count != add_c_prev ||
S            dbl_count != dbl_c_prev ||
S            mul_count != mul_c_prev )
S        {
S            if( verbose != 0 )
S                mbedtls_printf( "failed (%u)\n", (unsigned int) i );
S
S            ret = 1;
S            goto cleanup;
S        }
S    }
S
S    if( verbose != 0 )
S        mbedtls_printf( "passed\n" );
S
Scleanup:
S
S    if( ret < 0 && verbose != 0 )
S        mbedtls_printf( "Unexpected error, return code = %08X\n", ret );
S
S    mbedtls_ecp_group_free( &grp );
S    mbedtls_ecp_point_free( &R );
S    mbedtls_ecp_point_free( &P );
S    mbedtls_mpi_free( &m );
S
S    if( verbose != 0 )
S        mbedtls_printf( "\n" );
S
S    return( ret );
S}
S
S#endif /* MBEDTLS_SELF_TEST */
S
N#endif /* MBEDTLS_ECP_C */
