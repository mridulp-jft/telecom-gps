; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\uif.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\uif.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -I..\..\..\..\inc -I..\vts_ver3_rev1 -I.\RTE\_KL26Z128_-_Flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.13.0\Device\Include -D__UVISION_VERSION=524 -D_RTE_ -DMKL26Z256xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\uif.crf ..\..\..\src\common\uif.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  get_line PROC
;;;46     char *
;;;47     get_line (char *line)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {
000002  4606              MOV      r6,r0
;;;49         int pos;
;;;50         int ch;
;;;51     
;;;52         pos = 0;
000004  2500              MOVS     r5,#0
;;;53         ch = (int)in_char();
000006  f7fffffe          BL       in_char
00000a  4604              MOV      r4,r0
;;;54         while ( (ch != 0x0D /* CR */) &&
00000c  e024              B        |L1.88|
                  |L1.14|
;;;55                 (ch != 0x0A /* LF/NL */) &&
;;;56                 (pos < UIF_MAX_LINE))
;;;57         {
;;;58             switch (ch)
00000e  2c08              CMP      r4,#8
000010  d002              BEQ      |L1.24|
000012  2c7f              CMP      r4,#0x7f
000014  d10e              BNE      |L1.52|
000016  e000              B        |L1.26|
                  |L1.24|
;;;59             {
;;;60                 case 0x08:      /* Backspace */
;;;61                 case 0x7F:      /* Delete */
000018  bf00              NOP      
                  |L1.26|
;;;62                     if (pos > 0)
00001a  2d00              CMP      r5,#0
00001c  dd09              BLE      |L1.50|
;;;63                     {
;;;64                         pos -= 1;
00001e  1e6d              SUBS     r5,r5,#1
;;;65                         out_char(0x08);    /* backspace */
000020  2008              MOVS     r0,#8
000022  f7fffffe          BL       out_char
;;;66                         out_char(' ');
000026  2020              MOVS     r0,#0x20
000028  f7fffffe          BL       out_char
;;;67                         out_char(0x08);    /* backspace */
00002c  2008              MOVS     r0,#8
00002e  f7fffffe          BL       out_char
                  |L1.50|
;;;68                     }
;;;69                     break;
000032  e00d              B        |L1.80|
                  |L1.52|
;;;70                 default:
;;;71                     if ((pos+1) < UIF_MAX_LINE)
000034  1c68              ADDS     r0,r5,#1
000036  2850              CMP      r0,#0x50
000038  da09              BGE      |L1.78|
;;;72                     {
;;;73                         if ((ch > 0x1f) && (ch < 0x80))
00003a  2c1f              CMP      r4,#0x1f
00003c  dd07              BLE      |L1.78|
00003e  2c80              CMP      r4,#0x80
000040  da05              BGE      |L1.78|
;;;74                         {
;;;75                             line[pos++] = (char)ch;
000042  4628              MOV      r0,r5
000044  1c6d              ADDS     r5,r5,#1
000046  5434              STRB     r4,[r6,r0]
;;;76                             out_char((char)ch);
000048  b2e0              UXTB     r0,r4
00004a  f7fffffe          BL       out_char
                  |L1.78|
;;;77                         }
;;;78                     }
;;;79                     break;
00004e  bf00              NOP      
                  |L1.80|
000050  bf00              NOP                            ;69
;;;80             }
;;;81             ch = (int)in_char();
000052  f7fffffe          BL       in_char
000056  4604              MOV      r4,r0
                  |L1.88|
000058  2c0d              CMP      r4,#0xd               ;54
00005a  d003              BEQ      |L1.100|
00005c  2c0a              CMP      r4,#0xa               ;55
00005e  d001              BEQ      |L1.100|
000060  2d50              CMP      r5,#0x50              ;56
000062  dbd4              BLT      |L1.14|
                  |L1.100|
;;;82         }
;;;83         line[pos] = '\0';
000064  2000              MOVS     r0,#0
000066  5570              STRB     r0,[r6,r5]
;;;84         out_char(0x0D);    /* CR */
000068  200d              MOVS     r0,#0xd
00006a  f7fffffe          BL       out_char
;;;85         out_char(0x0A);    /* LF */
00006e  200a              MOVS     r0,#0xa
000070  f7fffffe          BL       out_char
;;;86     
;;;87         return line;
000074  4630              MOV      r0,r6
;;;88     }
000076  bd70              POP      {r4-r6,pc}
;;;89     
                          ENDP

                  make_argv PROC
;;;91     int
;;;92     make_argv (char *cmdline, char *argv[])
000078  b570              PUSH     {r4-r6,lr}
;;;93     {
00007a  4602              MOV      r2,r0
00007c  460b              MOV      r3,r1
;;;94         int argc, i, in_text;
;;;95     
;;;96         /* 
;;;97          * Break cmdline into strings and argv
;;;98          * It is permissible for argv to be NULL, in which case
;;;99          * the purpose of this routine becomes to count args
;;;100         */
;;;101        argc = 0;
00007e  2000              MOVS     r0,#0
;;;102        i = 0;
000080  2100              MOVS     r1,#0
;;;103        in_text = FALSE;
000082  2400              MOVS     r4,#0
;;;104        while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
000084  e019              B        |L1.186|
                  |L1.134|
;;;105        {
;;;106            if (((cmdline[i] == ' ')   ||
000086  5c55              LDRB     r5,[r2,r1]
000088  2d20              CMP      r5,#0x20
00008a  d002              BEQ      |L1.146|
;;;107                 (cmdline[i] == '\t')) )
00008c  5c55              LDRB     r5,[r2,r1]
00008e  2d09              CMP      r5,#9
000090  d105              BNE      |L1.158|
                  |L1.146|
;;;108            {
;;;109                if (in_text)
000092  2c00              CMP      r4,#0
000094  d010              BEQ      |L1.184|
;;;110                {
;;;111                    /* end of command line argument */
;;;112                    cmdline[i] = '\0';
000096  2500              MOVS     r5,#0
000098  5455              STRB     r5,[r2,r1]
;;;113                    in_text = FALSE;
00009a  2400              MOVS     r4,#0
00009c  e00c              B        |L1.184|
                  |L1.158|
;;;114                }
;;;115                else
;;;116                {
;;;117                    /* still looking for next argument */
;;;118                    
;;;119                }
;;;120            }
;;;121            else
;;;122            {
;;;123                /* got non-whitespace character */
;;;124                if (in_text)
00009e  2c00              CMP      r4,#0
0000a0  d10a              BNE      |L1.184|
;;;125                {
;;;126                }
;;;127                else
;;;128                {
;;;129                    /* start of an argument */
;;;130                    in_text = TRUE;
0000a2  2401              MOVS     r4,#1
;;;131                    if (argc < UIF_MAX_ARGS)
0000a4  280a              CMP      r0,#0xa
0000a6  da06              BGE      |L1.182|
;;;132                    {
;;;133                        if (argv != NULL)
0000a8  2b00              CMP      r3,#0
0000aa  d002              BEQ      |L1.178|
;;;134                            argv[argc] = &cmdline[i];
0000ac  1855              ADDS     r5,r2,r1
0000ae  0086              LSLS     r6,r0,#2
0000b0  519d              STR      r5,[r3,r6]
                  |L1.178|
;;;135                        argc++;
0000b2  1c40              ADDS     r0,r0,#1
0000b4  e000              B        |L1.184|
                  |L1.182|
;;;136                    }
;;;137                    else
;;;138                        /*return argc;*/
;;;139                        break;
0000b6  e003              B        |L1.192|
                  |L1.184|
;;;140                }
;;;141    
;;;142            }
;;;143            i++;    /* proceed to next character */
0000b8  1c49              ADDS     r1,r1,#1
                  |L1.186|
0000ba  5c55              LDRB     r5,[r2,r1]            ;104
0000bc  2d00              CMP      r5,#0                 ;104
0000be  d1e2              BNE      |L1.134|
                  |L1.192|
0000c0  bf00              NOP                            ;139
;;;144        }
;;;145        if (argv != NULL)
0000c2  2b00              CMP      r3,#0
0000c4  d002              BEQ      |L1.204|
;;;146            argv[argc] = NULL;
0000c6  2500              MOVS     r5,#0
0000c8  0086              LSLS     r6,r0,#2
0000ca  519d              STR      r5,[r3,r6]
                  |L1.204|
;;;147        return argc;
;;;148    }
0000cc  bd70              POP      {r4-r6,pc}
;;;149    
                          ENDP

                  run_cmd PROC
;;;151    void
;;;152    run_cmd (void)
0000ce  b530              PUSH     {r4,r5,lr}
;;;153    {
0000d0  b08b              SUB      sp,sp,#0x2c
;;;154        /*
;;;155         * Global array of pointers to emulate C argc,argv interface
;;;156         */
;;;157        int argc;
;;;158        char *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
;;;159    
;;;160        get_line(cmdline1);
0000d2  48ab              LDR      r0,|L1.896|
0000d4  f7fffffe          BL       get_line
;;;161    	
;;;162    	  argc = make_argv(cmdline1,argv);
0000d8  4669              MOV      r1,sp
0000da  48a9              LDR      r0,|L1.896|
0000dc  f7fffffe          BL       make_argv
0000e0  4605              MOV      r5,r0
;;;163    
;;;164        if (!(argc))
0000e2  2d00              CMP      r5,#0
0000e4  d108              BNE      |L1.248|
;;;165        {
;;;166            /* no command entered, just a blank line */
;;;167            strcpy(cmdline1,cmdline2);
0000e6  49a7              LDR      r1,|L1.900|
0000e8  48a5              LDR      r0,|L1.896|
0000ea  f7fffffe          BL       strcpy
;;;168            argc = make_argv(cmdline1,argv);
0000ee  4669              MOV      r1,sp
0000f0  48a3              LDR      r0,|L1.896|
0000f2  f7fffffe          BL       make_argv
0000f6  4605              MOV      r5,r0
                  |L1.248|
;;;169        }
;;;170        cmdline2[0] = '\0';
0000f8  2000              MOVS     r0,#0
0000fa  49a2              LDR      r1,|L1.900|
0000fc  7008              STRB     r0,[r1,#0]
;;;171    
;;;172        if (argc)
0000fe  2d00              CMP      r5,#0
000100  d041              BEQ      |L1.390|
;;;173        {
;;;174            int i;
;;;175            for (i = 0; i < UIF_NUM_CMD; i++)
000102  2400              MOVS     r4,#0
000104  e033              B        |L1.366|
                  |L1.262|
;;;176            {
;;;177                if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
000106  221c              MOVS     r2,#0x1c
000108  4362              MULS     r2,r4,r2
00010a  4b9f              LDR      r3,|L1.904|
00010c  5898              LDR      r0,[r3,r2]
00010e  9900              LDR      r1,[sp,#0]
000110  f7fffffe          BL       strcasecmp
000114  2800              CMP      r0,#0
000116  d129              BNE      |L1.364|
;;;178                {
;;;179                    if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
000118  1e68              SUBS     r0,r5,#1
00011a  211c              MOVS     r1,#0x1c
00011c  4361              MULS     r1,r4,r1
00011e  4a9a              LDR      r2,|L1.904|
000120  1889              ADDS     r1,r1,r2
000122  6849              LDR      r1,[r1,#4]
000124  4288              CMP      r0,r1
000126  db1c              BLT      |L1.354|
;;;180                        ((argc-1) <= UIF_CMDTAB[i].max_args))
000128  211c              MOVS     r1,#0x1c
00012a  4361              MULS     r1,r4,r1
00012c  1889              ADDS     r1,r1,r2
00012e  6889              LDR      r1,[r1,#8]
000130  4288              CMP      r0,r1
000132  dc16              BGT      |L1.354|
;;;181                    {
;;;182                        if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
000134  201c              MOVS     r0,#0x1c
000136  4360              MULS     r0,r4,r0
000138  4611              MOV      r1,r2
00013a  1840              ADDS     r0,r0,r1
00013c  7b00              LDRB     r0,[r0,#0xc]
00013e  07c0              LSLS     r0,r0,#31
000140  0fc0              LSRS     r0,r0,#31
000142  2800              CMP      r0,#0
000144  d003              BEQ      |L1.334|
;;;183                        {
;;;184                            strcpy(cmdline2,argv[0]);
000146  488f              LDR      r0,|L1.900|
000148  9900              LDR      r1,[sp,#0]
00014a  f7fffffe          BL       strcpy
                  |L1.334|
;;;185                        }
;;;186                        UIF_CMDTAB[i].func(argc,argv);
00014e  201c              MOVS     r0,#0x1c
000150  4360              MULS     r0,r4,r0
000152  498d              LDR      r1,|L1.904|
000154  1840              ADDS     r0,r0,r1
000156  4669              MOV      r1,sp
000158  6902              LDR      r2,[r0,#0x10]
00015a  4628              MOV      r0,r5
00015c  4790              BLX      r2
                  |L1.350|
;;;187                        return;
;;;188                    }
;;;189                    else
;;;190                    {
;;;191                        printf(SYNTAX,argv[0]);
;;;192                        return;
;;;193                    }
;;;194                }
;;;195            }
;;;196            printf(INVCMD,argv[0]);
;;;197            printf(HELPMSG);
;;;198        }
;;;199    }
00015e  b00b              ADD      sp,sp,#0x2c
000160  bd30              POP      {r4,r5,pc}
                  |L1.354|
000162  488a              LDR      r0,|L1.908|
000164  9900              LDR      r1,[sp,#0]            ;191
000166  f7fffffe          BL       __2printf
00016a  e7f8              B        |L1.350|
                  |L1.364|
00016c  1c64              ADDS     r4,r4,#1              ;175
                  |L1.366|
00016e  4888              LDR      r0,|L1.912|
000170  6800              LDR      r0,[r0,#0]            ;175  ; UIF_NUM_CMD
000172  4284              CMP      r4,r0                 ;175
000174  dbc7              BLT      |L1.262|
000176  4887              LDR      r0,|L1.916|
000178  9900              LDR      r1,[sp,#0]            ;196
00017a  f7fffffe          BL       __2printf
00017e  4886              LDR      r0,|L1.920|
000180  f7fffffe          BL       __2printf
000184  bf00              NOP                            ;198
                  |L1.390|
000186  bf00              NOP      
000188  e7e9              B        |L1.350|
;;;200    /********************************************************************/
                          ENDP

                  get_value PROC
;;;201    uint32
;;;202    get_value (char *s, int *success, int base)
00018a  b5f8              PUSH     {r3-r7,lr}
;;;203    {
00018c  4605              MOV      r5,r0
00018e  460c              MOV      r4,r1
000190  4617              MOV      r7,r2
;;;204        uint32 value;
;;;205        char *p;
;;;206    
;;;207        value = strtoul(s,&p,base);
000192  463a              MOV      r2,r7
000194  4669              MOV      r1,sp
000196  4628              MOV      r0,r5
000198  f7fffffe          BL       strtoul
00019c  4606              MOV      r6,r0
;;;208        if ((value == 0) && (p == s))
00019e  2e00              CMP      r6,#0
0001a0  d105              BNE      |L1.430|
0001a2  9800              LDR      r0,[sp,#0]
0001a4  42a8              CMP      r0,r5
0001a6  d102              BNE      |L1.430|
;;;209        {
;;;210            *success = FALSE;
0001a8  2000              MOVS     r0,#0
0001aa  6020              STR      r0,[r4,#0]
                  |L1.428|
;;;211            return 0;
;;;212        }
;;;213        else
;;;214        {
;;;215            *success = TRUE;
;;;216            return value;
;;;217        }
;;;218    }
0001ac  bdf8              POP      {r3-r7,pc}
                  |L1.430|
0001ae  2001              MOVS     r0,#1                 ;215
0001b0  6020              STR      r0,[r4,#0]            ;215
0001b2  4630              MOV      r0,r6                 ;216
0001b4  e7fa              B        |L1.428|
;;;219    /********************************************************************/
                          ENDP

                  uif_cmd_help PROC
;;;220    void
;;;221    uif_cmd_help (int argc, char **argv)
0001b6  b5f8              PUSH     {r3-r7,lr}
;;;222    {
0001b8  4605              MOV      r5,r0
0001ba  460e              MOV      r6,r1
;;;223        int index;
;;;224        
;;;225        (void)argc;
;;;226        (void)argv;
;;;227        
;;;228        printf("\n");
0001bc  a077              ADR      r0,|L1.924|
0001be  f7fffffe          BL       __2printf
;;;229        for (index = 0; index < UIF_NUM_CMD; index++)
0001c2  2400              MOVS     r4,#0
0001c4  e014              B        |L1.496|
                  |L1.454|
;;;230        {
;;;231            printf(HELPFORMAT,
0001c6  201c              MOVS     r0,#0x1c
0001c8  4360              MULS     r0,r4,r0
0001ca  496f              LDR      r1,|L1.904|
0001cc  1840              ADDS     r0,r0,r1
0001ce  6980              LDR      r0,[r0,#0x18]
0001d0  9000              STR      r0,[sp,#0]
0001d2  201c              MOVS     r0,#0x1c
0001d4  4360              MULS     r0,r4,r0
0001d6  460f              MOV      r7,r1
0001d8  583b              LDR      r3,[r7,r0]
0001da  201c              MOVS     r0,#0x1c
0001dc  4360              MULS     r0,r4,r0
0001de  19c0              ADDS     r0,r0,r7
0001e0  6942              LDR      r2,[r0,#0x14]
0001e2  201c              MOVS     r0,#0x1c
0001e4  4360              MULS     r0,r4,r0
0001e6  5839              LDR      r1,[r7,r0]
0001e8  486d              LDR      r0,|L1.928|
0001ea  f7fffffe          BL       __2printf
0001ee  1c64              ADDS     r4,r4,#1              ;229
                  |L1.496|
0001f0  4867              LDR      r0,|L1.912|
0001f2  6800              LDR      r0,[r0,#0]            ;229  ; UIF_NUM_CMD
0001f4  4284              CMP      r4,r0                 ;229
0001f6  dbe6              BLT      |L1.454|
;;;232                UIF_CMDTAB[index].cmd,
;;;233                UIF_CMDTAB[index].description,
;;;234                UIF_CMDTAB[index].cmd,
;;;235                UIF_CMDTAB[index].syntax);
;;;236        }
;;;237        printf("\n");
0001f8  a068              ADR      r0,|L1.924|
0001fa  f7fffffe          BL       __2printf
;;;238    }
0001fe  bdf8              POP      {r3-r7,pc}
;;;239    /********************************************************************/
                          ENDP

                  uif_cmd_set PROC
;;;240    void
;;;241    uif_cmd_set (int argc, char **argv)
000200  b570              PUSH     {r4-r6,lr}
;;;242    {
000202  4605              MOV      r5,r0
000204  460e              MOV      r6,r1
;;;243        int index;
;;;244    
;;;245        printf("\n");
000206  a065              ADR      r0,|L1.924|
000208  f7fffffe          BL       __2printf
;;;246        if (argc == 1)
00020c  2d01              CMP      r5,#1
00020e  d11c              BNE      |L1.586|
;;;247        {
;;;248            printf("Valid 'set' options:\n");
000210  a064              ADR      r0,|L1.932|
000212  f7fffffe          BL       __2printf
;;;249            for (index = 0; index < UIF_NUM_SETCMD; ++index)
000216  2400              MOVS     r4,#0
000218  e00f              B        |L1.570|
                  |L1.538|
;;;250            {
;;;251                printf(OPTFMT,UIF_SETCMDTAB[index].option);
00021a  2014              MOVS     r0,#0x14
00021c  4360              MULS     r0,r4,r0
00021e  4a67              LDR      r2,|L1.956|
000220  5811              LDR      r1,[r2,r0]
000222  4867              LDR      r0,|L1.960|
000224  f7fffffe          BL       __2printf
;;;252                printf("%s\n",UIF_SETCMDTAB[index].syntax);
000228  2014              MOVS     r0,#0x14
00022a  4360              MULS     r0,r4,r0
00022c  4a63              LDR      r2,|L1.956|
00022e  1880              ADDS     r0,r0,r2
000230  6901              LDR      r1,[r0,#0x10]
000232  a064              ADR      r0,|L1.964|
000234  f7fffffe          BL       __2printf
000238  1c64              ADDS     r4,r4,#1              ;249
                  |L1.570|
00023a  4863              LDR      r0,|L1.968|
00023c  6800              LDR      r0,[r0,#0]            ;249  ; UIF_NUM_SETCMD
00023e  4284              CMP      r4,r0                 ;249
000240  dbeb              BLT      |L1.538|
;;;253            }
;;;254            printf("\n");
000242  a056              ADR      r0,|L1.924|
000244  f7fffffe          BL       __2printf
                  |L1.584|
;;;255            return;
;;;256        }
;;;257    
;;;258        if (argc != 3)
;;;259        {
;;;260            printf("Error: Invalid argument list\n");
;;;261            return;
;;;262        }
;;;263    
;;;264        for (index = 0; index < UIF_NUM_SETCMD; index++)
;;;265        {
;;;266            if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
;;;267            {
;;;268                if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
;;;269                    ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
;;;270                {
;;;271                    UIF_SETCMDTAB[index].func(argc,argv);
;;;272                    return;
;;;273                }
;;;274                else
;;;275                {
;;;276                    printf(INVARG,argv[1]);
;;;277                    return;
;;;278                }
;;;279            }
;;;280        }
;;;281        printf(INVOPT,argv[1]);
;;;282    }
000248  bd70              POP      {r4-r6,pc}
                  |L1.586|
00024a  2d03              CMP      r5,#3                 ;258
00024c  d003              BEQ      |L1.598|
00024e  a05f              ADR      r0,|L1.972|
000250  f7fffffe          BL       __2printf
000254  e7f8              B        |L1.584|
                  |L1.598|
000256  2400              MOVS     r4,#0                 ;264
000258  e025              B        |L1.678|
                  |L1.602|
00025a  2214              MOVS     r2,#0x14              ;266
00025c  4362              MULS     r2,r4,r2              ;266
00025e  4b57              LDR      r3,|L1.956|
000260  5898              LDR      r0,[r3,r2]            ;266
000262  6871              LDR      r1,[r6,#4]            ;266
000264  f7fffffe          BL       strcasecmp
000268  2800              CMP      r0,#0                 ;266
00026a  d11b              BNE      |L1.676|
00026c  1ea8              SUBS     r0,r5,#2              ;268
00026e  2114              MOVS     r1,#0x14              ;268
000270  4361              MULS     r1,r4,r1              ;268
000272  4a52              LDR      r2,|L1.956|
000274  1889              ADDS     r1,r1,r2              ;268
000276  6849              LDR      r1,[r1,#4]            ;268
000278  4288              CMP      r0,r1                 ;268
00027a  db0e              BLT      |L1.666|
00027c  2114              MOVS     r1,#0x14              ;269
00027e  4361              MULS     r1,r4,r1              ;269
000280  1889              ADDS     r1,r1,r2              ;269
000282  6889              LDR      r1,[r1,#8]            ;269
000284  4288              CMP      r0,r1                 ;269
000286  dc08              BGT      |L1.666|
000288  2014              MOVS     r0,#0x14              ;271
00028a  4360              MULS     r0,r4,r0              ;271
00028c  4611              MOV      r1,r2                 ;271
00028e  1840              ADDS     r0,r0,r1              ;271
000290  4631              MOV      r1,r6                 ;271
000292  68c2              LDR      r2,[r0,#0xc]          ;271
000294  4628              MOV      r0,r5                 ;271
000296  4790              BLX      r2                    ;271
000298  e7d6              B        |L1.584|
                  |L1.666|
00029a  4854              LDR      r0,|L1.1004|
00029c  6871              LDR      r1,[r6,#4]            ;276
00029e  f7fffffe          BL       __2printf
0002a2  e7d1              B        |L1.584|
                  |L1.676|
0002a4  1c64              ADDS     r4,r4,#1              ;264
                  |L1.678|
0002a6  4848              LDR      r0,|L1.968|
0002a8  6800              LDR      r0,[r0,#0]            ;264  ; UIF_NUM_SETCMD
0002aa  4284              CMP      r4,r0                 ;264
0002ac  dbd5              BLT      |L1.602|
0002ae  4850              LDR      r0,|L1.1008|
0002b0  6871              LDR      r1,[r6,#4]            ;281
0002b2  f7fffffe          BL       __2printf
0002b6  bf00              NOP      
0002b8  e7c6              B        |L1.584|
;;;283    
                          ENDP

                  uif_cmd_show PROC
;;;285    void
;;;286    uif_cmd_show (int argc, char **argv)
0002ba  b570              PUSH     {r4-r6,lr}
;;;287    {
0002bc  4606              MOV      r6,r0
0002be  460d              MOV      r5,r1
;;;288        int index;
;;;289    
;;;290        printf("\n");
0002c0  a036              ADR      r0,|L1.924|
0002c2  f7fffffe          BL       __2printf
;;;291        if (argc == 1)
0002c6  2e01              CMP      r6,#1
0002c8  d11f              BNE      |L1.778|
;;;292        {
;;;293            /*
;;;294             * Show all Option settings
;;;295             */
;;;296            argc = 2;
0002ca  2602              MOVS     r6,#2
;;;297            argv[2] = NULL;
0002cc  2000              MOVS     r0,#0
0002ce  60a8              STR      r0,[r5,#8]
;;;298            for (index = 0; index < UIF_NUM_SETCMD; index++)
0002d0  2400              MOVS     r4,#0
0002d2  e012              B        |L1.762|
                  |L1.724|
;;;299            {
;;;300                printf(OPTFMT,UIF_SETCMDTAB[index].option);
0002d4  2014              MOVS     r0,#0x14
0002d6  4360              MULS     r0,r4,r0
0002d8  4a38              LDR      r2,|L1.956|
0002da  5811              LDR      r1,[r2,r0]
0002dc  4838              LDR      r0,|L1.960|
0002de  f7fffffe          BL       __2printf
;;;301                UIF_SETCMDTAB[index].func(argc,argv);
0002e2  2014              MOVS     r0,#0x14
0002e4  4360              MULS     r0,r4,r0
0002e6  4935              LDR      r1,|L1.956|
0002e8  1840              ADDS     r0,r0,r1
0002ea  4629              MOV      r1,r5
0002ec  68c2              LDR      r2,[r0,#0xc]
0002ee  4630              MOV      r0,r6
0002f0  4790              BLX      r2
;;;302                printf("\n");
0002f2  a02a              ADR      r0,|L1.924|
0002f4  f7fffffe          BL       __2printf
0002f8  1c64              ADDS     r4,r4,#1              ;298
                  |L1.762|
0002fa  4833              LDR      r0,|L1.968|
0002fc  6800              LDR      r0,[r0,#0]            ;298  ; UIF_NUM_SETCMD
0002fe  4284              CMP      r4,r0                 ;298
000300  dbe8              BLT      |L1.724|
;;;303            }
;;;304            printf("\n");
000302  a026              ADR      r0,|L1.924|
000304  f7fffffe          BL       __2printf
                  |L1.776|
;;;305            return;
;;;306        }
;;;307    
;;;308        for (index = 0; index < UIF_NUM_SETCMD; index++)
;;;309        {
;;;310            if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
;;;311            {
;;;312                if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
;;;313                    ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
;;;314                {
;;;315                    printf(OPTFMT,UIF_SETCMDTAB[index].option);
;;;316                    UIF_SETCMDTAB[index].func(argc,argv);
;;;317                    printf("\n\n");
;;;318                    return;
;;;319                }
;;;320                else
;;;321                {
;;;322                    printf(INVARG,argv[1]);
;;;323                    return;
;;;324                }
;;;325            }
;;;326        }
;;;327        printf(INVOPT,argv[1]);
;;;328    }
000308  bd70              POP      {r4-r6,pc}
                  |L1.778|
00030a  2400              MOVS     r4,#0                 ;308
00030c  e02e              B        |L1.876|
                  |L1.782|
00030e  2214              MOVS     r2,#0x14              ;310
000310  4362              MULS     r2,r4,r2              ;310
000312  4b2a              LDR      r3,|L1.956|
000314  5898              LDR      r0,[r3,r2]            ;310
000316  6869              LDR      r1,[r5,#4]            ;310
000318  f7fffffe          BL       strcasecmp
00031c  2800              CMP      r0,#0                 ;310
00031e  d124              BNE      |L1.874|
000320  1eb0              SUBS     r0,r6,#2              ;312
000322  2114              MOVS     r1,#0x14              ;312
000324  4361              MULS     r1,r4,r1              ;312
000326  4a25              LDR      r2,|L1.956|
000328  1889              ADDS     r1,r1,r2              ;312
00032a  6849              LDR      r1,[r1,#4]            ;312
00032c  4288              CMP      r0,r1                 ;312
00032e  db17              BLT      |L1.864|
000330  2114              MOVS     r1,#0x14              ;313
000332  4361              MULS     r1,r4,r1              ;313
000334  1889              ADDS     r1,r1,r2              ;313
000336  6889              LDR      r1,[r1,#8]            ;313
000338  4288              CMP      r0,r1                 ;313
00033a  dc11              BGT      |L1.864|
00033c  2014              MOVS     r0,#0x14              ;315
00033e  4360              MULS     r0,r4,r0              ;315
000340  5811              LDR      r1,[r2,r0]            ;315
000342  481f              LDR      r0,|L1.960|
000344  f7fffffe          BL       __2printf
000348  2014              MOVS     r0,#0x14              ;316
00034a  4360              MULS     r0,r4,r0              ;316
00034c  491b              LDR      r1,|L1.956|
00034e  1840              ADDS     r0,r0,r1              ;316
000350  4629              MOV      r1,r5                 ;316
000352  68c2              LDR      r2,[r0,#0xc]          ;316
000354  4630              MOV      r0,r6                 ;316
000356  4790              BLX      r2                    ;316
000358  a026              ADR      r0,|L1.1012|
00035a  f7fffffe          BL       __2printf
00035e  e7d3              B        |L1.776|
                  |L1.864|
000360  4822              LDR      r0,|L1.1004|
000362  6869              LDR      r1,[r5,#4]            ;322
000364  f7fffffe          BL       __2printf
000368  e7ce              B        |L1.776|
                  |L1.874|
00036a  1c64              ADDS     r4,r4,#1              ;308
                  |L1.876|
00036c  4816              LDR      r0,|L1.968|
00036e  6800              LDR      r0,[r0,#0]            ;308  ; UIF_NUM_SETCMD
000370  4284              CMP      r4,r0                 ;308
000372  dbcc              BLT      |L1.782|
000374  481e              LDR      r0,|L1.1008|
000376  6869              LDR      r1,[r5,#4]            ;327
000378  f7fffffe          BL       __2printf
00037c  bf00              NOP      
00037e  e7c3              B        |L1.776|
;;;329    
                          ENDP

                  |L1.896|
                          DCD      cmdline1
                  |L1.900|
                          DCD      cmdline2
                  |L1.904|
                          DCD      UIF_CMDTAB
                  |L1.908|
                          DCD      SYNTAX
                  |L1.912|
                          DCD      UIF_NUM_CMD
                  |L1.916|
                          DCD      INVCMD
                  |L1.920|
                          DCD      HELPMSG
                  |L1.924|
00039c  0a00              DCB      "\n",0
00039e  00                DCB      0
00039f  00                DCB      0
                  |L1.928|
                          DCD      HELPFORMAT
                  |L1.932|
0003a4  56616c69          DCB      "Valid 'set' options:\n",0
0003a8  64202773
0003ac  65742720
0003b0  6f707469
0003b4  6f6e733a
0003b8  0a00    
0003ba  00                DCB      0
0003bb  00                DCB      0
                  |L1.956|
                          DCD      UIF_SETCMDTAB
                  |L1.960|
                          DCD      OPTFMT
                  |L1.964|
0003c4  25730a00          DCB      "%s\n",0
                  |L1.968|
                          DCD      UIF_NUM_SETCMD
                  |L1.972|
0003cc  4572726f          DCB      "Error: Invalid argument list\n",0
0003d0  723a2049
0003d4  6e76616c
0003d8  69642061
0003dc  7267756d
0003e0  656e7420
0003e4  6c697374
0003e8  0a00    
0003ea  00                DCB      0
0003eb  00                DCB      0
                  |L1.1004|
                          DCD      INVARG
                  |L1.1008|
                          DCD      INVOPT
                  |L1.1012|
0003f4  0a0a00            DCB      "\n\n",0
0003f7  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  cmdline1
                          %        80
                  cmdline2
                          %        80

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  UIF_CMDTAB
                          %        28
                  UIF_NUM_CMD
                          DCD      0x00000000
                  UIF_SETCMDTAB
                          %        20
                  UIF_NUM_SETCMD
                          DCD      0x00000000
                  HELPMSG
000038  456e7465          DCB      0x45,0x6e,0x74,0x65
00003c  72202768          DCB      0x72,0x20,0x27,0x68
000040  656c7027          DCB      0x65,0x6c,0x70,0x27
000044  20666f72          DCB      0x20,0x66,0x6f,0x72
000048  2068656c          DCB      0x20,0x68,0x65,0x6c
00004c  702e0a00          DCB      0x70,0x2e,0x0a,0x00
                  INVARG
000050  4572726f          DCB      0x45,0x72,0x72,0x6f
000054  723a2049          DCB      0x72,0x3a,0x20,0x49
000058  6e76616c          DCB      0x6e,0x76,0x61,0x6c
00005c  69642061          DCB      0x69,0x64,0x20,0x61
000060  7267756d          DCB      0x72,0x67,0x75,0x6d
000064  656e743a          DCB      0x65,0x6e,0x74,0x3a
000068  2025730a          DCB      0x20,0x25,0x73,0x0a
00006c  00                DCB      0x00
                  INVALUE
00006d  457272            DCB      0x45,0x72,0x72
000070  6f723a20          DCB      0x6f,0x72,0x3a,0x20
000074  496e7661          DCB      0x49,0x6e,0x76,0x61
000078  6c696420          DCB      0x6c,0x69,0x64,0x20
00007c  76616c75          DCB      0x76,0x61,0x6c,0x75
000080  653a2025          DCB      0x65,0x3a,0x20,0x25
000084  730a00            DCB      0x73,0x0a,0x00
                  INVCMD
000087  45                DCB      0x45
000088  72726f72          DCB      0x72,0x72,0x6f,0x72
00008c  3a204e6f          DCB      0x3a,0x20,0x4e,0x6f
000090  20737563          DCB      0x20,0x73,0x75,0x63
000094  6820636f          DCB      0x68,0x20,0x63,0x6f
000098  6d6d616e          DCB      0x6d,0x6d,0x61,0x6e
00009c  643a2025          DCB      0x64,0x3a,0x20,0x25
0000a0  730a00            DCB      0x73,0x0a,0x00
                  HELPFORMAT
0000a3  25                DCB      0x25
0000a4  38732020          DCB      0x38,0x73,0x20,0x20
0000a8  252d3235          DCB      0x25,0x2d,0x32,0x35
0000ac  73202573          DCB      0x73,0x20,0x25,0x73
0000b0  2025730a          DCB      0x20,0x25,0x73,0x0a
0000b4  00                DCB      0x00
                  SYNTAX
0000b5  457272            DCB      0x45,0x72,0x72
0000b8  6f723a20          DCB      0x6f,0x72,0x3a,0x20
0000bc  496e7661          DCB      0x49,0x6e,0x76,0x61
0000c0  6c696420          DCB      0x6c,0x69,0x64,0x20
0000c4  73796e74          DCB      0x73,0x79,0x6e,0x74
0000c8  61782066          DCB      0x61,0x78,0x20,0x66
0000cc  6f723a20          DCB      0x6f,0x72,0x3a,0x20
0000d0  25730a00          DCB      0x25,0x73,0x0a,0x00
                  INVOPT
0000d4  4572726f          DCB      0x45,0x72,0x72,0x6f
0000d8  723a2020          DCB      0x72,0x3a,0x20,0x20
0000dc  496e7661          DCB      0x49,0x6e,0x76,0x61
0000e0  6c696420          DCB      0x6c,0x69,0x64,0x20
0000e4  7365742f          DCB      0x73,0x65,0x74,0x2f
0000e8  73686f77          DCB      0x73,0x68,0x6f,0x77
0000ec  206f7074          DCB      0x20,0x6f,0x70,0x74
0000f0  696f6e3a          DCB      0x69,0x6f,0x6e,0x3a
0000f4  2025730a          DCB      0x20,0x25,0x73,0x0a
0000f8  00                DCB      0x00
                  OPTFMT
0000f9  253132            DCB      0x25,0x31,0x32
0000fc  733a2000          DCB      0x73,0x3a,0x20,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\common\\uif.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_uif_c_HELPMSG____REV16|
#line 465 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.2.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_uif_c_HELPMSG____REV16| PROC
#line 466

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_uif_c_HELPMSG____REVSH|
#line 480
|__asm___5_uif_c_HELPMSG____REVSH| PROC
#line 481

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
