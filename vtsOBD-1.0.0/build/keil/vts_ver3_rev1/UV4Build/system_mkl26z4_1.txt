; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\system_mkl26z4_1.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\system_mkl26z4_1.d --cpu=Cortex-M0+ --apcs=interwork -O0 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -IC:\Users\Mridul\Desktop\vts_ver3\build\keil\vts_ver3_rev1\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS_RTX\INC -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.5.0\Device\Include -D__RTX -D__MICROLIB -D_RTE_ -DMKL26Z128xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\system_mkl26z4_1.crf RTE\Device\MKL26Z128xxx4\system_MKL26Z4.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;108    
;;;109    void SystemInit (void) {
000000  2000              MOVS     r0,#0
;;;110    #if (DISABLE_WDOG)
;;;111      /* Disable the WDOG module */
;;;112      /* SIM_COPC: COPT=0,COPCLKS=0,COPW=0 */
;;;113      SIM->COPC = (uint32_t)0x00u;
000002  4967              LDR      r1,|L1.416|
000004  6008              STR      r0,[r1,#0]
;;;114    #endif /* (DISABLE_WDOG) */
;;;115    #if (CLOCK_SETUP == 0)
;;;116      /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=2,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;117      SIM->CLKDIV1 = (uint32_t)0x00020000UL; /* Update system prescalers */
000006  2001              MOVS     r0,#1
000008  0440              LSLS     r0,r0,#17
00000a  4965              LDR      r1,|L1.416|
00000c  39c0              SUBS     r1,r1,#0xc0
00000e  6048              STR      r0,[r1,#4]
;;;118      /* Switch to FEI Mode */
;;;119      /* MCG->C1: CLKS=0,FRDIV=0,IREFS=1,IRCLKEN=1,IREFSTEN=0 */
;;;120      MCG->C1 = (uint8_t)0x06U;
000010  2006              MOVS     r0,#6
000012  4964              LDR      r1,|L1.420|
000014  7008              STRB     r0,[r1,#0]
;;;121      /* MCG_C2: LOCRE0=0,RANGE0=0,HGO0=0,EREFS0=0,LP=0,IRCS=0 */
;;;122      MCG->C2 &= (uint8_t)~(uint8_t)0xBFU;
000016  4608              MOV      r0,r1
000018  7840              LDRB     r0,[r0,#1]
00001a  2140              MOVS     r1,#0x40
00001c  4008              ANDS     r0,r0,r1
00001e  4961              LDR      r1,|L1.420|
000020  7048              STRB     r0,[r1,#1]
;;;123      /* MCG->C4: DMX32=0,DRST_DRS=1 */
;;;124      MCG->C4 = (uint8_t)((MCG->C4 & (uint8_t)~(uint8_t)0xC0U) | (uint8_t)0x20U);
000022  4608              MOV      r0,r1
000024  78c0              LDRB     r0,[r0,#3]
000026  0680              LSLS     r0,r0,#26
000028  0e80              LSRS     r0,r0,#26
00002a  2120              MOVS     r1,#0x20
00002c  4308              ORRS     r0,r0,r1
00002e  495d              LDR      r1,|L1.420|
000030  70c8              STRB     r0,[r1,#3]
;;;125      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
;;;126      OSC0->CR = (uint8_t)0x80U;
000032  2080              MOVS     r0,#0x80
000034  495c              LDR      r1,|L1.424|
000036  7008              STRB     r0,[r1,#0]
;;;127      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;128      MCG->C5 = (uint8_t)0x00U;
000038  2000              MOVS     r0,#0
00003a  495a              LDR      r1,|L1.420|
00003c  7108              STRB     r0,[r1,#4]
;;;129      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;130      MCG->C6 = (uint8_t)0x00U;
00003e  7148              STRB     r0,[r1,#5]
;;;131      while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
000040  bf00              NOP      
                  |L1.66|
000042  4858              LDR      r0,|L1.420|
000044  7980              LDRB     r0,[r0,#6]
000046  2110              MOVS     r1,#0x10
000048  4008              ANDS     r0,r0,r1
00004a  2800              CMP      r0,#0
00004c  d0f9              BEQ      |L1.66|
;;;132      }
;;;133      while((MCG->S & 0x0CU) != 0x00U) {    /* Wait until output of the FLL is selected */
00004e  bf00              NOP      
                  |L1.80|
000050  4854              LDR      r0,|L1.420|
000052  7980              LDRB     r0,[r0,#6]
000054  210c              MOVS     r1,#0xc
000056  4008              ANDS     r0,r0,r1
000058  2800              CMP      r0,#0
00005a  d1f9              BNE      |L1.80|
;;;134      }
;;;135    #elif (CLOCK_SETUP == 1)
;;;136      /* SIM->SCGC5: PORTA=1 */
;;;137      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
;;;138      /* SIM->CLKDIV1: OUTDIV1=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;139      SIM->CLKDIV1 = (uint32_t)0x10010000UL; /* Update system prescalers */
;;;140      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;141      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
;;;142      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;143      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
;;;144      /* Switch to FBE Mode */
;;;145      /* MCG_C2: LOCRE0=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;146      MCG->C2 = (uint8_t)((MCG->C2 & (uint8_t)~(uint8_t)0x9BU) | (uint8_t)0x24U);
;;;147      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=0 */
;;;148      OSC0->CR = (uint8_t)0x80U;
;;;149      /* MCG_C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;150      MCG->C1 = (uint8_t)0x9AU;
;;;151      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;152      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
;;;153      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=1 */
;;;154      MCG->C5 = (uint8_t)0x01U;
;;;155      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;156      MCG->C6 = (uint8_t)0x00U;
;;;157      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
;;;158      }
;;;159      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;160      }
;;;161      /* Switch to PBE Mode */
;;;162      /* MCG->C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
;;;163      MCG->C6 = (uint8_t)0x40U;
;;;164      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;165      }
;;;166      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
;;;167      }
;;;168      /* Switch to PEE Mode */
;;;169      /* MCG->C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;170      MCG->C1 = (uint8_t)0x1AU;
;;;171      while((MCG->S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */
;;;172      }
;;;173    #elif (CLOCK_SETUP == 2)
;;;174      /* SIM->SCGC5: PORTA=1 */
;;;175      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
;;;176      /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;177      SIM->CLKDIV1 = (uint32_t)0x00000000UL; /* Update system prescalers */
;;;178      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;179      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
;;;180      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;181      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
;;;182      /* Switch to FBE Mode */
;;;183      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;184      MCG->C2 = (uint8_t)0x24U;
;;;185      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=0 */
;;;186      OSC0->CR = (uint8_t)0x80U;
;;;187      /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;188      MCG->C1 = (uint8_t)0x9AU;
;;;189      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;190      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
;;;191      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;192      MCG->C5 = (uint8_t)0x00U;
;;;193      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;194      MCG->C6 = (uint8_t)0x00U;
;;;195      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
;;;196      }
;;;197      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;198      }
;;;199      /* Switch to BLPE Mode */
;;;200      /* MCG_C2: LOCRE0=0,RANGE0=2,HGO0=0,EREFS0=1,LP=1,IRCS=0 */
;;;201      MCG->C2 = (uint8_t)((MCG->C2 & (uint8_t)~(uint8_t)0x99U) | (uint8_t)0x26U);
;;;202      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;203      }
;;;204    #endif /* (CLOCK_SETUP == 2) */
;;;205    }
00005c  4770              BX       lr
;;;206    
                          ENDP

                  SystemCoreClockUpdate PROC
;;;210    
;;;211    void SystemCoreClockUpdate (void) {
00005e  b570              PUSH     {r4-r6,lr}
;;;212      uint32_t MCGOUTClock;                                                        /* Variable to store output clock frequency of the MCG module */
;;;213      uint8_t Divider;
;;;214    
;;;215      if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x0u) {
000060  4850              LDR      r0,|L1.420|
000062  7800              LDRB     r0,[r0,#0]
000064  21c0              MOVS     r1,#0xc0
000066  4008              ANDS     r0,r0,r1
000068  2800              CMP      r0,#0
00006a  d168              BNE      |L1.318|
;;;216        /* Output of FLL or PLL is selected */
;;;217        if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u) {
00006c  484d              LDR      r0,|L1.420|
00006e  7940              LDRB     r0,[r0,#5]
000070  2140              MOVS     r1,#0x40
000072  4008              ANDS     r0,r0,r1
000074  2800              CMP      r0,#0
000076  d14e              BNE      |L1.278|
;;;218          /* FLL is selected */
;;;219          if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u) {
000078  484a              LDR      r0,|L1.420|
00007a  7800              LDRB     r0,[r0,#0]
00007c  2104              MOVS     r1,#4
00007e  4008              ANDS     r0,r0,r1
000080  2800              CMP      r0,#0
000082  d115              BNE      |L1.176|
;;;220            /* External reference clock is selected */
;;;221            MCGOUTClock = CPU_XTAL_CLK_HZ;                                       /* System oscillator drives MCG clock */
000084  4c49              LDR      r4,|L1.428|
;;;222            Divider = (uint8_t)(1u << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
000086  4847              LDR      r0,|L1.420|
000088  7800              LDRB     r0,[r0,#0]
00008a  2138              MOVS     r1,#0x38
00008c  4008              ANDS     r0,r0,r1
00008e  08c1              LSRS     r1,r0,#3
000090  2001              MOVS     r0,#1
000092  4088              LSLS     r0,r0,r1
000094  b2c5              UXTB     r5,r0
;;;223            MCGOUTClock = (MCGOUTClock / Divider);  /* Calculate the divided FLL reference clock */
000096  4629              MOV      r1,r5
000098  4620              MOV      r0,r4
00009a  f7fffffe          BL       __aeabi_uidivmod
00009e  4604              MOV      r4,r0
;;;224            if ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) {
0000a0  4840              LDR      r0,|L1.420|
0000a2  7840              LDRB     r0,[r0,#1]
0000a4  2130              MOVS     r1,#0x30
0000a6  4008              ANDS     r0,r0,r1
0000a8  2800              CMP      r0,#0
0000aa  d003              BEQ      |L1.180|
;;;225              MCGOUTClock /= 32u;                                                  /* If high range is enabled, additional 32 divider is active */
0000ac  0964              LSRS     r4,r4,#5
0000ae  e001              B        |L1.180|
                  |L1.176|
;;;226            } /* ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) */
;;;227          } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;228            MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                     /* The slow internal reference clock is selected */
0000b0  2401              MOVS     r4,#1
0000b2  03e4              LSLS     r4,r4,#15
                  |L1.180|
;;;229          } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;230          /* Select correct multiplier to calculate the MCG output clock  */
;;;231          switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
0000b4  483b              LDR      r0,|L1.420|
0000b6  78c0              LDRB     r0,[r0,#3]
0000b8  21e0              MOVS     r1,#0xe0
0000ba  4008              ANDS     r0,r0,r1
0000bc  06c1              LSLS     r1,r0,#27
0000be  0ec9              LSRS     r1,r1,#27
0000c0  2900              CMP      r1,#0
0000c2  d126              BNE      |L1.274|
0000c4  1140              ASRS     r0,r0,#5
0000c6  0003              MOVS     r3,r0
0000c8  f7fffffe          BL       __ARM_common_switch8
0000cc  0805090d          DCB      0x08,0x05,0x09,0x0d
0000d0  1115191d          DCB      0x11,0x15,0x19,0x1d
0000d4  2023              DCB      0x20,0x23
;;;232            case 0x0u:
;;;233              MCGOUTClock *= 640u;
0000d6  2005              MOVS     r0,#5
0000d8  01c0              LSLS     r0,r0,#7
0000da  4344              MULS     r4,r0,r4
;;;234              break;
0000dc  e01a              B        |L1.276|
;;;235            case 0x20u:
;;;236              MCGOUTClock *= 1280u;
0000de  2005              MOVS     r0,#5
0000e0  0200              LSLS     r0,r0,#8
0000e2  4344              MULS     r4,r0,r4
;;;237              break;
0000e4  e016              B        |L1.276|
;;;238            case 0x40u:
;;;239              MCGOUTClock *= 1920u;
0000e6  200f              MOVS     r0,#0xf
0000e8  01c0              LSLS     r0,r0,#7
0000ea  4344              MULS     r4,r0,r4
;;;240              break;
0000ec  e012              B        |L1.276|
;;;241            case 0x60u:
;;;242              MCGOUTClock *= 2560u;
0000ee  2005              MOVS     r0,#5
0000f0  0240              LSLS     r0,r0,#9
0000f2  4344              MULS     r4,r0,r4
;;;243              break;
0000f4  e00e              B        |L1.276|
;;;244            case 0x80u:
;;;245              MCGOUTClock *= 732u;
0000f6  20b7              MOVS     r0,#0xb7
0000f8  0080              LSLS     r0,r0,#2
0000fa  4344              MULS     r4,r0,r4
;;;246              break;
0000fc  e00a              B        |L1.276|
;;;247            case 0xA0u:
;;;248              MCGOUTClock *= 1464u;
0000fe  20b7              MOVS     r0,#0xb7
000100  00c0              LSLS     r0,r0,#3
000102  4344              MULS     r4,r0,r4
;;;249              break;
000104  e006              B        |L1.276|
;;;250            case 0xC0u:
;;;251              MCGOUTClock *= 2197u;
000106  482a              LDR      r0,|L1.432|
000108  4344              MULS     r4,r0,r4
;;;252              break;
00010a  e003              B        |L1.276|
;;;253            case 0xE0u:
;;;254              MCGOUTClock *= 2929u;
00010c  4829              LDR      r0,|L1.436|
00010e  4344              MULS     r4,r0,r4
;;;255              break;
000110  e000              B        |L1.276|
                  |L1.274|
;;;256            default:
;;;257              break;
000112  bf00              NOP      
                  |L1.276|
000114  e038              B        |L1.392|
                  |L1.278|
;;;258          }
;;;259        } else { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;260          /* PLL is selected */
;;;261          Divider = (1u + (MCG->C5 & MCG_C5_PRDIV0_MASK));
000116  4823              LDR      r0,|L1.420|
000118  7900              LDRB     r0,[r0,#4]
00011a  06c0              LSLS     r0,r0,#27
00011c  0ec0              LSRS     r0,r0,#27
00011e  1c45              ADDS     r5,r0,#1
;;;262          MCGOUTClock = (uint32_t)(CPU_XTAL_CLK_HZ / Divider);                     /* Calculate the PLL reference clock */
000120  4629              MOV      r1,r5
000122  4822              LDR      r0,|L1.428|
000124  f7fffffe          BL       __aeabi_uidivmod
000128  4604              MOV      r4,r0
;;;263          Divider = ((MCG->C6 & MCG_C6_VDIV0_MASK) + 24u);
00012a  481e              LDR      r0,|L1.420|
00012c  7940              LDRB     r0,[r0,#5]
00012e  06c0              LSLS     r0,r0,#27
000130  0ec0              LSRS     r0,r0,#27
000132  4605              MOV      r5,r0
000134  3518              ADDS     r5,r5,#0x18
;;;264          MCGOUTClock *= Divider;                       /* Calculate the MCG output clock */
000136  4620              MOV      r0,r4
000138  4368              MULS     r0,r5,r0
00013a  4604              MOV      r4,r0
00013c  e024              B        |L1.392|
                  |L1.318|
;;;265        } /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;266      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40u) {
00013e  4819              LDR      r0,|L1.420|
000140  7800              LDRB     r0,[r0,#0]
000142  21c0              MOVS     r1,#0xc0
000144  4008              ANDS     r0,r0,r1
000146  2840              CMP      r0,#0x40
000148  d115              BNE      |L1.374|
;;;267        /* Internal reference clock is selected */
;;;268        if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u) {
00014a  4816              LDR      r0,|L1.420|
00014c  7840              LDRB     r0,[r0,#1]
00014e  07c0              LSLS     r0,r0,#31
000150  0fc0              LSRS     r0,r0,#31
000152  2800              CMP      r0,#0
000154  d102              BNE      |L1.348|
;;;269          MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                       /* Slow internal reference clock selected */
000156  2401              MOVS     r4,#1
000158  03e4              LSLS     r4,r4,#15
00015a  e015              B        |L1.392|
                  |L1.348|
;;;270        } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;271          MCGOUTClock = CPU_INT_FAST_CLK_HZ / (1 << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));  /* Fast internal reference clock selected */
00015c  4811              LDR      r0,|L1.420|
00015e  7a00              LDRB     r0,[r0,#8]
000160  220e              MOVS     r2,#0xe
000162  4010              ANDS     r0,r0,r2
000164  0842              LSRS     r2,r0,#1
000166  2001              MOVS     r0,#1
000168  4090              LSLS     r0,r0,r2
00016a  4601              MOV      r1,r0
00016c  4812              LDR      r0,|L1.440|
00016e  f7fffffe          BL       __aeabi_uidivmod
000172  4604              MOV      r4,r0
000174  e008              B        |L1.392|
                  |L1.374|
;;;272        } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;273      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u) {
000176  480b              LDR      r0,|L1.420|
000178  7800              LDRB     r0,[r0,#0]
00017a  21c0              MOVS     r1,#0xc0
00017c  4008              ANDS     r0,r0,r1
00017e  2880              CMP      r0,#0x80
000180  d101              BNE      |L1.390|
;;;274        /* External reference clock is selected */
;;;275        MCGOUTClock = CPU_XTAL_CLK_HZ;                                           /* System oscillator drives MCG clock */
000182  4c0a              LDR      r4,|L1.428|
000184  e000              B        |L1.392|
                  |L1.390|
;;;276      } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;277        /* Reserved value */
;;;278        return;
;;;279      } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;280      SystemCoreClock = (MCGOUTClock / (1u + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
;;;281    }
000186  bd70              POP      {r4-r6,pc}
                  |L1.392|
000188  4805              LDR      r0,|L1.416|
00018a  38c0              SUBS     r0,r0,#0xc0           ;280
00018c  6840              LDR      r0,[r0,#4]            ;280
00018e  0f00              LSRS     r0,r0,#28             ;280
000190  1c41              ADDS     r1,r0,#1              ;280
000192  4620              MOV      r0,r4                 ;280
000194  f7fffffe          BL       __aeabi_uidivmod
000198  4908              LDR      r1,|L1.444|
00019a  6008              STR      r0,[r1,#0]            ;280  ; SystemCoreClock
00019c  bf00              NOP      
00019e  e7f2              B        |L1.390|
                          ENDP

                  |L1.416|
                          DCD      0x40048100
                  |L1.420|
                          DCD      0x40064000
                  |L1.424|
                          DCD      0x40065000
                  |L1.428|
                          DCD      0x007a1200
                  |L1.432|
                          DCD      0x00000895
                  |L1.436|
                          DCD      0x00000b71
                  |L1.440|
                          DCD      0x003d0900
                  |L1.444|
                          DCD      SystemCoreClock

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x02800000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L16.24|
                  |L16.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L16.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L16.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "RTE\\Device\\MKL26Z128xxx4\\system_MKL26Z4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL26Z4_c_5d646a67____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_system_MKL26Z4_c_5d646a67____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL26Z4_c_5d646a67____REVSH|
#line 144
|__asm___16_system_MKL26Z4_c_5d646a67____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
