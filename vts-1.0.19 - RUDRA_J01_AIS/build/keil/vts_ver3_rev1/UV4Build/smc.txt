; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\smc.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\smc.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -I..\..\..\..\inc -I..\vts_ver3_rev1 -IF:\vts-ver19\build\keil\vts_ver3_rev1\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.12.0\Device\Include -D__UVISION_VERSION=518 -D_RTE_ -DMKL26Z256xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\smc.crf ..\..\..\src\drivers\smc\smc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sleep PROC
;;;34     
;;;35     void sleep (void)
000000  48d7              LDR      r0,|L1.864|
;;;36     {
;;;37     /* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) 
;;;38      * mode instead of deep sleep.
;;;39      */
;;;40     SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
000002  6900              LDR      r0,[r0,#0x10]
000004  2104              MOVS     r1,#4
000006  4388              BICS     r0,r0,r1
000008  49d5              LDR      r1,|L1.864|
00000a  6108              STR      r0,[r1,#0x10]
;;;41     
;;;42     #if (defined(CMSIS))
;;;43       __wfi();
00000c  bf30              WFI      
;;;44     #elif (defined(KEIL))
;;;45     	__wfi();
;;;46     #else
;;;47       /* WFI instruction will start entry into WAIT mode */
;;;48       asm("WFI");
;;;49     #endif 
;;;50     }
00000e  4770              BX       lr
;;;51     /***************************************************************/
                          ENDP

                  deepsleep PROC
;;;61     
;;;62     void deepsleep (void)
000010  48d3              LDR      r0,|L1.864|
;;;63     {
;;;64       /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
;;;65       SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
000012  6900              LDR      r0,[r0,#0x10]
000014  2104              MOVS     r1,#4
000016  4308              ORRS     r0,r0,r1
000018  49d1              LDR      r1,|L1.864|
00001a  6108              STR      r0,[r1,#0x10]
;;;66     
;;;67     #if (defined(CMSIS))
;;;68       __wfi();
00001c  bf30              WFI      
;;;69     #elif (defined(KEIL))
;;;70     	__wfi();
;;;71     #else
;;;72       /* WFI instruction will start entry into STOP mode */
;;;73       asm("WFI");
;;;74     #endif
;;;75     }
00001e  4770              BX       lr
;;;76     /********************************************************************/
                          ENDP

                  enter_wait PROC
;;;100     */
;;;101    void enter_wait(void)
000020  48cf              LDR      r0,|L1.864|
;;;102    {
;;;103    #ifdef CMSIS
;;;104        /* Clear the SLEEPDEEP bit to make sure we go into WAIT (sleep) mode instead
;;;105         * of deep sleep.
;;;106         */
;;;107    	SCB_SCR &= ~SCB_SCR_SLEEPDEEP_MASK;
000022  6900              LDR      r0,[r0,#0x10]
000024  2104              MOVS     r1,#4
000026  4388              BICS     r0,r0,r1
000028  49cd              LDR      r1,|L1.864|
00002a  6108              STR      r0,[r1,#0x10]
;;;108            
;;;109        __wfi();
00002c  bf30              WFI      
;;;110    #else
;;;111        wait();
;;;112    #endif
;;;113    }
00002e  4770              BX       lr
;;;114    /********************************************************************/
                          ENDP

                  enter_stop PROC
;;;136     */
;;;137    void enter_stop(unsigned char partial_stop_opt)
000030  b508              PUSH     {r3,lr}
;;;138    {
;;;139      volatile unsigned int dummyread;
;;;140      /* The PMPROT register may have already been written by init code
;;;141         If so then this next write is not done since  
;;;142         PMPROT is write once after RESET  
;;;143         this write-once bit allows the MCU to enter the
;;;144         normal STOP mode.
;;;145         If AVLP is already a 1, VLPS mode is entered instead of normal STOP*/
;;;146      SMC_PMPROT = 0;  
000032  2100              MOVS     r1,#0
000034  4acb              LDR      r2,|L1.868|
000036  7011              STRB     r1,[r2,#0]
;;;147    
;;;148      /* Set the STOPM field to 0b000 for normal STOP mode */
;;;149      SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK;
000038  4611              MOV      r1,r2
00003a  7849              LDRB     r1,[r1,#1]
00003c  08c9              LSRS     r1,r1,#3
00003e  00c9              LSLS     r1,r1,#3
000040  7051              STRB     r1,[r2,#1]
;;;150      SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0); 
000042  4611              MOV      r1,r2
000044  7849              LDRB     r1,[r1,#1]
000046  7051              STRB     r1,[r2,#1]
;;;151      SMC_STOPCTRL &= ~SMC_STOPCTRL_PSTOPO_MASK;
000048  4611              MOV      r1,r2
00004a  7889              LDRB     r1,[r1,#2]
00004c  22c0              MOVS     r2,#0xc0
00004e  4391              BICS     r1,r1,r2
000050  4ac4              LDR      r2,|L1.868|
000052  7091              STRB     r1,[r2,#2]
;;;152      SMC_STOPCTRL |= partial_stop_opt;
000054  4611              MOV      r1,r2
000056  7889              LDRB     r1,[r1,#2]
000058  4301              ORRS     r1,r1,r0
00005a  7091              STRB     r1,[r2,#2]
;;;153      /*wait for write to complete to SMC before stopping core */  
;;;154      dummyread = SMC_PMCTRL;
00005c  4611              MOV      r1,r2
00005e  7849              LDRB     r1,[r1,#1]
000060  9100              STR      r1,[sp,#0]
;;;155      dummyread = dummyread + 1;
000062  9900              LDR      r1,[sp,#0]
000064  1c49              ADDS     r1,r1,#1
000066  9100              STR      r1,[sp,#0]
;;;156      
;;;157    #ifdef CMSIS
;;;158      /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
;;;159      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
000068  49bd              LDR      r1,|L1.864|
00006a  6909              LDR      r1,[r1,#0x10]
00006c  2204              MOVS     r2,#4
00006e  4311              ORRS     r1,r1,r2
000070  4abb              LDR      r2,|L1.864|
000072  6111              STR      r1,[r2,#0x10]
;;;160      __wfi();
000074  bf30              WFI      
;;;161    #else
;;;162      stop();
;;;163    #endif
;;;164    }
000076  bd08              POP      {r3,pc}
;;;165    /****************************************************************/
                          ENDP

                  enter_vlpr PROC
;;;186     */
;;;187    int enter_vlpr(void)
000078  2000              MOVS     r0,#0
;;;188    {
;;;189      int i; 
;;;190      unsigned int return_value = 0;
;;;191      if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
00007a  4aba              LDR      r2,|L1.868|
00007c  78d2              LDRB     r2,[r2,#3]
00007e  0652              LSLS     r2,r2,#25
000080  0e52              LSRS     r2,r2,#25
000082  2a04              CMP      r2,#4
000084  d100              BNE      |L1.136|
;;;192             return_value = 0x14;
000086  2014              MOVS     r0,#0x14
                  |L1.136|
;;;193             }
;;;194      /* The PMPROT register may have already been written by init code
;;;195         If so then this next write is not done.  
;;;196         PMPROT is write once after RESET  
;;;197         this write-once bit allows the MCU to enter the
;;;198         very low power modes: VLPR, VLPW, and VLPS   */
;;;199      SMC_PMPROT = SMC_PMPROT_AVLP_MASK;  
000088  2220              MOVS     r2,#0x20
00008a  4bb6              LDR      r3,|L1.868|
00008c  701a              STRB     r2,[r3,#0]
;;;200        
;;;201      /* Set the (for MC1)LPLLSM or (for MC2)STOPM field 
;;;202         to 0b010 for VLPS mode -
;;;203         and RUNM bits to 0b010 for VLPR mode  */
;;;204      SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK; 
00008e  461a              MOV      r2,r3
000090  7852              LDRB     r2,[r2,#1]
000092  2360              MOVS     r3,#0x60
000094  439a              BICS     r2,r2,r3
000096  4bb3              LDR      r3,|L1.868|
000098  705a              STRB     r2,[r3,#1]
;;;205      SMC_PMCTRL  |= SMC_PMCTRL_RUNM(0x2);
00009a  461a              MOV      r2,r3
00009c  7852              LDRB     r2,[r2,#1]
00009e  2340              MOVS     r3,#0x40
0000a0  431a              ORRS     r2,r2,r3
0000a2  4bb0              LDR      r3,|L1.868|
0000a4  705a              STRB     r2,[r3,#1]
;;;206      /* Wait for VLPS regulator mode to be confirmed */
;;;207      for (i = 0 ; i < 10000 ; i++)
0000a6  2100              MOVS     r1,#0
0000a8  e007              B        |L1.186|
                  |L1.170|
;;;208        {     /* check that the value of REGONS bit is not 0
;;;209                 once it is a zero we can stop checking */
;;;210          if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) ==0x04){
0000aa  4aaf              LDR      r2,|L1.872|
0000ac  7892              LDRB     r2,[r2,#2]
0000ae  2304              MOVS     r3,#4
0000b0  401a              ANDS     r2,r2,r3
0000b2  2a04              CMP      r2,#4
0000b4  d000              BEQ      |L1.184|
;;;211           /* 0 Regulator is in stop regulation or in transition 
;;;212                to/from it
;;;213              1 MCU is in Run regulation mode */
;;;214          }  
;;;215          else  break;
0000b6  e003              B        |L1.192|
                  |L1.184|
0000b8  1c49              ADDS     r1,r1,#1              ;207
                  |L1.186|
0000ba  4aac              LDR      r2,|L1.876|
0000bc  4291              CMP      r1,r2                 ;207
0000be  dbf4              BLT      |L1.170|
                  |L1.192|
0000c0  bf00              NOP      
;;;216        }  
;;;217      if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) ==0x04) 
0000c2  4aa9              LDR      r2,|L1.872|
0000c4  7892              LDRB     r2,[r2,#2]
0000c6  2304              MOVS     r3,#4
0000c8  401a              ANDS     r2,r2,r3
0000ca  2a04              CMP      r2,#4
0000cc  d100              BNE      |L1.208|
;;;218        {  
;;;219          return_value = 0x24; 
0000ce  2024              MOVS     r0,#0x24
                  |L1.208|
;;;220        }
;;;221      /* SMC_PMSTAT register only exist in Mode Controller 2 MCU versions */
;;;222      if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK) == 4)  
0000d0  4aa4              LDR      r2,|L1.868|
0000d2  78d2              LDRB     r2,[r2,#3]
0000d4  0652              LSLS     r2,r2,#25
0000d6  0e52              LSRS     r2,r2,#25
0000d8  2a04              CMP      r2,#4
0000da  d101              BNE      |L1.224|
;;;223        {
;;;224          return_value = SMC_PMSTAT;
0000dc  4aa1              LDR      r2,|L1.868|
0000de  78d0              LDRB     r0,[r2,#3]
                  |L1.224|
;;;225        }
;;;226      return (return_value);
;;;227    }
0000e0  4770              BX       lr
;;;228    /********************************************************************/
                          ENDP

                  exit_vlpr PROC
;;;240    
;;;241    void exit_vlpr(void)
0000e2  49a0              LDR      r1,|L1.868|
;;;242    {
;;;243        int i;
;;;244        /* check to make sure in VLPR before exiting    */
;;;245        if  ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4) {
0000e4  78c9              LDRB     r1,[r1,#3]
0000e6  0649              LSLS     r1,r1,#25
0000e8  0e49              LSRS     r1,r1,#25
0000ea  2904              CMP      r1,#4
0000ec  d118              BNE      |L1.288|
;;;246          
;;;247           /* Clear RUNM */
;;;248           SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;
0000ee  499d              LDR      r1,|L1.868|
0000f0  7849              LDRB     r1,[r1,#1]
0000f2  2260              MOVS     r2,#0x60
0000f4  4391              BICS     r1,r1,r2
0000f6  4a9b              LDR      r2,|L1.868|
0000f8  7051              STRB     r1,[r2,#1]
;;;249                          
;;;250           /* Wait for normal RUN regulation mode to be confirmed */                   
;;;251           // 1 PMSTAT MCU is in RUN  mode
;;;252           // 4 PMSTAT MCU is in VLPR mode
;;;253           for (i=0;i<0xff;i++)
0000fa  2000              MOVS     r0,#0
0000fc  e00d              B        |L1.282|
                  |L1.254|
;;;254           {
;;;255               if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
0000fe  4999              LDR      r1,|L1.868|
000100  78c9              LDRB     r1,[r1,#3]
000102  0649              LSLS     r1,r1,#25
000104  0e49              LSRS     r1,r1,#25
000106  2901              CMP      r1,#1
000108  d106              BNE      |L1.280|
;;;256                 if ((PMC_REGSC & PMC_REGSC_REGONS_MASK) == 1)
00010a  4997              LDR      r1,|L1.872|
00010c  7889              LDRB     r1,[r1,#2]
00010e  2204              MOVS     r2,#4
000110  4011              ANDS     r1,r1,r2
000112  2901              CMP      r1,#1
000114  d100              BNE      |L1.280|
;;;257        	        break;
000116  e002              B        |L1.286|
                  |L1.280|
000118  1c40              ADDS     r0,r0,#1              ;253
                  |L1.282|
00011a  28ff              CMP      r0,#0xff              ;253
00011c  dbef              BLT      |L1.254|
                  |L1.286|
00011e  bf00              NOP      
                  |L1.288|
;;;258           }           
;;;259        }  //if in VLPR mode
;;;260         // else if not in VLPR ignore call
;;;261    }
000120  4770              BX       lr
;;;262    /***************************************************************/
                          ENDP

                  enter_vlps PROC
;;;278    
;;;279    void enter_vlps(void)
000122  b508              PUSH     {r3,lr}
;;;280    {
;;;281      volatile unsigned int dummyread;
;;;282      /* The PMPROT register may have already been written by init code
;;;283         If so then this next write is not done since  
;;;284         PMPROT is write once after RESET 
;;;285         allows the MCU to enter the VLPR, VLPW, and VLPS modes.
;;;286         If AVLP is already writen to 0 
;;;287         Stop is entered instead of VLPS*/
;;;288      SMC_PMPROT = SMC_PMPROT_AVLP_MASK;           
000124  2020              MOVS     r0,#0x20
000126  498f              LDR      r1,|L1.868|
000128  7008              STRB     r0,[r1,#0]
;;;289      /* Set the STOPM field to 0b010 for VLPS mode */
;;;290      SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
00012a  4608              MOV      r0,r1
00012c  7840              LDRB     r0,[r0,#1]
00012e  08c0              LSRS     r0,r0,#3
000130  00c0              LSLS     r0,r0,#3
000132  7048              STRB     r0,[r1,#1]
;;;291      SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x2); 
000134  4608              MOV      r0,r1
000136  7840              LDRB     r0,[r0,#1]
000138  2102              MOVS     r1,#2
00013a  4308              ORRS     r0,r0,r1
00013c  4989              LDR      r1,|L1.868|
00013e  7048              STRB     r0,[r1,#1]
;;;292      /*wait for write to complete to SMC before stopping core */  
;;;293      dummyread = SMC_PMCTRL;
000140  4608              MOV      r0,r1
000142  7840              LDRB     r0,[r0,#1]
000144  9000              STR      r0,[sp,#0]
;;;294      dummyread = dummyread + 1;
000146  9800              LDR      r0,[sp,#0]
000148  1c40              ADDS     r0,r0,#1
00014a  9000              STR      r0,[sp,#0]
;;;295      /* Now execute the stop instruction to go into VLPS */
;;;296      #ifdef CMSIS
;;;297      /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
;;;298      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
00014c  4884              LDR      r0,|L1.864|
00014e  6900              LDR      r0,[r0,#0x10]
000150  2104              MOVS     r1,#4
000152  4308              ORRS     r0,r0,r1
000154  4982              LDR      r1,|L1.864|
000156  6108              STR      r0,[r1,#0x10]
;;;299      __wfi();
000158  bf30              WFI      
;;;300    #else
;;;301      stop();
;;;302    #endif
;;;303    }
00015a  bd08              POP      {r3,pc}
;;;304    /****************************************************************/
                          ENDP

                  enter_lls PROC
;;;324    
;;;325    void enter_lls(void)
00015c  b508              PUSH     {r3,lr}
;;;326    {
;;;327      volatile unsigned int dummyread;
;;;328      /* Write to PMPROT to allow LLS power modes this write-once 
;;;329         bit allows the MCU to enter the LLS low power mode*/
;;;330      SMC_PMPROT = SMC_PMPROT_ALLS_MASK;   
00015e  2008              MOVS     r0,#8
000160  4980              LDR      r1,|L1.868|
000162  7008              STRB     r0,[r1,#0]
;;;331      /* Set the STOPM field to 0b011 for LLS mode  */
;;;332      SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
000164  4608              MOV      r0,r1
000166  7840              LDRB     r0,[r0,#1]
000168  08c0              LSRS     r0,r0,#3
00016a  00c0              LSLS     r0,r0,#3
00016c  7048              STRB     r0,[r1,#1]
;;;333      SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x3); 
00016e  4608              MOV      r0,r1
000170  7840              LDRB     r0,[r0,#1]
000172  2103              MOVS     r1,#3
000174  4308              ORRS     r0,r0,r1
000176  497b              LDR      r1,|L1.868|
000178  7048              STRB     r0,[r1,#1]
;;;334      /*wait for write to complete to SMC before stopping core */  
;;;335      dummyread = SMC_PMCTRL;
00017a  4608              MOV      r0,r1
00017c  7840              LDRB     r0,[r0,#1]
00017e  9000              STR      r0,[sp,#0]
;;;336      dummyread = dummyread + 1;
000180  9800              LDR      r0,[sp,#0]
000182  1c40              ADDS     r0,r0,#1
000184  9000              STR      r0,[sp,#0]
;;;337      /* Now execute the stop instruction to go into LLS */
;;;338      #ifdef CMSIS
;;;339      /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
;;;340      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
000186  4876              LDR      r0,|L1.864|
000188  6900              LDR      r0,[r0,#0x10]
00018a  2104              MOVS     r1,#4
00018c  4308              ORRS     r0,r0,r1
00018e  4974              LDR      r1,|L1.864|
000190  6108              STR      r0,[r1,#0x10]
;;;341      __wfi();
000192  bf30              WFI      
;;;342    #else
;;;343      stop();
;;;344    #endif
;;;345    }
000194  bd08              POP      {r3,pc}
;;;346    /***************************************************************/
                          ENDP

                  enter_vlls3 PROC
;;;366    
;;;367    void enter_vlls3(void)
000196  b508              PUSH     {r3,lr}
;;;368    {
;;;369      volatile unsigned int dummyread;
;;;370      /* Write to PMPROT to allow VLLS3 power modes */
;;;371      SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;      
000198  2002              MOVS     r0,#2
00019a  4972              LDR      r1,|L1.868|
00019c  7008              STRB     r0,[r1,#0]
;;;372      /* Set the STOPM field to 0b100 for VLLS3 mode */
;;;373      SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
00019e  4608              MOV      r0,r1
0001a0  7840              LDRB     r0,[r0,#1]
0001a2  08c0              LSRS     r0,r0,#3
0001a4  00c0              LSLS     r0,r0,#3
0001a6  7048              STRB     r0,[r1,#1]
;;;374      SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
0001a8  4608              MOV      r0,r1
0001aa  7840              LDRB     r0,[r0,#1]
0001ac  2104              MOVS     r1,#4
0001ae  4308              ORRS     r0,r0,r1
0001b0  496c              LDR      r1,|L1.868|
0001b2  7048              STRB     r0,[r1,#1]
;;;375      /* set VLLSM = 0b11 */
;;;376      SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(3);          
0001b4  2003              MOVS     r0,#3
0001b6  7088              STRB     r0,[r1,#2]
;;;377      /*wait for write to complete to SMC before stopping core */  
;;;378      dummyread = SMC_STOPCTRL;
0001b8  4608              MOV      r0,r1
0001ba  7880              LDRB     r0,[r0,#2]
0001bc  9000              STR      r0,[sp,#0]
;;;379      dummyread = dummyread + 1;
0001be  9800              LDR      r0,[sp,#0]
0001c0  1c40              ADDS     r0,r0,#1
0001c2  9000              STR      r0,[sp,#0]
;;;380      /* Now execute the stop instruction to go into VLLS3 */
;;;381      #ifdef CMSIS
;;;382      /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
;;;383      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
0001c4  4866              LDR      r0,|L1.864|
0001c6  6900              LDR      r0,[r0,#0x10]
0001c8  2104              MOVS     r1,#4
0001ca  4308              ORRS     r0,r0,r1
0001cc  4964              LDR      r1,|L1.864|
0001ce  6108              STR      r0,[r1,#0x10]
;;;384      __wfi();
0001d0  bf30              WFI      
;;;385    #else
;;;386      stop();
;;;387    #endif
;;;388    }
0001d2  bd08              POP      {r3,pc}
;;;389    /***************************************************************/
                          ENDP

                  enter_vlls2 PROC
;;;409    
;;;410    void enter_vlls2(void)
0001d4  b508              PUSH     {r3,lr}
;;;411    {
;;;412      volatile unsigned int dummyread;
;;;413      /* Write to PMPROT to allow VLLS2 power modes */
;;;414      SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;      
0001d6  2002              MOVS     r0,#2
0001d8  4962              LDR      r1,|L1.868|
0001da  7008              STRB     r0,[r1,#0]
;;;415      /* Set the STOPM field to 0b100 for VLLS2 mode */
;;;416      SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
0001dc  4608              MOV      r0,r1
0001de  7840              LDRB     r0,[r0,#1]
0001e0  08c0              LSRS     r0,r0,#3
0001e2  00c0              LSLS     r0,r0,#3
0001e4  7048              STRB     r0,[r1,#1]
;;;417      SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
0001e6  4608              MOV      r0,r1
0001e8  7840              LDRB     r0,[r0,#1]
0001ea  2104              MOVS     r1,#4
0001ec  4308              ORRS     r0,r0,r1
0001ee  495d              LDR      r1,|L1.868|
0001f0  7048              STRB     r0,[r1,#1]
;;;418      /* set VLLSM = 0b10 */
;;;419      SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(2);                
0001f2  2002              MOVS     r0,#2
0001f4  7088              STRB     r0,[r1,#2]
;;;420      /*wait for write to complete to SMC before stopping core */  
;;;421      dummyread = SMC_STOPCTRL;
0001f6  4608              MOV      r0,r1
0001f8  7880              LDRB     r0,[r0,#2]
0001fa  9000              STR      r0,[sp,#0]
;;;422      dummyread = dummyread + 1;
0001fc  9800              LDR      r0,[sp,#0]
0001fe  1c40              ADDS     r0,r0,#1
000200  9000              STR      r0,[sp,#0]
;;;423      /* Now execute the stop instruction to go into VLLS2 */
;;;424      #ifdef CMSIS
;;;425      /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
;;;426      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
000202  4857              LDR      r0,|L1.864|
000204  6900              LDR      r0,[r0,#0x10]
000206  2104              MOVS     r1,#4
000208  4308              ORRS     r0,r0,r1
00020a  4955              LDR      r1,|L1.864|
00020c  6108              STR      r0,[r1,#0x10]
;;;427      __wfi();
00020e  bf30              WFI      
;;;428    #else
;;;429      stop();
;;;430    #endif
;;;431    }
000210  bd08              POP      {r3,pc}
;;;432    /***************************************************************/
                          ENDP

                  enter_vlls1 PROC
;;;452    
;;;453    void enter_vlls1(void)
000212  b508              PUSH     {r3,lr}
;;;454    {
;;;455      volatile unsigned int dummyread;
;;;456      SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;
000214  2002              MOVS     r0,#2
000216  4953              LDR      r1,|L1.868|
000218  7008              STRB     r0,[r1,#0]
;;;457        
;;;458      /* Write to PMPROT to allow all possible power modes */
;;;459      /* Set the STOPM field to 0b100 for VLLS1 mode */
;;;460      SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
00021a  4608              MOV      r0,r1
00021c  7840              LDRB     r0,[r0,#1]
00021e  08c0              LSRS     r0,r0,#3
000220  00c0              LSLS     r0,r0,#3
000222  7048              STRB     r0,[r1,#1]
;;;461      SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
000224  4608              MOV      r0,r1
000226  7840              LDRB     r0,[r0,#1]
000228  2104              MOVS     r1,#4
00022a  4308              ORRS     r0,r0,r1
00022c  494d              LDR      r1,|L1.868|
00022e  7048              STRB     r0,[r1,#1]
;;;462      /* set VLLSM = 0b01 */
;;;463      SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(1);          
000230  2001              MOVS     r0,#1
000232  7088              STRB     r0,[r1,#2]
;;;464      /*wait for write to complete to SMC before stopping core */  
;;;465      dummyread = SMC_STOPCTRL;
000234  4608              MOV      r0,r1
000236  7880              LDRB     r0,[r0,#2]
000238  9000              STR      r0,[sp,#0]
;;;466      dummyread = dummyread + 1;
00023a  9800              LDR      r0,[sp,#0]
00023c  1c40              ADDS     r0,r0,#1
00023e  9000              STR      r0,[sp,#0]
;;;467      /* Now execute the stop instruction to go into VLLS1 */
;;;468      #ifdef CMSIS
;;;469      /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
;;;470      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
000240  4847              LDR      r0,|L1.864|
000242  6900              LDR      r0,[r0,#0x10]
000244  2104              MOVS     r1,#4
000246  4308              ORRS     r0,r0,r1
000248  4945              LDR      r1,|L1.864|
00024a  6108              STR      r0,[r1,#0x10]
;;;471      __wfi();
00024c  bf30              WFI      
;;;472    #else
;;;473      stop();
;;;474    #endif
;;;475    }
00024e  bd08              POP      {r3,pc}
;;;476    
                          ENDP

                  enter_vlls0 PROC
;;;498    
;;;499    void enter_vlls0(unsigned char PORPO_value )
000250  b508              PUSH     {r3,lr}
;;;500    {
000252  4601              MOV      r1,r0
;;;501      volatile unsigned int dummyread;
;;;502      int i;
;;;503      /* Write to PMPROT to allow all possible power modes */
;;;504      SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;   
000254  2202              MOVS     r2,#2
000256  4b43              LDR      r3,|L1.868|
000258  701a              STRB     r2,[r3,#0]
;;;505      if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
00025a  461a              MOV      r2,r3
00025c  78d2              LDRB     r2,[r2,#3]
00025e  0652              LSLS     r2,r2,#25
000260  0e52              LSRS     r2,r2,#25
000262  2a04              CMP      r2,#4
000264  d112              BNE      |L1.652|
;;;506         SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;   // go back to RUN mode temporarily
000266  461a              MOV      r2,r3
000268  7852              LDRB     r2,[r2,#1]
00026a  2360              MOVS     r3,#0x60
00026c  439a              BICS     r2,r2,r3
00026e  4b3d              LDR      r3,|L1.868|
000270  705a              STRB     r2,[r3,#1]
;;;507         for (i=0;i<0xff;i++)
000272  2000              MOVS     r0,#0
000274  e007              B        |L1.646|
                  |L1.630|
;;;508           {
;;;509           if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
000276  4a3b              LDR      r2,|L1.868|
000278  78d2              LDRB     r2,[r2,#3]
00027a  0652              LSLS     r2,r2,#25
00027c  0e52              LSRS     r2,r2,#25
00027e  2a01              CMP      r2,#1
000280  d100              BNE      |L1.644|
;;;510        	 break;
000282  e002              B        |L1.650|
                  |L1.644|
000284  1c40              ADDS     r0,r0,#1              ;507
                  |L1.646|
000286  28ff              CMP      r0,#0xff              ;507
000288  dbf5              BLT      |L1.630|
                  |L1.650|
00028a  bf00              NOP      
                  |L1.652|
;;;511           }
;;;512      }
;;;513      /* Set the STOPM field to 0b100 for VLLS0 mode */
;;;514      SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
00028c  4a35              LDR      r2,|L1.868|
00028e  7852              LDRB     r2,[r2,#1]
000290  08d2              LSRS     r2,r2,#3
000292  00d2              LSLS     r2,r2,#3
000294  4b33              LDR      r3,|L1.868|
000296  705a              STRB     r2,[r3,#1]
;;;515      SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
000298  461a              MOV      r2,r3
00029a  7852              LDRB     r2,[r2,#1]
00029c  2304              MOVS     r3,#4
00029e  431a              ORRS     r2,r2,r3
0002a0  4b30              LDR      r3,|L1.868|
0002a2  705a              STRB     r2,[r3,#1]
;;;516      /* set VLLSM = 0b00 */
;;;517      SMC_STOPCTRL &= ~SMC_STOPCTRL_VLLSM_MASK;
0002a4  461a              MOV      r2,r3
0002a6  7892              LDRB     r2,[r2,#2]
0002a8  08d2              LSRS     r2,r2,#3
0002aa  00d2              LSLS     r2,r2,#3
0002ac  709a              STRB     r2,[r3,#2]
;;;518      SMC_STOPCTRL &= ~SMC_STOPCTRL_PORPO_MASK;
0002ae  461a              MOV      r2,r3
0002b0  7892              LDRB     r2,[r2,#2]
0002b2  2320              MOVS     r3,#0x20
0002b4  439a              BICS     r2,r2,r3
0002b6  4b2b              LDR      r3,|L1.868|
0002b8  709a              STRB     r2,[r3,#2]
;;;519      SMC_STOPCTRL |=  (PORPO_value <<SMC_STOPCTRL_PORPO_SHIFT) 
0002ba  461a              MOV      r2,r3
0002bc  7892              LDRB     r2,[r2,#2]
0002be  014b              LSLS     r3,r1,#5
0002c0  431a              ORRS     r2,r2,r3
0002c2  4b28              LDR      r3,|L1.868|
0002c4  709a              STRB     r2,[r3,#2]
;;;520                     | SMC_STOPCTRL_VLLSM(0);          
;;;521      /*wait for write to complete to SMC before stopping core */  
;;;522      dummyread = SMC_STOPCTRL;
0002c6  461a              MOV      r2,r3
0002c8  7892              LDRB     r2,[r2,#2]
0002ca  9200              STR      r2,[sp,#0]
;;;523      dummyread = dummyread + 1;
0002cc  9a00              LDR      r2,[sp,#0]
0002ce  1c52              ADDS     r2,r2,#1
0002d0  9200              STR      r2,[sp,#0]
;;;524      /* Now execute the stop instruction to go into VLLS0 */
;;;525      #ifdef CMSIS
;;;526      /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
;;;527      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
0002d2  4a23              LDR      r2,|L1.864|
0002d4  6912              LDR      r2,[r2,#0x10]
0002d6  2304              MOVS     r3,#4
0002d8  431a              ORRS     r2,r2,r3
0002da  4b21              LDR      r3,|L1.864|
0002dc  611a              STR      r2,[r3,#0x10]
;;;528      __wfi();
0002de  bf30              WFI      
;;;529    #else
;;;530      stop();
;;;531    #endif
;;;532    }
0002e0  bd08              POP      {r3,pc}
;;;533    /***************************************************************/
                          ENDP

                  enter_vlls0_nopor PROC
;;;552    /***************************************************************/
;;;553    void enter_vlls0_nopor(void)
0002e2  b508              PUSH     {r3,lr}
;;;554    {
;;;555      volatile unsigned int dummyread;
;;;556      int i;
;;;557      /* Write to PMPROT to allow all possible power modes */
;;;558      SMC_PMPROT = SMC_PMPROT_AVLLS_MASK;   
0002e4  2102              MOVS     r1,#2
0002e6  4a1f              LDR      r2,|L1.868|
0002e8  7011              STRB     r1,[r2,#0]
;;;559      if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 4){
0002ea  4611              MOV      r1,r2
0002ec  78c9              LDRB     r1,[r1,#3]
0002ee  0649              LSLS     r1,r1,#25
0002f0  0e49              LSRS     r1,r1,#25
0002f2  2904              CMP      r1,#4
0002f4  d112              BNE      |L1.796|
;;;560         SMC_PMCTRL &= ~SMC_PMCTRL_RUNM_MASK;   // go back to RUN mode temporarily
0002f6  4611              MOV      r1,r2
0002f8  7849              LDRB     r1,[r1,#1]
0002fa  2260              MOVS     r2,#0x60
0002fc  4391              BICS     r1,r1,r2
0002fe  4a19              LDR      r2,|L1.868|
000300  7051              STRB     r1,[r2,#1]
;;;561         for (i=0;i<0xff;i++)
000302  2000              MOVS     r0,#0
000304  e007              B        |L1.790|
                  |L1.774|
;;;562           {
;;;563           if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK)== 1)
000306  4917              LDR      r1,|L1.868|
000308  78c9              LDRB     r1,[r1,#3]
00030a  0649              LSLS     r1,r1,#25
00030c  0e49              LSRS     r1,r1,#25
00030e  2901              CMP      r1,#1
000310  d100              BNE      |L1.788|
;;;564        	 break;
000312  e002              B        |L1.794|
                  |L1.788|
000314  1c40              ADDS     r0,r0,#1              ;561
                  |L1.790|
000316  28ff              CMP      r0,#0xff              ;561
000318  dbf5              BLT      |L1.774|
                  |L1.794|
00031a  bf00              NOP      
                  |L1.796|
;;;565           }
;;;566      }
;;;567      /* Set the STOPM field to 0b100 for VLLS0 mode */
;;;568      SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
00031c  4911              LDR      r1,|L1.868|
00031e  7849              LDRB     r1,[r1,#1]
000320  08c9              LSRS     r1,r1,#3
000322  00c9              LSLS     r1,r1,#3
000324  4a0f              LDR      r2,|L1.868|
000326  7051              STRB     r1,[r2,#1]
;;;569      SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x4); 
000328  4611              MOV      r1,r2
00032a  7849              LDRB     r1,[r1,#1]
00032c  2204              MOVS     r2,#4
00032e  4311              ORRS     r1,r1,r2
000330  4a0c              LDR      r2,|L1.868|
000332  7051              STRB     r1,[r2,#1]
;;;570      /* set VLLSM = 00 * and PORPO = 1 */
;;;571      SMC_STOPCTRL &= ~SMC_STOPCTRL_VLLSM_MASK;
000334  4611              MOV      r1,r2
000336  7889              LDRB     r1,[r1,#2]
000338  08c9              LSRS     r1,r1,#3
00033a  00c9              LSLS     r1,r1,#3
00033c  7091              STRB     r1,[r2,#2]
;;;572      SMC_STOPCTRL =  SMC_STOPCTRL_VLLSM(0) | SMC_STOPCTRL_PORPO_MASK;  
00033e  2120              MOVS     r1,#0x20
000340  7091              STRB     r1,[r2,#2]
;;;573      /*wait for write to complete to SMC before stopping core */  
;;;574      dummyread = SMC_STOPCTRL;
000342  4611              MOV      r1,r2
000344  7889              LDRB     r1,[r1,#2]
000346  9100              STR      r1,[sp,#0]
;;;575      dummyread = dummyread + 1;
000348  9900              LDR      r1,[sp,#0]
00034a  1c49              ADDS     r1,r1,#1
00034c  9100              STR      r1,[sp,#0]
;;;576      /* Now execute the stop instruction to go into VLLS0 */
;;;577      #ifdef CMSIS
;;;578      /* Set the SLEEPDEEP bit to enable deep sleep mode (STOP) */
;;;579      SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
00034e  4904              LDR      r1,|L1.864|
000350  6909              LDR      r1,[r1,#0x10]
000352  2204              MOVS     r2,#4
000354  4311              ORRS     r1,r1,r2
000356  4a02              LDR      r2,|L1.864|
000358  6111              STR      r1,[r2,#0x10]
;;;580      __wfi();
00035a  bf30              WFI      
;;;581    #else
;;;582      stop();
;;;583    #endif
;;;584    }
00035c  bd08              POP      {r3,pc}
;;;585    
                          ENDP

00035e  0000              DCW      0x0000
                  |L1.864|
                          DCD      0xe000ed00
                  |L1.868|
                          DCD      0x4007e000
                  |L1.872|
                          DCD      0x4007d000
                  |L1.876|
                          DCD      0x00002710

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\drivers\\smc\\smc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_smc_c_sleep____REV16|
#line 388 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.5.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_smc_c_sleep____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_smc_c_sleep____REVSH|
#line 402
|__asm___5_smc_c_sleep____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
