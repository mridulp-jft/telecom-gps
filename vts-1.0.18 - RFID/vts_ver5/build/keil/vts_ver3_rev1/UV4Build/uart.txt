; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\uart.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\uart.d --cpu=Cortex-M0+ --apcs=interwork -O0 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -IC:\Keil_v5\ARM\RV31\Inc -IC:\Users\Mridul\Desktop\vts_ver5\build\keil\vts_ver3_rev1\RTE -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.5.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__RTX -D__MICROLIB -DMKL26Z128xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\uart.crf ..\..\..\src\drivers\uart\uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;31      */
;;;32     void uart_init (UART_MemMapPtr uartch, int sysclk, int baud)
000000  b5f8              PUSH     {r3-r7,lr}
;;;33     {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;34         register uint16 sbr;
;;;35         uint8 temp;
;;;36      
;;;37           if (uartch == UART1_BASE_PTR)
000008  489b              LDR      r0,|L1.632|
00000a  4284              CMP      r4,r0
00000c  d106              BNE      |L1.28|
;;;38             SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
00000e  489b              LDR      r0,|L1.636|
000010  6b40              LDR      r0,[r0,#0x34]
000012  14e1              ASRS     r1,r4,#19
000014  4308              ORRS     r0,r0,r1
000016  4999              LDR      r1,|L1.636|
000018  6348              STR      r0,[r1,#0x34]
00001a  e006              B        |L1.42|
                  |L1.28|
;;;39           else
;;;40         	SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
00001c  4897              LDR      r0,|L1.636|
00001e  6b40              LDR      r0,[r0,#0x34]
000020  2101              MOVS     r1,#1
000022  0309              LSLS     r1,r1,#12
000024  4308              ORRS     r0,r0,r1
000026  4995              LDR      r1,|L1.636|
000028  6348              STR      r0,[r1,#0x34]
                  |L1.42|
;;;41           /* Make sure that the transmitter and receiver are disabled while we 
;;;42            * change settings.
;;;43            */
;;;44           UART_C2_REG(uartch) &= ~(UART_C2_TE_MASK
00002a  78e0              LDRB     r0,[r4,#3]
00002c  210c              MOVS     r1,#0xc
00002e  4388              BICS     r0,r0,r1
000030  70e0              STRB     r0,[r4,#3]
;;;45     				| UART_C2_RE_MASK );
;;;46     			
;;;47     				      /* Configure the uart for 8-bit mode, no parity */
;;;48           UART_C1_REG(uartch) = 0;	/* We need all default settings, so entire register is cleared */
000032  2000              MOVS     r0,#0
000034  70a0              STRB     r0,[r4,#2]
;;;49         
;;;50           /* Calculate baud settings */
;;;51           sbr = (uint16)((sysclk*1000)/(baud * 16));
000036  0139              LSLS     r1,r7,#4
000038  227d              MOVS     r2,#0x7d
00003a  00d2              LSLS     r2,r2,#3
00003c  4372              MULS     r2,r6,r2
00003e  4610              MOV      r0,r2
000040  f7fffffe          BL       __aeabi_idivmod
000044  b285              UXTH     r5,r0
;;;52     	//		sbr = sy/baud(OSR+1);
;;;53     			//sbr = 
;;;54             
;;;55           /* Save off the current value of the uartx_BDH except for the SBR field */
;;;56           temp = UART_BDH_REG(uartch) & ~(UART_BDH_SBR(0x1F));
000046  7820              LDRB     r0,[r4,#0]
000048  0941              LSRS     r1,r0,#5
00004a  0149              LSLS     r1,r1,#5
00004c  9100              STR      r1,[sp,#0]
;;;57         
;;;58           UART_BDH_REG(uartch) = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
00004e  201f              MOVS     r0,#0x1f
000050  0200              LSLS     r0,r0,#8
000052  4028              ANDS     r0,r0,r5
000054  1200              ASRS     r0,r0,#8
000056  9900              LDR      r1,[sp,#0]
000058  4308              ORRS     r0,r0,r1
00005a  7020              STRB     r0,[r4,#0]
;;;59           UART_BDL_REG(uartch) = (uint8)(sbr & UART_BDL_SBR_MASK);
00005c  7065              STRB     r5,[r4,#1]
;;;60     			
;;;61     			
;;;62     			UART_C2_REG(uartch) |= UART_C2_RIE_MASK;			//newly added
00005e  78e0              LDRB     r0,[r4,#3]
000060  2120              MOVS     r1,#0x20
000062  4308              ORRS     r0,r0,r1
000064  70e0              STRB     r0,[r4,#3]
;;;63     			
;;;64     
;;;65     		
;;;66     			enable_irq(13);	
000066  200d              MOVS     r0,#0xd
000068  2101              MOVS     r1,#1
00006a  4081              LSLS     r1,r1,r0
00006c  4a84              LDR      r2,|L1.640|
00006e  6011              STR      r1,[r2,#0]
000070  bf00              NOP      
;;;67     
;;;68     			EnableInterrupts;		//newly added
000072  b662              CPSIE    i
;;;69          		
;;;70     
;;;71     
;;;72     
;;;73     
;;;74           /* Enable receiver and transmitter */
;;;75           UART_C2_REG(uartch) |= (UART_C2_TE_MASK
000074  78e0              LDRB     r0,[r4,#3]
000076  210c              MOVS     r1,#0xc
000078  4308              ORRS     r0,r0,r1
00007a  70e0              STRB     r0,[r4,#3]
;;;76     	    		  | UART_C2_RE_MASK );
;;;77     		
;;;78     
;;;79     
;;;80     }
00007c  bdf8              POP      {r3-r7,pc}
;;;81     
                          ENDP

                  uart_getchar_present PROC
;;;161     */
;;;162    int uart_getchar_present (UART_MemMapPtr channel)
00007e  4601              MOV      r1,r0
;;;163    {
;;;164        return (UART_S1_REG(channel) & UART_S1_RDRF_MASK);
000080  7908              LDRB     r0,[r1,#4]
000082  2220              MOVS     r2,#0x20
000084  4010              ANDS     r0,r0,r2
;;;165    }
000086  4770              BX       lr
;;;166    /********************************************************************/
                          ENDP

                  UART1_IRQHandler PROC
;;;81     
;;;82     void UART1_IRQHandler(void)
000088  b500              PUSH     {lr}
;;;83     {int counter=19999;
00008a  4b7e              LDR      r3,|L1.644|
;;;84     
;;;85     			do{
00008c  bf00              NOP      
                  |L1.142|
;;;86     			if( uart_getchar_present (UART1_BASE_PTR))	
00008e  487a              LDR      r0,|L1.632|
000090  f7fffffe          BL       uart_getchar_present
000094  2800              CMP      r0,#0
000096  d00c              BEQ      |L1.178|
;;;87     			{uart_string_gsm[k2]=UART_D_REG(UART1_BASE_PTR);k2++;
000098  4877              LDR      r0,|L1.632|
00009a  79c0              LDRB     r0,[r0,#7]
00009c  497a              LDR      r1,|L1.648|
00009e  4a7b              LDR      r2,|L1.652|
0000a0  6812              LDR      r2,[r2,#0]  ; k2
0000a2  5488              STRB     r0,[r1,r2]
0000a4  4879              LDR      r0,|L1.652|
0000a6  6800              LDR      r0,[r0,#0]  ; k2
0000a8  1c40              ADDS     r0,r0,#1
0000aa  4978              LDR      r1,|L1.652|
0000ac  6008              STR      r0,[r1,#0]  ; k2
;;;88     				counter=19999;
0000ae  4b75              LDR      r3,|L1.644|
0000b0  e000              B        |L1.180|
                  |L1.178|
;;;89     		//	if(k2>4990)k2=0;
;;;90     			}
;;;91     				else{counter--;
0000b2  1e5b              SUBS     r3,r3,#1
                  |L1.180|
;;;92     						}
;;;93     			}while(uart_getchar_present (UART1_BASE_PTR)  || (counter>1));
0000b4  4870              LDR      r0,|L1.632|
0000b6  f7fffffe          BL       uart_getchar_present
0000ba  2800              CMP      r0,#0
0000bc  d1e7              BNE      |L1.142|
0000be  2b01              CMP      r3,#1
0000c0  dce5              BGT      |L1.142|
;;;94     			
;;;95     }
0000c2  bd00              POP      {pc}
;;;96     
                          ENDP

                  UART2_IRQHandler PROC
;;;97     void UART2_IRQHandler(void)
0000c4  4770              BX       lr
;;;98     {
;;;99     //k=0;l=999999;
;;;100    //			do{
;;;101    //			if( uart_getchar_present (UART2_BASE_PTR))	
;;;102    //			{uart_string_gps[k]=UART_D_REG(UART2_BASE_PTR);k++;l=9999;if(k>298){k=0;}}
;;;103    //				else{
;;;104    //							l--;if(l==10){}
;;;105    //						}
;;;106    //			}while(!((strstr(uart_string_gps, "OK\r\n"))
;;;107    //							||(strstr(uart_string_gps, "ERROR\r\n"))  || (l<=0)
;;;108    //				        	||(strstr(uart_string_gps, "ERROR:"))
;;;109    //							));
;;;110    //printf("uart_string_gps -> %s",uart_string_gps);
;;;111    }
;;;112    
                          ENDP

                  uart_getchar PROC
;;;125     */
;;;126    char uart_getchar (UART_MemMapPtr channel)
0000c6  4601              MOV      r1,r0
;;;127    {int timeouttt=199;
0000c8  22c7              MOVS     r2,#0xc7
;;;128          /* Wait until character has been received */
;;;129          while (!((UART_S1_REG(channel) & UART_S1_RDRF_MASK)    ));//{timeouttt--;}
0000ca  bf00              NOP      
                  |L1.204|
0000cc  7908              LDRB     r0,[r1,#4]
0000ce  2320              MOVS     r3,#0x20
0000d0  4018              ANDS     r0,r0,r3
0000d2  2800              CMP      r0,#0
0000d4  d0fa              BEQ      |L1.204|
;;;130     //   ||   (timeouttt < 1 ) 
;;;131          /* Return the 8-bit data from the receiver */
;;;132          return UART_D_REG(channel);
0000d6  79c8              LDRB     r0,[r1,#7]
;;;133    }
0000d8  4770              BX       lr
;;;134    /********************************************************************/
                          ENDP

                  uart_putchar PROC
;;;141     */ 
;;;142    void uart_putchar (UART_MemMapPtr channel, char ch)
0000da  b510              PUSH     {r4,lr}
;;;143    {int to=19999;
0000dc  4a69              LDR      r2,|L1.644|
;;;144          /* Wait until space is available in the FIFO */
;;;145          while(!((UART_S1_REG(channel) & UART_S1_TDRE_MASK)    ||  ( to <= 1 ))){to--;}
0000de  e000              B        |L1.226|
                  |L1.224|
0000e0  1e52              SUBS     r2,r2,#1
                  |L1.226|
0000e2  7903              LDRB     r3,[r0,#4]
0000e4  2480              MOVS     r4,#0x80
0000e6  4023              ANDS     r3,r3,r4
0000e8  2b00              CMP      r3,#0
0000ea  d101              BNE      |L1.240|
0000ec  2a01              CMP      r2,#1
0000ee  dcf7              BGT      |L1.224|
                  |L1.240|
;;;146        
;;;147          /* Send the character */
;;;148          UART_D_REG(channel) = (uint8)ch;
0000f0  71c1              STRB     r1,[r0,#7]
;;;149        
;;;150     }
0000f2  bd10              POP      {r4,pc}
;;;151    /********************************************************************/
                          ENDP

                  uart0_init PROC
;;;184     */
;;;185    void uart0_init (UART0_MemMapPtr uartch, int sysclk, int baud)
0000f4  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;186    {
0000f6  b086              SUB      sp,sp,#0x18
;;;187        uint8 i;
;;;188        uint32 calculated_baud = 0;
0000f8  bf00              NOP      
;;;189        uint32 baud_diff = 0;
0000fa  2000              MOVS     r0,#0
0000fc  9005              STR      r0,[sp,#0x14]
;;;190        uint32 osr_val = 0;
0000fe  9004              STR      r0,[sp,#0x10]
;;;191        uint32 sbr_val, uart0clk;
;;;192        uint32 baud_rate;
;;;193        uint32 reg_temp = 0;
000100  2500              MOVS     r5,#0
;;;194        uint32 temp = 0;
000102  9001              STR      r0,[sp,#4]
;;;195        
;;;196        SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
000104  485d              LDR      r0,|L1.636|
000106  6b40              LDR      r0,[r0,#0x34]
000108  2101              MOVS     r1,#1
00010a  0289              LSLS     r1,r1,#10
00010c  4308              ORRS     r0,r0,r1
00010e  495b              LDR      r1,|L1.636|
000110  6348              STR      r0,[r1,#0x34]
;;;197        
;;;198        // Disable UART0 before changing registers
;;;199        UART0_C2 &= ~(UART0_C2_TE_MASK | UART0_C2_RE_MASK);
000112  485f              LDR      r0,|L1.656|
000114  78c0              LDRB     r0,[r0,#3]
000116  210c              MOVS     r1,#0xc
000118  4388              BICS     r0,r0,r1
00011a  495d              LDR      r1,|L1.656|
00011c  70c8              STRB     r0,[r1,#3]
;;;200      
;;;201        // Verify that a valid clock value has been passed to the function 
;;;202        if ((sysclk > 50000) || (sysclk < 32))
00011e  495d              LDR      r1,|L1.660|
000120  9807              LDR      r0,[sp,#0x1c]
000122  4288              CMP      r0,r1
000124  dc02              BGT      |L1.300|
000126  9807              LDR      r0,[sp,#0x1c]
000128  2820              CMP      r0,#0x20
00012a  da0c              BGE      |L1.326|
                  |L1.300|
;;;203        {
;;;204            sysclk = 0;
00012c  bf00              NOP      
;;;205            reg_temp = SIM_SOPT2;
00012e  4853              LDR      r0,|L1.636|
000130  6845              LDR      r5,[r0,#4]
;;;206            reg_temp &= ~SIM_SOPT2_UART0SRC_MASK;
000132  2103              MOVS     r1,#3
000134  0689              LSLS     r1,r1,#26
000136  4628              MOV      r0,r5
000138  4388              BICS     r0,r0,r1
00013a  4605              MOV      r5,r0
;;;207            reg_temp |= SIM_SOPT2_UART0SRC(0);
00013c  bf00              NOP      
;;;208            SIM_SOPT2 = reg_temp;
00013e  484f              LDR      r0,|L1.636|
000140  6045              STR      r5,[r0,#4]
;;;209    			
;;;210    			  // Enter inifinite loop because the 
;;;211    			  // the desired system clock value is 
;;;212    			  // invalid!!
;;;213    			  while(1)
000142  bf00              NOP      
                  |L1.324|
000144  e7fe              B        |L1.324|
                  |L1.326|
;;;214    				{}
;;;215        }
;;;216        
;;;217        // Verify that a valid value has been passed to TERM_PORT_NUM and update
;;;218        // uart0_clk_hz accordingly.  Write 0 to TERM_PORT_NUM if an invalid 
;;;219        // value has been passed.  
;;;220        if (TERM_PORT_NUM != 0)
;;;221        {
;;;222            reg_temp = SIM_SOPT2;
;;;223            reg_temp &= ~SIM_SOPT2_UART0SRC_MASK;
;;;224            reg_temp |= SIM_SOPT2_UART0SRC(0);
;;;225            SIM_SOPT2 = reg_temp;
;;;226    			
;;;227    			  // Enter inifinite loop because the 
;;;228    			  // the desired terminal port number 
;;;229    			  // invalid!!
;;;230    			  while(1)
;;;231    				{}
;;;232        }
;;;233        
;;;234        
;;;235        
;;;236        // Initialize baud rate
;;;237        baud_rate = baud;
000146  9c08              LDR      r4,[sp,#0x20]
;;;238        
;;;239        // Change units to Hz
;;;240        uart0clk = sysclk * 1000;
000148  217d              MOVS     r1,#0x7d
00014a  00c9              LSLS     r1,r1,#3
00014c  9807              LDR      r0,[sp,#0x1c]
00014e  4348              MULS     r0,r1,r0
000150  9002              STR      r0,[sp,#8]
;;;241        // Calculate the first baud rate using the lowest OSR value possible.  
;;;242        i = 4;
000152  2604              MOVS     r6,#4
;;;243        sbr_val = (uint32)(uart0clk/(baud_rate * i));
000154  4620              MOV      r0,r4
000156  4370              MULS     r0,r6,r0
000158  4601              MOV      r1,r0
00015a  9802              LDR      r0,[sp,#8]
00015c  f7fffffe          BL       __aeabi_uidivmod
000160  9003              STR      r0,[sp,#0xc]
;;;244        calculated_baud = (uart0clk / (i * sbr_val));
000162  9803              LDR      r0,[sp,#0xc]
000164  4370              MULS     r0,r6,r0
000166  4601              MOV      r1,r0
000168  9802              LDR      r0,[sp,#8]
00016a  f7fffffe          BL       __aeabi_uidivmod
00016e  4607              MOV      r7,r0
;;;245            
;;;246        if (calculated_baud > baud_rate)
000170  42a7              CMP      r7,r4
000172  d902              BLS      |L1.378|
;;;247            baud_diff = calculated_baud - baud_rate;
000174  1b38              SUBS     r0,r7,r4
000176  9005              STR      r0,[sp,#0x14]
000178  e001              B        |L1.382|
                  |L1.378|
;;;248        else
;;;249            baud_diff = baud_rate - calculated_baud;
00017a  1be0              SUBS     r0,r4,r7
00017c  9005              STR      r0,[sp,#0x14]
                  |L1.382|
;;;250        
;;;251        osr_val = i;
00017e  9604              STR      r6,[sp,#0x10]
;;;252            
;;;253        // Select the best OSR value
;;;254        for (i = 5; i <= 32; i++)
000180  2605              MOVS     r6,#5
000182  e01d              B        |L1.448|
                  |L1.388|
;;;255        {
;;;256            sbr_val = (uint32)(uart0clk/(baud_rate * i));
000184  4620              MOV      r0,r4
000186  4370              MULS     r0,r6,r0
000188  4601              MOV      r1,r0
00018a  9802              LDR      r0,[sp,#8]
00018c  f7fffffe          BL       __aeabi_uidivmod
000190  9003              STR      r0,[sp,#0xc]
;;;257            calculated_baud = (uart0clk / (i * sbr_val));
000192  9803              LDR      r0,[sp,#0xc]
000194  4370              MULS     r0,r6,r0
000196  4601              MOV      r1,r0
000198  9802              LDR      r0,[sp,#8]
00019a  f7fffffe          BL       __aeabi_uidivmod
00019e  4607              MOV      r7,r0
;;;258            
;;;259            if (calculated_baud > baud_rate)
0001a0  42a7              CMP      r7,r4
0001a2  d902              BLS      |L1.426|
;;;260                temp = calculated_baud - baud_rate;
0001a4  1b38              SUBS     r0,r7,r4
0001a6  9001              STR      r0,[sp,#4]
0001a8  e001              B        |L1.430|
                  |L1.426|
;;;261            else
;;;262                temp = baud_rate - calculated_baud;
0001aa  1be0              SUBS     r0,r4,r7
0001ac  9001              STR      r0,[sp,#4]
                  |L1.430|
;;;263            
;;;264            if (temp <= baud_diff)
0001ae  9905              LDR      r1,[sp,#0x14]
0001b0  9801              LDR      r0,[sp,#4]
0001b2  4288              CMP      r0,r1
0001b4  d802              BHI      |L1.444|
;;;265            {
;;;266                baud_diff = temp;
0001b6  9801              LDR      r0,[sp,#4]
0001b8  9005              STR      r0,[sp,#0x14]
;;;267                osr_val = i; 
0001ba  9604              STR      r6,[sp,#0x10]
                  |L1.444|
0001bc  1c70              ADDS     r0,r6,#1              ;254
0001be  b2c6              UXTB     r6,r0                 ;254
                  |L1.448|
0001c0  2e20              CMP      r6,#0x20              ;254
0001c2  dddf              BLE      |L1.388|
;;;268            }
;;;269        }
;;;270        
;;;271        if (baud_diff < ((baud_rate / 100) * 3))
0001c4  2164              MOVS     r1,#0x64
0001c6  4620              MOV      r0,r4
0001c8  f7fffffe          BL       __aeabi_uidivmod
0001cc  0041              LSLS     r1,r0,#1
0001ce  1841              ADDS     r1,r0,r1
0001d0  9805              LDR      r0,[sp,#0x14]
0001d2  4281              CMP      r1,r0
0001d4  d935              BLS      |L1.578|
;;;272        {
;;;273            // If the OSR is between 4x and 8x then both
;;;274            // edge sampling MUST be turned on.  
;;;275            if ((osr_val >3) && (osr_val < 9))
0001d6  9804              LDR      r0,[sp,#0x10]
0001d8  2803              CMP      r0,#3
0001da  d908              BLS      |L1.494|
0001dc  9804              LDR      r0,[sp,#0x10]
0001de  2809              CMP      r0,#9
0001e0  d205              BCS      |L1.494|
;;;276                UART0_C5|= UART0_C5_BOTHEDGE_MASK;
0001e2  482b              LDR      r0,|L1.656|
0001e4  7ac0              LDRB     r0,[r0,#0xb]
0001e6  2102              MOVS     r1,#2
0001e8  4308              ORRS     r0,r0,r1
0001ea  4929              LDR      r1,|L1.656|
0001ec  72c8              STRB     r0,[r1,#0xb]
                  |L1.494|
;;;277            
;;;278            // Setup OSR value 
;;;279            reg_temp = UART0_C4;
0001ee  4828              LDR      r0,|L1.656|
0001f0  7a85              LDRB     r5,[r0,#0xa]
;;;280            reg_temp &= ~UART0_C4_OSR_MASK;
0001f2  096d              LSRS     r5,r5,#5
0001f4  016d              LSLS     r5,r5,#5
;;;281            reg_temp |= UART0_C4_OSR(osr_val-1);
0001f6  9804              LDR      r0,[sp,#0x10]
0001f8  1e40              SUBS     r0,r0,#1
0001fa  06c0              LSLS     r0,r0,#27
0001fc  0ec0              LSRS     r0,r0,#27
0001fe  4305              ORRS     r5,r5,r0
;;;282        
;;;283            // Write reg_temp to C4 register
;;;284            UART0_C4 = reg_temp;
000200  4823              LDR      r0,|L1.656|
000202  7285              STRB     r5,[r0,#0xa]
;;;285            
;;;286            reg_temp = (reg_temp & UART0_C4_OSR_MASK) + 1;
000204  06e8              LSLS     r0,r5,#27
000206  0ec0              LSRS     r0,r0,#27
000208  1c45              ADDS     r5,r0,#1
;;;287            sbr_val = (uint32)((uart0clk)/(baud_rate * (reg_temp)));
00020a  4620              MOV      r0,r4
00020c  4368              MULS     r0,r5,r0
00020e  4601              MOV      r1,r0
000210  9802              LDR      r0,[sp,#8]
000212  f7fffffe          BL       __aeabi_uidivmod
000216  9003              STR      r0,[sp,#0xc]
;;;288            
;;;289             /* Save off the current value of the uartx_BDH except for the SBR field */
;;;290            reg_temp = UART0_BDH & ~(UART0_BDH_SBR(0x1F));
000218  481d              LDR      r0,|L1.656|
00021a  7800              LDRB     r0,[r0,#0]
00021c  0945              LSRS     r5,r0,#5
00021e  016d              LSLS     r5,r5,#5
;;;291       
;;;292            UART0_BDH = reg_temp |  UART0_BDH_SBR(((sbr_val & 0x1F00) >> 8));
000220  211f              MOVS     r1,#0x1f
000222  0209              LSLS     r1,r1,#8
000224  9803              LDR      r0,[sp,#0xc]
000226  4008              ANDS     r0,r0,r1
000228  0a00              LSRS     r0,r0,#8
00022a  4328              ORRS     r0,r0,r5
00022c  4918              LDR      r1,|L1.656|
00022e  7008              STRB     r0,[r1,#0]
;;;293            UART0_BDL = (uint8)(sbr_val & UART0_BDL_SBR_MASK);
000230  9803              LDR      r0,[sp,#0xc]
000232  7048              STRB     r0,[r1,#1]
;;;294            
;;;295            /* Enable receiver and transmitter */
;;;296            UART0_C2 |= (UART0_C2_TE_MASK
000234  4608              MOV      r0,r1
000236  78c0              LDRB     r0,[r0,#3]
000238  210c              MOVS     r1,#0xc
00023a  4308              ORRS     r0,r0,r1
00023c  4914              LDR      r1,|L1.656|
00023e  70c8              STRB     r0,[r1,#3]
000240  e001              B        |L1.582|
                  |L1.578|
;;;297                        | UART0_C2_RE_MASK );
;;;298        }
;;;299        else
;;;300        {
;;;301            // Unacceptable baud rate difference
;;;302            // More than 3% difference!!
;;;303            // Enter infinite loop!
;;;304            while(1)
000242  bf00              NOP      
                  |L1.580|
000244  e7fe              B        |L1.580|
                  |L1.582|
;;;305    	{}
;;;306        }					
;;;307        
;;;308    }
000246  b009              ADD      sp,sp,#0x24
000248  bdf0              POP      {r4-r7,pc}
;;;309    /********************************************************************/
                          ENDP

                  uart0_getchar PROC
;;;318     */
;;;319    char uart0_getchar (UART0_MemMapPtr channel)
00024a  4601              MOV      r1,r0
;;;320    {
;;;321          /* Wait until character has been received */
;;;322          while (!(UART0_S1_REG(channel) & UART0_S1_RDRF_MASK));
00024c  bf00              NOP      
                  |L1.590|
00024e  7908              LDRB     r0,[r1,#4]
000250  2220              MOVS     r2,#0x20
000252  4010              ANDS     r0,r0,r2
000254  2800              CMP      r0,#0
000256  d0fa              BEQ      |L1.590|
;;;323        
;;;324          /* Return the 8-bit data from the receiver */
;;;325          return UART0_D_REG(channel);
000258  79c8              LDRB     r0,[r1,#7]
;;;326    }
00025a  4770              BX       lr
;;;327    /********************************************************************/
                          ENDP

                  uart0_putchar PROC
;;;334     */ 
;;;335    void uart0_putchar (UART0_MemMapPtr channel, char ch)
00025c  bf00              NOP      
                  |L1.606|
;;;336    {
;;;337          /* Wait until space is available in the FIFO */
;;;338          while(!(UART0_S1_REG(channel) & UART0_S1_TDRE_MASK));
00025e  7902              LDRB     r2,[r0,#4]
000260  2380              MOVS     r3,#0x80
000262  401a              ANDS     r2,r2,r3
000264  2a00              CMP      r2,#0
000266  d0fa              BEQ      |L1.606|
;;;339        
;;;340          /* Send the character */
;;;341          UART0_D_REG(channel) = (uint8)ch;
000268  71c1              STRB     r1,[r0,#7]
;;;342        
;;;343     }
00026a  4770              BX       lr
;;;344    /********************************************************************/
                          ENDP

                  uart0_getchar_present PROC
;;;354     */
;;;355    int uart0_getchar_present (UART0_MemMapPtr channel)
00026c  4601              MOV      r1,r0
;;;356    {
;;;357        return (UART0_S1_REG(channel) & UART0_S1_RDRF_MASK);
00026e  7908              LDRB     r0,[r1,#4]
000270  2220              MOVS     r2,#0x20
000272  4010              ANDS     r0,r0,r2
;;;358    }
000274  4770              BX       lr
;;;359    /********************************************************************/
                          ENDP

000276  0000              DCW      0x0000
                  |L1.632|
                          DCD      0x4006b000
                  |L1.636|
                          DCD      0x40048000
                  |L1.640|
                          DCD      0xe000e100
                  |L1.644|
                          DCD      0x00004e1f
                  |L1.648|
                          DCD      uart_string_gsm
                  |L1.652|
                          DCD      ||k2||
                  |L1.656|
                          DCD      0x4006a000
                  |L1.660|
                          DCD      0x0000c350

                          AREA ||.data||, DATA, ALIGN=2

                  test
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\drivers\\uart\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f64bdfb6____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_uart_c_f64bdfb6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f64bdfb6____REVSH|
#line 144
|__asm___6_uart_c_f64bdfb6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
