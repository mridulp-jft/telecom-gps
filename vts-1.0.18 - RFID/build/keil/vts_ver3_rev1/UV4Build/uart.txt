; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\uart.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\uart.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -I..\..\..\..\inc -I..\vts_ver3_rev1 -IE:\bitbuck\gps-trackr\Software\vts-ver18+\build\keil\vts_ver3_rev1\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0-Beta4\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.11.0\Device\Include -D__UVISION_VERSION=518 -D_RTE_ -DMKL26Z128xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\uart.crf ..\..\..\src\drivers\uart\uart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;864     */
;;;865    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;866    {
;;;867      if ((int32_t)(IRQn) >= 0)
000002  2800              CMP      r0,#0
000004  db19              BLT      |L1.58|
;;;868      {
;;;869        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
000006  4acc              LDR      r2,|L1.824|
000008  2303              MOVS     r3,#3
00000a  021b              LSLS     r3,r3,#8
00000c  18d2              ADDS     r2,r2,r3
00000e  0883              LSRS     r3,r0,#2
000010  009b              LSLS     r3,r3,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0783              LSLS     r3,r0,#30
000016  0edc              LSRS     r4,r3,#27
000018  23ff              MOVS     r3,#0xff
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  078b              LSLS     r3,r1,#30
000020  0e1b              LSRS     r3,r3,#24
000022  0784              LSLS     r4,r0,#30
000024  0ee4              LSRS     r4,r4,#27
000026  40a3              LSLS     r3,r3,r4
000028  431a              ORRS     r2,r2,r3
00002a  4bc3              LDR      r3,|L1.824|
00002c  2403              MOVS     r4,#3
00002e  0224              LSLS     r4,r4,#8
000030  191b              ADDS     r3,r3,r4
000032  0884              LSRS     r4,r0,#2
000034  00a4              LSLS     r4,r4,#2
000036  511a              STR      r2,[r3,r4]
000038  e018              B        |L1.108|
                  |L1.58|
;;;870           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;871      }
;;;872      else
;;;873      {
;;;874        SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
00003a  4ac0              LDR      r2,|L1.828|
00003c  0703              LSLS     r3,r0,#28
00003e  0f1b              LSRS     r3,r3,#28
000040  3b08              SUBS     r3,r3,#8
000042  089b              LSRS     r3,r3,#2
000044  009b              LSLS     r3,r3,#2
000046  58d2              LDR      r2,[r2,r3]
000048  0783              LSLS     r3,r0,#30
00004a  0edc              LSRS     r4,r3,#27
00004c  23ff              MOVS     r3,#0xff
00004e  40a3              LSLS     r3,r3,r4
000050  439a              BICS     r2,r2,r3
000052  078b              LSLS     r3,r1,#30
000054  0e1b              LSRS     r3,r3,#24
000056  0784              LSLS     r4,r0,#30
000058  0ee4              LSRS     r4,r4,#27
00005a  40a3              LSLS     r3,r3,r4
00005c  431a              ORRS     r2,r2,r3
00005e  4bb7              LDR      r3,|L1.828|
000060  0704              LSLS     r4,r0,#28
000062  0f24              LSRS     r4,r4,#28
000064  3c08              SUBS     r4,r4,#8
000066  08a4              LSRS     r4,r4,#2
000068  00a4              LSLS     r4,r4,#2
00006a  511a              STR      r2,[r3,r4]
                  |L1.108|
;;;875           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;876      }
;;;877    }
00006c  bd10              POP      {r4,pc}
;;;878    
                          ENDP

                  uart_init PROC
;;;35      */
;;;36     void uart_init (UART_MemMapPtr uartch, int sysclk, int baud)
00006e  b5f8              PUSH     {r3-r7,lr}
;;;37     {
000070  4604              MOV      r4,r0
000072  460e              MOV      r6,r1
000074  4617              MOV      r7,r2
;;;38         register uint16 sbr;
;;;39         uint8 temp;
;;;40      
;;;41           if (uartch == UART1_BASE_PTR)
000076  48b2              LDR      r0,|L1.832|
000078  4284              CMP      r4,r0
00007a  d106              BNE      |L1.138|
;;;42             SIM_SCGC4 |= SIM_SCGC4_UART1_MASK;
00007c  48b1              LDR      r0,|L1.836|
00007e  6b40              LDR      r0,[r0,#0x34]
000080  14e1              ASRS     r1,r4,#19
000082  4308              ORRS     r0,r0,r1
000084  49af              LDR      r1,|L1.836|
000086  6348              STR      r0,[r1,#0x34]
000088  e006              B        |L1.152|
                  |L1.138|
;;;43           else
;;;44         	SIM_SCGC4 |= SIM_SCGC4_UART2_MASK;
00008a  48ae              LDR      r0,|L1.836|
00008c  6b40              LDR      r0,[r0,#0x34]
00008e  2101              MOVS     r1,#1
000090  0309              LSLS     r1,r1,#12
000092  4308              ORRS     r0,r0,r1
000094  49ab              LDR      r1,|L1.836|
000096  6348              STR      r0,[r1,#0x34]
                  |L1.152|
;;;45           /* Make sure that the transmitter and receiver are disabled while we 
;;;46            * change settings.
;;;47            */
;;;48     			
;;;49     				NVIC_SetPriority(UART1_IRQn, 1);
000098  2101              MOVS     r1,#1
00009a  200d              MOVS     r0,#0xd
00009c  f7fffffe          BL       NVIC_SetPriority
;;;50     
;;;51     			
;;;52           UART_C2_REG(uartch) &= ~(UART_C2_TE_MASK
0000a0  78e0              LDRB     r0,[r4,#3]
0000a2  210c              MOVS     r1,#0xc
0000a4  4388              BICS     r0,r0,r1
0000a6  70e0              STRB     r0,[r4,#3]
;;;53     				| UART_C2_RE_MASK );
;;;54     			
;;;55     				      /* Configure the uart for 8-bit mode, no parity */
;;;56           UART_C1_REG(uartch) = 0;	/* We need all default settings, so entire register is cleared */
0000a8  2000              MOVS     r0,#0
0000aa  70a0              STRB     r0,[r4,#2]
;;;57         
;;;58           /* Calculate baud settings */
;;;59           sbr = (uint16)((sysclk*1000)/(baud * 16));
0000ac  0139              LSLS     r1,r7,#4
0000ae  227d              MOVS     r2,#0x7d
0000b0  00d2              LSLS     r2,r2,#3
0000b2  4372              MULS     r2,r6,r2
0000b4  4610              MOV      r0,r2
0000b6  f7fffffe          BL       __aeabi_idivmod
0000ba  b285              UXTH     r5,r0
;;;60     	//		sbr = sy/baud(OSR+1);
;;;61     			//sbr = 
;;;62             
;;;63           /* Save off the current value of the uartx_BDH except for the SBR field */
;;;64           temp = UART_BDH_REG(uartch) & ~(UART_BDH_SBR(0x1F));
0000bc  7820              LDRB     r0,[r4,#0]
0000be  0941              LSRS     r1,r0,#5
0000c0  0149              LSLS     r1,r1,#5
0000c2  9100              STR      r1,[sp,#0]
;;;65         
;;;66           UART_BDH_REG(uartch) = temp |  UART_BDH_SBR(((sbr & 0x1F00) >> 8));
0000c4  201f              MOVS     r0,#0x1f
0000c6  0200              LSLS     r0,r0,#8
0000c8  4028              ANDS     r0,r0,r5
0000ca  1200              ASRS     r0,r0,#8
0000cc  9900              LDR      r1,[sp,#0]
0000ce  4308              ORRS     r0,r0,r1
0000d0  7020              STRB     r0,[r4,#0]
;;;67           UART_BDL_REG(uartch) = (uint8)(sbr & UART_BDL_SBR_MASK);
0000d2  7065              STRB     r5,[r4,#1]
;;;68     			
;;;69     			
;;;70     			UART_C2_REG(uartch) |= UART_C2_RIE_MASK;			//newly added
0000d4  78e0              LDRB     r0,[r4,#3]
0000d6  2120              MOVS     r1,#0x20
0000d8  4308              ORRS     r0,r0,r1
0000da  70e0              STRB     r0,[r4,#3]
;;;71     			
;;;72     
;;;73     		
;;;74     			enable_irq(UART1_IRQn);	
0000dc  200d              MOVS     r0,#0xd
0000de  f7fffffe          BL       NVIC_EnableIRQ
;;;75     
;;;76     			EnableInterrupts;		//newly added
0000e2  b662              CPSIE    i
;;;77          		
;;;78     
;;;79     
;;;80     
;;;81     
;;;82           /* Enable receiver and transmitter */
;;;83           UART_C2_REG(uartch) |= (UART_C2_TE_MASK
0000e4  78e0              LDRB     r0,[r4,#3]
0000e6  210c              MOVS     r1,#0xc
0000e8  4308              ORRS     r0,r0,r1
0000ea  70e0              STRB     r0,[r4,#3]
;;;84     	    		  | UART_C2_RE_MASK );
;;;85     		
;;;86     
;;;87     
;;;88     }
0000ec  bdf8              POP      {r3-r7,pc}
;;;89     
                          ENDP

                  UART1_IRQHandler PROC
;;;90     void UART1_IRQHandler(void)
0000ee  4894              LDR      r0,|L1.832|
;;;91     {//int32 counter=19999;
;;;92     
;;;93     		//	do
;;;94     				{
;;;95     			if( (UART_S1_REG(UART1_BASE_PTR) & UART_S1_RDRF_MASK))	
0000f0  7900              LDRB     r0,[r0,#4]
0000f2  2120              MOVS     r1,#0x20
0000f4  4008              ANDS     r0,r0,r1
0000f6  2800              CMP      r0,#0
0000f8  d00a              BEQ      |L1.272|
;;;96     			{uart_string_gsm[k2]=UART_D_REG(UART1_BASE_PTR);k2++;
0000fa  4891              LDR      r0,|L1.832|
0000fc  79c0              LDRB     r0,[r0,#7]
0000fe  4992              LDR      r1,|L1.840|
000100  4a92              LDR      r2,|L1.844|
000102  6812              LDR      r2,[r2,#0]  ; k2
000104  5488              STRB     r0,[r1,r2]
000106  4891              LDR      r0,|L1.844|
000108  6800              LDR      r0,[r0,#0]  ; k2
00010a  1c40              ADDS     r0,r0,#1
00010c  498f              LDR      r1,|L1.844|
00010e  6008              STR      r0,[r1,#0]  ; k2
                  |L1.272|
;;;97     			//	counter=19999;
;;;98     		//	if(k2>4990)k2=0;
;;;99     			}
;;;100    //				else{counter--;
;;;101    //						}
;;;102    			}//`while((UART_S1_REG(UART1_BASE_PTR) & UART_S1_RDRF_MASK)  || (counter>1));
;;;103    			
;;;104    			
;;;105    }
000110  4770              BX       lr
;;;106    
                          ENDP

                  UART2_IRQHandler PROC
;;;107    void UART2_IRQHandler(void)
000112  4770              BX       lr
;;;108    {
;;;109    //k=0;l=999999;
;;;110    //			do{
;;;111    //			if( uart_getchar_present (UART2_BASE_PTR))	
;;;112    //			{uart_string_gps[k]=UART_D_REG(UART2_BASE_PTR);k++;l=9999;if(k>298){k=0;}}
;;;113    //				else{
;;;114    //							l--;if(l==10){}
;;;115    //						}
;;;116    //			}while(!((strstr(uart_string_gps, "OK\r\n"))
;;;117    //							||(strstr(uart_string_gps, "ERROR\r\n"))  || (l<=0)
;;;118    //				        	||(strstr(uart_string_gps, "ERROR:"))
;;;119    //							));
;;;120    //printf("uart_string_gps -> %s",uart_string_gps);
;;;121    }
;;;122    
                          ENDP

                  UART0_IRQHandler PROC
;;;126    
;;;127    void UART0_IRQHandler(void){
000114  2000              MOVS     r0,#0
;;;128    intrtmr=0;
000116  498e              LDR      r1,|L1.848|
000118  6008              STR      r0,[r1,#0]  ; intrtmr
;;;129    
;;;130    		if((UART_S1_REG(UART0_BASE_PTR) & UART0_S1_RDRF_MASK))
00011a  488e              LDR      r0,|L1.852|
00011c  7900              LDRB     r0,[r0,#4]
00011e  2120              MOVS     r1,#0x20
000120  4008              ANDS     r0,r0,r1
000122  2800              CMP      r0,#0
000124  d00d              BEQ      |L1.322|
;;;131    			{
;;;132    				id[uart0buffinc]=UART_D_REG(UART0_BASE_PTR);
000126  488b              LDR      r0,|L1.852|
000128  79c0              LDRB     r0,[r0,#7]
00012a  498b              LDR      r1,|L1.856|
00012c  4a8b              LDR      r2,|L1.860|
00012e  6812              LDR      r2,[r2,#0]  ; uart0buffinc
000130  5488              STRB     r0,[r1,r2]
;;;133    				uart0buffinc++;
000132  488a              LDR      r0,|L1.860|
000134  6800              LDR      r0,[r0,#0]  ; uart0buffinc
000136  1c40              ADDS     r0,r0,#1
000138  4988              LDR      r1,|L1.860|
00013a  6008              STR      r0,[r1,#0]  ; uart0buffinc
;;;134    				intrtmr = 0;
00013c  2000              MOVS     r0,#0
00013e  4984              LDR      r1,|L1.848|
000140  6008              STR      r0,[r1,#0]  ; intrtmr
                  |L1.322|
;;;135    			}
;;;136    
;;;137    				
;;;138    	
;;;139    }
000142  4770              BX       lr
;;;140    
                          ENDP

                  uart_getchar PROC
;;;158     */
;;;159    char uart_getchar (UART_MemMapPtr channel)
000144  4601              MOV      r1,r0
;;;160    {
;;;161          /* Wait until character has been received */
;;;162          while (!((UART_S1_REG(channel) & UART_S1_RDRF_MASK)    ));//{timeouttt--;}
000146  bf00              NOP      
                  |L1.328|
000148  7908              LDRB     r0,[r1,#4]
00014a  2220              MOVS     r2,#0x20
00014c  4010              ANDS     r0,r0,r2
00014e  2800              CMP      r0,#0
000150  d0fa              BEQ      |L1.328|
;;;163     //   ||   (timeouttt < 1 ) 
;;;164          /* Return the 8-bit data from the receiver */
;;;165          return UART_D_REG(channel);
000152  79c8              LDRB     r0,[r1,#7]
;;;166    }
000154  4770              BX       lr
;;;167    /********************************************************************/
                          ENDP

                  uart_putchar PROC
;;;174     */ 
;;;175    void uart_putchar (UART_MemMapPtr channel, char ch)
000156  b510              PUSH     {r4,lr}
;;;176    {int to=19999;
000158  4a81              LDR      r2,|L1.864|
;;;177          /* Wait until space is available in the FIFO */
;;;178          while(!((UART_S1_REG(channel) & UART_S1_TDRE_MASK)    ||  ( to <= 1 ))){to--;}
00015a  e000              B        |L1.350|
                  |L1.348|
00015c  1e52              SUBS     r2,r2,#1
                  |L1.350|
00015e  7903              LDRB     r3,[r0,#4]
000160  2480              MOVS     r4,#0x80
000162  4023              ANDS     r3,r3,r4
000164  2b00              CMP      r3,#0
000166  d101              BNE      |L1.364|
000168  2a01              CMP      r2,#1
00016a  dcf7              BGT      |L1.348|
                  |L1.364|
;;;179        
;;;180          /* Send the character */
;;;181          UART_D_REG(channel) = (uint8)ch;
00016c  71c1              STRB     r1,[r0,#7]
;;;182        
;;;183     }
00016e  bd10              POP      {r4,pc}
;;;184    /********************************************************************/
                          ENDP

                  uart_getchar_present PROC
;;;194     */
;;;195    int uart_getchar_present (UART_MemMapPtr channel)
000170  4601              MOV      r1,r0
;;;196    {
;;;197        return (UART_S1_REG(channel) & UART_S1_RDRF_MASK);
000172  7908              LDRB     r0,[r1,#4]
000174  2220              MOVS     r2,#0x20
000176  4010              ANDS     r0,r0,r2
;;;198    }
000178  4770              BX       lr
;;;199    /********************************************************************/
                          ENDP

                  uart0_init PROC
;;;217     */
;;;218    void uart0_init (UART0_MemMapPtr uartch, int sysclk, int baud)
00017a  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;219    {
00017c  b086              SUB      sp,sp,#0x18
;;;220        uint8 i;
;;;221        uint32 calculated_baud = 0;
00017e  bf00              NOP      
;;;222        uint32 baud_diff = 0;
000180  2000              MOVS     r0,#0
000182  9005              STR      r0,[sp,#0x14]
;;;223        uint32 osr_val = 0;
000184  9004              STR      r0,[sp,#0x10]
;;;224        uint32 sbr_val, uart0clk;
;;;225        uint32 baud_rate;
;;;226        uint32 reg_temp = 0;
000186  2500              MOVS     r5,#0
;;;227        uint32 temp = 0;
000188  9001              STR      r0,[sp,#4]
;;;228        
;;;229        SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
00018a  486e              LDR      r0,|L1.836|
00018c  6b40              LDR      r0,[r0,#0x34]
00018e  2101              MOVS     r1,#1
000190  0289              LSLS     r1,r1,#10
000192  4308              ORRS     r0,r0,r1
000194  496b              LDR      r1,|L1.836|
000196  6348              STR      r0,[r1,#0x34]
;;;230        
;;;231        // Disable UART0 before changing registers
;;;232        UART0_C2 &= ~(UART0_C2_TE_MASK | UART0_C2_RE_MASK);
000198  486e              LDR      r0,|L1.852|
00019a  78c0              LDRB     r0,[r0,#3]
00019c  210c              MOVS     r1,#0xc
00019e  4388              BICS     r0,r0,r1
0001a0  496c              LDR      r1,|L1.852|
0001a2  70c8              STRB     r0,[r1,#3]
;;;233    	
;;;234    		UART0_S2 |= UART_S2_RXINV_MASK;
0001a4  4608              MOV      r0,r1
0001a6  7940              LDRB     r0,[r0,#5]
0001a8  2110              MOVS     r1,#0x10
0001aa  4308              ORRS     r0,r0,r1
0001ac  4969              LDR      r1,|L1.852|
0001ae  7148              STRB     r0,[r1,#5]
;;;235    	
;;;236    		NVIC_SetPriority(UART0_IRQn, 1);
0001b0  2101              MOVS     r1,#1
0001b2  200c              MOVS     r0,#0xc
0001b4  f7fffffe          BL       NVIC_SetPriority
;;;237    
;;;238      
;;;239        // Verify that a valid clock value has been passed to the function 
;;;240        if ((sysclk > 50000) || (sysclk < 32))
0001b8  496a              LDR      r1,|L1.868|
0001ba  9807              LDR      r0,[sp,#0x1c]
0001bc  4288              CMP      r0,r1
0001be  dc02              BGT      |L1.454|
0001c0  9807              LDR      r0,[sp,#0x1c]
0001c2  2820              CMP      r0,#0x20
0001c4  da0c              BGE      |L1.480|
                  |L1.454|
;;;241        {
;;;242            sysclk = 0;
0001c6  bf00              NOP      
;;;243            reg_temp = SIM_SOPT2;
0001c8  485e              LDR      r0,|L1.836|
0001ca  6845              LDR      r5,[r0,#4]
;;;244            reg_temp &= ~SIM_SOPT2_UART0SRC_MASK;
0001cc  2103              MOVS     r1,#3
0001ce  0689              LSLS     r1,r1,#26
0001d0  4628              MOV      r0,r5
0001d2  4388              BICS     r0,r0,r1
0001d4  4605              MOV      r5,r0
;;;245            reg_temp |= SIM_SOPT2_UART0SRC(0);
0001d6  bf00              NOP      
;;;246            SIM_SOPT2 = reg_temp;
0001d8  485a              LDR      r0,|L1.836|
0001da  6045              STR      r5,[r0,#4]
;;;247    			
;;;248    			  // Enter inifinite loop because the 
;;;249    			  // the desired system clock value is 
;;;250    			  // invalid!!
;;;251    			  while(1)
0001dc  bf00              NOP      
                  |L1.478|
0001de  e7fe              B        |L1.478|
                  |L1.480|
;;;252    				{}
;;;253        }
;;;254        
;;;255        // Verify that a valid value has been passed to TERM_PORT_NUM and update
;;;256        // uart0_clk_hz accordingly.  Write 0 to TERM_PORT_NUM if an invalid 
;;;257        // value has been passed.  
;;;258        if (TERM_PORT_NUM != 0)
;;;259        {
;;;260            reg_temp = SIM_SOPT2;
;;;261            reg_temp &= ~SIM_SOPT2_UART0SRC_MASK;
;;;262            reg_temp |= SIM_SOPT2_UART0SRC(0);
;;;263            SIM_SOPT2 = reg_temp;
;;;264    			
;;;265    			  // Enter inifinite loop because the 
;;;266    			  // the desired terminal port number 
;;;267    			  // invalid!!
;;;268    			  while(1)
;;;269    				{}
;;;270        }
;;;271        
;;;272        
;;;273        
;;;274        // Initialize baud rate
;;;275        baud_rate = baud;
0001e0  9c08              LDR      r4,[sp,#0x20]
;;;276        
;;;277        // Change units to Hz
;;;278        uart0clk = sysclk * 1000;
0001e2  217d              MOVS     r1,#0x7d
0001e4  00c9              LSLS     r1,r1,#3
0001e6  9807              LDR      r0,[sp,#0x1c]
0001e8  4348              MULS     r0,r1,r0
0001ea  9002              STR      r0,[sp,#8]
;;;279        // Calculate the first baud rate using the lowest OSR value possible.  
;;;280        i = 4;
0001ec  2604              MOVS     r6,#4
;;;281        sbr_val = (uint32)(uart0clk/(baud_rate * i));
0001ee  4620              MOV      r0,r4
0001f0  4370              MULS     r0,r6,r0
0001f2  4601              MOV      r1,r0
0001f4  9802              LDR      r0,[sp,#8]
0001f6  f7fffffe          BL       __aeabi_uidivmod
0001fa  9003              STR      r0,[sp,#0xc]
;;;282        calculated_baud = (uart0clk / (i * sbr_val));
0001fc  9803              LDR      r0,[sp,#0xc]
0001fe  4370              MULS     r0,r6,r0
000200  4601              MOV      r1,r0
000202  9802              LDR      r0,[sp,#8]
000204  f7fffffe          BL       __aeabi_uidivmod
000208  4607              MOV      r7,r0
;;;283            
;;;284        if (calculated_baud > baud_rate)
00020a  42a7              CMP      r7,r4
00020c  d902              BLS      |L1.532|
;;;285            baud_diff = calculated_baud - baud_rate;
00020e  1b38              SUBS     r0,r7,r4
000210  9005              STR      r0,[sp,#0x14]
000212  e001              B        |L1.536|
                  |L1.532|
;;;286        else
;;;287            baud_diff = baud_rate - calculated_baud;
000214  1be0              SUBS     r0,r4,r7
000216  9005              STR      r0,[sp,#0x14]
                  |L1.536|
;;;288        
;;;289        osr_val = i;
000218  9604              STR      r6,[sp,#0x10]
;;;290            
;;;291        // Select the best OSR value
;;;292        for (i = 5; i <= 32; i++)
00021a  2605              MOVS     r6,#5
00021c  e01d              B        |L1.602|
                  |L1.542|
;;;293        {
;;;294            sbr_val = (uint32)(uart0clk/(baud_rate * i));
00021e  4620              MOV      r0,r4
000220  4370              MULS     r0,r6,r0
000222  4601              MOV      r1,r0
000224  9802              LDR      r0,[sp,#8]
000226  f7fffffe          BL       __aeabi_uidivmod
00022a  9003              STR      r0,[sp,#0xc]
;;;295            calculated_baud = (uart0clk / (i * sbr_val));
00022c  9803              LDR      r0,[sp,#0xc]
00022e  4370              MULS     r0,r6,r0
000230  4601              MOV      r1,r0
000232  9802              LDR      r0,[sp,#8]
000234  f7fffffe          BL       __aeabi_uidivmod
000238  4607              MOV      r7,r0
;;;296            
;;;297            if (calculated_baud > baud_rate)
00023a  42a7              CMP      r7,r4
00023c  d902              BLS      |L1.580|
;;;298                temp = calculated_baud - baud_rate;
00023e  1b38              SUBS     r0,r7,r4
000240  9001              STR      r0,[sp,#4]
000242  e001              B        |L1.584|
                  |L1.580|
;;;299            else
;;;300                temp = baud_rate - calculated_baud;
000244  1be0              SUBS     r0,r4,r7
000246  9001              STR      r0,[sp,#4]
                  |L1.584|
;;;301            
;;;302            if (temp <= baud_diff)
000248  9905              LDR      r1,[sp,#0x14]
00024a  9801              LDR      r0,[sp,#4]
00024c  4288              CMP      r0,r1
00024e  d802              BHI      |L1.598|
;;;303            {
;;;304                baud_diff = temp;
000250  9801              LDR      r0,[sp,#4]
000252  9005              STR      r0,[sp,#0x14]
;;;305                osr_val = i; 
000254  9604              STR      r6,[sp,#0x10]
                  |L1.598|
000256  1c70              ADDS     r0,r6,#1              ;292
000258  b2c6              UXTB     r6,r0                 ;292
                  |L1.602|
00025a  2e20              CMP      r6,#0x20              ;292
00025c  dddf              BLE      |L1.542|
;;;306            }
;;;307        }
;;;308        
;;;309        if (baud_diff < ((baud_rate / 100) * 3))
00025e  2164              MOVS     r1,#0x64
000260  4620              MOV      r0,r4
000262  f7fffffe          BL       __aeabi_uidivmod
000266  0041              LSLS     r1,r0,#1
000268  1841              ADDS     r1,r0,r1
00026a  9805              LDR      r0,[sp,#0x14]
00026c  4281              CMP      r1,r0
00026e  d93f              BLS      |L1.752|
;;;310        {
;;;311            // If the OSR is between 4x and 8x then both
;;;312            // edge sampling MUST be turned on.  
;;;313            if ((osr_val >3) && (osr_val < 9))
000270  9804              LDR      r0,[sp,#0x10]
000272  2803              CMP      r0,#3
000274  d908              BLS      |L1.648|
000276  9804              LDR      r0,[sp,#0x10]
000278  2809              CMP      r0,#9
00027a  d205              BCS      |L1.648|
;;;314                UART0_C5|= UART0_C5_BOTHEDGE_MASK;
00027c  4835              LDR      r0,|L1.852|
00027e  7ac0              LDRB     r0,[r0,#0xb]
000280  2102              MOVS     r1,#2
000282  4308              ORRS     r0,r0,r1
000284  4933              LDR      r1,|L1.852|
000286  72c8              STRB     r0,[r1,#0xb]
                  |L1.648|
;;;315            
;;;316            // Setup OSR value 
;;;317            reg_temp = UART0_C4;
000288  4832              LDR      r0,|L1.852|
00028a  7a85              LDRB     r5,[r0,#0xa]
;;;318            reg_temp &= ~UART0_C4_OSR_MASK;
00028c  096d              LSRS     r5,r5,#5
00028e  016d              LSLS     r5,r5,#5
;;;319            reg_temp |= UART0_C4_OSR(osr_val-1);
000290  9804              LDR      r0,[sp,#0x10]
000292  1e40              SUBS     r0,r0,#1
000294  06c0              LSLS     r0,r0,#27
000296  0ec0              LSRS     r0,r0,#27
000298  4305              ORRS     r5,r5,r0
;;;320        
;;;321            // Write reg_temp to C4 register
;;;322            UART0_C4 = reg_temp;
00029a  482e              LDR      r0,|L1.852|
00029c  7285              STRB     r5,[r0,#0xa]
;;;323            
;;;324            reg_temp = (reg_temp & UART0_C4_OSR_MASK) + 1;
00029e  06e8              LSLS     r0,r5,#27
0002a0  0ec0              LSRS     r0,r0,#27
0002a2  1c45              ADDS     r5,r0,#1
;;;325            sbr_val = (uint32)((uart0clk)/(baud_rate * (reg_temp)));
0002a4  4620              MOV      r0,r4
0002a6  4368              MULS     r0,r5,r0
0002a8  4601              MOV      r1,r0
0002aa  9802              LDR      r0,[sp,#8]
0002ac  f7fffffe          BL       __aeabi_uidivmod
0002b0  9003              STR      r0,[sp,#0xc]
;;;326            
;;;327             /* Save off the current value of the uartx_BDH except for the SBR field */
;;;328            reg_temp = UART0_BDH & ~(UART0_BDH_SBR(0x1F));
0002b2  4828              LDR      r0,|L1.852|
0002b4  7800              LDRB     r0,[r0,#0]
0002b6  0945              LSRS     r5,r0,#5
0002b8  016d              LSLS     r5,r5,#5
;;;329       
;;;330            UART0_BDH = reg_temp |  UART0_BDH_SBR(((sbr_val & 0x1F00) >> 8));
0002ba  211f              MOVS     r1,#0x1f
0002bc  0209              LSLS     r1,r1,#8
0002be  9803              LDR      r0,[sp,#0xc]
0002c0  4008              ANDS     r0,r0,r1
0002c2  0a00              LSRS     r0,r0,#8
0002c4  4328              ORRS     r0,r0,r5
0002c6  4923              LDR      r1,|L1.852|
0002c8  7008              STRB     r0,[r1,#0]
;;;331            UART0_BDL = (uint8)(sbr_val & UART0_BDL_SBR_MASK);
0002ca  9803              LDR      r0,[sp,#0xc]
0002cc  7048              STRB     r0,[r1,#1]
;;;332            
;;;333            /* Enable receiver and transmitter */
;;;334            UART0_C2 |= (UART0_C2_TE_MASK
0002ce  4608              MOV      r0,r1
0002d0  78c0              LDRB     r0,[r0,#3]
0002d2  210c              MOVS     r1,#0xc
0002d4  4308              ORRS     r0,r0,r1
0002d6  491f              LDR      r1,|L1.852|
0002d8  70c8              STRB     r0,[r1,#3]
;;;335                        | UART0_C2_RE_MASK );
;;;336    										
;;;337    										
;;;338    				UART0_C2 |= UART_C2_RIE_MASK;
0002da  4608              MOV      r0,r1
0002dc  78c0              LDRB     r0,[r0,#3]
0002de  2120              MOVS     r1,#0x20
0002e0  4308              ORRS     r0,r0,r1
0002e2  491c              LDR      r1,|L1.852|
0002e4  70c8              STRB     r0,[r1,#3]
;;;339    				
;;;340    				enable_irq(UART0_IRQn);	
0002e6  200c              MOVS     r0,#0xc
0002e8  f7fffffe          BL       NVIC_EnableIRQ
;;;341    
;;;342    				EnableInterrupts;		//newly added
0002ec  b662              CPSIE    i
0002ee  e001              B        |L1.756|
                  |L1.752|
;;;343    				
;;;344    				
;;;345        }
;;;346        else
;;;347        {
;;;348            // Unacceptable baud rate difference
;;;349            // More than 3% difference!!
;;;350            // Enter infinite loop!
;;;351            while(1)
0002f0  bf00              NOP      
                  |L1.754|
0002f2  e7fe              B        |L1.754|
                  |L1.756|
;;;352    	{}
;;;353        }					
;;;354        
;;;355    }
0002f4  b009              ADD      sp,sp,#0x24
0002f6  bdf0              POP      {r4-r7,pc}
;;;356    /********************************************************************/
                          ENDP

                  uart0_getchar PROC
;;;365     */
;;;366    int8 uart0_getchar (UART0_MemMapPtr channel)
0002f8  4601              MOV      r1,r0
;;;367    {
;;;368          /* Wait until character has been received */
;;;369          while (!(UART0_S1_REG(channel) & UART0_S1_RDRF_MASK));
0002fa  bf00              NOP      
                  |L1.764|
0002fc  7908              LDRB     r0,[r1,#4]
0002fe  2220              MOVS     r2,#0x20
000300  4010              ANDS     r0,r0,r2
000302  2800              CMP      r0,#0
000304  d0fa              BEQ      |L1.764|
;;;370        
;;;371          /* Return the 8-bit data from the receiver */
;;;372          return UART0_D_REG(channel);
000306  79c8              LDRB     r0,[r1,#7]
;;;373    }
000308  4770              BX       lr
;;;374    /********************************************************************/
                          ENDP

                  uart0_putchar PROC
;;;381     */ 
;;;382    void uart0_putchar (UART0_MemMapPtr channel, char ch)
00030a  bf00              NOP      
                  |L1.780|
;;;383    {
;;;384          /* Wait until space is available in the FIFO */
;;;385          while(!(UART0_S1_REG(channel) & UART0_S1_TDRE_MASK));
00030c  7902              LDRB     r2,[r0,#4]
00030e  2380              MOVS     r3,#0x80
000310  401a              ANDS     r2,r2,r3
000312  2a00              CMP      r2,#0
000314  d0fa              BEQ      |L1.780|
;;;386        
;;;387          /* Send the character */
;;;388          UART0_D_REG(channel) = (uint8)ch;
000316  71c1              STRB     r1,[r0,#7]
;;;389        
;;;390     }
000318  4770              BX       lr
;;;391    /********************************************************************/
                          ENDP

                  uart0_getchar_present PROC
;;;401     */
;;;402    int uart0_getchar_present (UART0_MemMapPtr channel)
00031a  4601              MOV      r1,r0
;;;403    {
;;;404    			return (UART0_S1_REG(channel) & UART0_S1_RDRF_MASK);
00031c  7908              LDRB     r0,[r1,#4]
00031e  2220              MOVS     r2,#0x20
000320  4010              ANDS     r0,r0,r2
;;;405    }
000322  4770              BX       lr
;;;406    /********************************************************************/
                          ENDP

                  NVIC_EnableIRQ PROC
;;;780     */
;;;781    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000324  2800              CMP      r0,#0
;;;782    {
;;;783      if ((int32_t)(IRQn) >= 0)
000326  db05              BLT      |L1.820|
;;;784      {
;;;785        NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000328  06c2              LSLS     r2,r0,#27
00032a  0ed2              LSRS     r2,r2,#27
00032c  2101              MOVS     r1,#1
00032e  4091              LSLS     r1,r1,r2
000330  4a01              LDR      r2,|L1.824|
000332  6011              STR      r1,[r2,#0]
                  |L1.820|
;;;786      }
;;;787    }
000334  4770              BX       lr
;;;788    
                          ENDP

000336  0000              DCW      0x0000
                  |L1.824|
                          DCD      0xe000e100
                  |L1.828|
                          DCD      0xe000ed1c
                  |L1.832|
                          DCD      0x4006b000
                  |L1.836|
                          DCD      0x40048000
                  |L1.840|
                          DCD      uart_string_gsm
                  |L1.844|
                          DCD      ||k2||
                  |L1.848|
                          DCD      intrtmr
                  |L1.852|
                          DCD      0x4006a000
                  |L1.856|
                          DCD      ||id||
                  |L1.860|
                          DCD      uart0buffinc
                  |L1.864|
                          DCD      0x00004e1f
                  |L1.868|
                          DCD      0x0000c350

                          AREA ||.data||, DATA, ALIGN=2

                  test
                          DCD      0x00000000
                  uart0buffinc
                          DCD      0x00000000
                  intrtmr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\drivers\\uart\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_ab62809a____REV16|
#line 383 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.0-Beta4\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_ab62809a____REV16| PROC
#line 384

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_ab62809a____REVSH|
#line 397
|__asm___6_uart_c_ab62809a____REVSH| PROC
#line 398

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
