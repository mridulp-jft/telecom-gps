; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\sysinit.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\sysinit.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -I..\..\..\..\inc -IC:\vts-ver17\build\keil\vts_ver3_rev1\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0-Beta4\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.11.0\Device\Include -D__UVISION_VERSION=520 -D_RTE_ -DMKL26Z128xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\sysinit.crf ..\..\..\src\cpu\sysinit.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  sysinit PROC
;;;31     /********************************************************************/
;;;32     void sysinit (void)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34             /* Enable all of the port clocks. These have to be enabled to configure
;;;35              * pin muxing options, so most code will need all of these on anyway.
;;;36              */
;;;37             SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK
000002  484b              LDR      r0,|L1.304|
000004  6b80              LDR      r0,[r0,#0x38]
000006  211f              MOVS     r1,#0x1f
000008  0249              LSLS     r1,r1,#9
00000a  4308              ORRS     r0,r0,r1
00000c  4948              LDR      r1,|L1.304|
00000e  6388              STR      r0,[r1,#0x38]
;;;38                           | SIM_SCGC5_PORTB_MASK
;;;39                           | SIM_SCGC5_PORTC_MASK
;;;40                           | SIM_SCGC5_PORTD_MASK
;;;41                           | SIM_SCGC5_PORTE_MASK );
;;;42             
;;;43             // Release hold with ACKISO:  Only has an effect if recovering from VLLS1, VLLS2, or VLLS3
;;;44             // if ACKISO is set you must clear ackiso before calling pll_init 
;;;45             //    or pll init hangs waiting for OSC to initialize
;;;46             // if osc enabled in low power modes - enable it first before ack
;;;47             // if I/O needs to be maintained without glitches enable outputs and modules first before ack.
;;;48             if (PMC_REGSC &  PMC_REGSC_ACKISO_MASK)
000010  4848              LDR      r0,|L1.308|
000012  7880              LDRB     r0,[r0,#2]
000014  2108              MOVS     r1,#8
000016  4008              ANDS     r0,r0,r1
000018  2800              CMP      r0,#0
00001a  d004              BEQ      |L1.38|
;;;49             PMC_REGSC |= PMC_REGSC_ACKISO_MASK;
00001c  4845              LDR      r0,|L1.308|
00001e  7880              LDRB     r0,[r0,#2]
000020  4308              ORRS     r0,r0,r1
000022  4944              LDR      r1,|L1.308|
000024  7088              STRB     r0,[r1,#2]
                  |L1.38|
;;;50             
;;;51     #ifdef ENABLE_CLKOUT
;;;52             // Initialize trace clk functionality
;;;53             clk_out_init();
;;;54     #endif
;;;55     				
;;;56     #ifndef CMSIS
;;;57            /* Ramp up the system clock */
;;;58            /* Set the system dividers */
;;;59            /* NOTE: The PLL init will not configure the system clock dividers,
;;;60             * so they must be configured appropriately before calling the PLL
;;;61             * init function to ensure that clocks remain in valid ranges.
;;;62             */  
;;;63             SIM_CLKDIV1 = ( 0
;;;64                             | SIM_CLKDIV1_OUTDIV1(OUTDIV1_VAL)
;;;65                             | SIM_CLKDIV1_OUTDIV4(OUTDIV4_VAL) );
;;;66      
;;;67     #if defined(NO_PLL_INIT)
;;;68             // If PLL initialization is not desired, set FLL to 48 MHz clock in default FEI mode
;;;69             // Set DMX32 and DRST_DRS values accordingly
;;;70             MCG_C4 = ((MCG_C4 & ~(MCG_C4_DRST_DRS_MASK)) | ((FLL_DMX32 << MCG_C4_DMX32_SHIFT)
;;;71                                                          | (FLL_DRST_DRS << MCG_C4_DRST_DRS_SHIFT)));
;;;72             if (FLL_DMX32 == 0)
;;;73                 mcg_clk_hz = 640 * (FLL_DRST_DRS + 1) * FLL_REF_FREQ;
;;;74             else 
;;;75                 mcg_clk_hz = 732 * (FLL_DRST_DRS + 1) * FLL_REF_FREQ;
;;;76             
;;;77             SIM_SOPT2 &= ~SIM_SOPT2_PLLFLLSEL_MASK; // clear PLLFLLSEL to select the FLL for this clock source
;;;78             
;;;79             uart0_clk_khz = (mcg_clk_hz / 1000); // the uart0 clock frequency will equal the FLL frequency
;;;80             
;;;81             SIM_SOPT2 = ((SIM_SOPT2 & ~SIM_SOPT2_UART0SRC_MASK) | SIM_SOPT2_UART0SRC(1));
;;;82            
;;;83     #else 
;;;84            /* Initialize PLL */
;;;85            /* PLL will be the source for MCG CLKOUT so the core, system, and flash clocks are derived from it */ 
;;;86            mcg_clk_hz = pll_init(CLK0_FREQ_HZ,  /* CLKIN0 frequency */
;;;87                                  LOW_POWER,     /* Set the oscillator for low power mode */
;;;88                                  CLK0_TYPE,     /* Crystal or canned oscillator clock input */
;;;89                                  PLL0_PRDIV,    /* PLL predivider value */
;;;90                                  PLL0_VDIV,     /* PLL multiplier */
;;;91                                  MCGOUT);       /* Use the output from this PLL as the MCGOUT */
;;;92     														 
;;;93     														 
;;;94     			/* Check the value returned from pll_init() to make sure there wasn't an error */
;;;95            if (mcg_clk_hz < 0x100)
;;;96              while(1);
;;;97            
;;;98            SIM_SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK; // set PLLFLLSEL to select the PLL for this clock source
;;;99            
;;;100           uart0_clk_khz = ((mcg_clk_hz / 2) / 1000); // UART0 clock frequency will equal half the PLL frequency
;;;101           
;;;102           SIM_SOPT2 = ((SIM_SOPT2 & ~SIM_SOPT2_UART0SRC_MASK) | SIM_SOPT2_UART0SRC(1));
;;;103    #endif 
;;;104    			 
;;;105    #else
;;;106    mcg_clk_hz = SystemCoreClock;
000026  4844              LDR      r0,|L1.312|
000028  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00002a  4944              LDR      r1,|L1.316|
00002c  6008              STR      r0,[r1,#0]  ; mcg_clk_hz
;;;107    			 
;;;108    if (CLOCK_SETUP == 3)
;;;109    {
;;;110    	// If PLL initialization is not desired, set FLL to 48 MHz clock in default FEI mode
;;;111      MCG_C4 |= (MCG_C4_DRST_DRS(1) | MCG_C4_DMX32_MASK);
;;;112            
;;;113      SIM_SOPT2 &= ~SIM_SOPT2_PLLFLLSEL_MASK; // clear PLLFLLSEL to select the FLL for this clock source
;;;114            
;;;115      uart0_clk_khz = (mcg_clk_hz / 1000); // the uart0 clock frequency will equal the FLL frequency
;;;116            
;;;117      SIM_SOPT2 = ((SIM_SOPT2 & ~SIM_SOPT2_UART0SRC_MASK) | SIM_SOPT2_UART0SRC(1));
;;;118    }
;;;119    else
;;;120    {      
;;;121      SIM_SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK; // set PLLFLLSEL to select the PLL for this clock source
00002e  4840              LDR      r0,|L1.304|
000030  6840              LDR      r0,[r0,#4]
000032  2101              MOVS     r1,#1
000034  0409              LSLS     r1,r1,#16
000036  4308              ORRS     r0,r0,r1
000038  493d              LDR      r1,|L1.304|
00003a  6048              STR      r0,[r1,#4]
;;;122        
;;;123      uart0_clk_khz = ((mcg_clk_hz / 2) / 1000); // UART0 clock frequency will equal half the PLL frequency
00003c  483f              LDR      r0,|L1.316|
00003e  6804              LDR      r4,[r0,#0]  ; mcg_clk_hz
000040  0fe1              LSRS     r1,r4,#31
000042  1909              ADDS     r1,r1,r4
000044  1048              ASRS     r0,r1,#1
000046  217d              MOVS     r1,#0x7d
000048  00c9              LSLS     r1,r1,#3
00004a  f7fffffe          BL       __aeabi_idivmod
00004e  493c              LDR      r1,|L1.320|
000050  6008              STR      r0,[r1,#0]  ; uart0_clk_khz
;;;124           
;;;125      SIM_SOPT2 = ((SIM_SOPT2 & ~SIM_SOPT2_UART0SRC_MASK) | SIM_SOPT2_UART0SRC(1));
000052  4837              LDR      r0,|L1.304|
000054  6840              LDR      r0,[r0,#4]
000056  2103              MOVS     r1,#3
000058  0689              LSLS     r1,r1,#26
00005a  4388              BICS     r0,r0,r1
00005c  2101              MOVS     r1,#1
00005e  0689              LSLS     r1,r1,#26
000060  1840              ADDS     r0,r0,r1
000062  4933              LDR      r1,|L1.304|
000064  6048              STR      r0,[r1,#4]
;;;126    }
;;;127    #endif    
;;;128    
;;;129    	/*
;;;130             * Use the value obtained from the pll_init function to define variables
;;;131    	 * for the core clock in kHz and also the peripheral clock. These
;;;132    	 * variables can be used by other functions that need awareness of the
;;;133    	 * system frequency.
;;;134    	 */
;;;135            mcg_clk_khz = mcg_clk_hz / 1000;
000066  217d              MOVS     r1,#0x7d
000068  00c9              LSLS     r1,r1,#3
00006a  4834              LDR      r0,|L1.316|
00006c  6800              LDR      r0,[r0,#0]  ; mcg_clk_hz
00006e  f7fffffe          BL       __aeabi_idivmod
000072  4934              LDR      r1,|L1.324|
000074  6008              STR      r0,[r1,#0]  ; mcg_clk_khz
;;;136    				core_clk_khz = mcg_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> 28)+ 1);
000076  482e              LDR      r0,|L1.304|
000078  3040              ADDS     r0,r0,#0x40
00007a  6840              LDR      r0,[r0,#4]
00007c  0f00              LSRS     r0,r0,#28
00007e  1c41              ADDS     r1,r0,#1
000080  4830              LDR      r0,|L1.324|
000082  6800              LDR      r0,[r0,#0]  ; mcg_clk_khz
000084  f7fffffe          BL       __aeabi_uidivmod
000088  492f              LDR      r1,|L1.328|
00008a  6008              STR      r0,[r1,#0]  ; core_clk_khz
;;;137            periph_clk_khz = core_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> 16)+ 1);
00008c  4828              LDR      r0,|L1.304|
00008e  3040              ADDS     r0,r0,#0x40
000090  6840              LDR      r0,[r0,#4]
000092  2207              MOVS     r2,#7
000094  0412              LSLS     r2,r2,#16
000096  4010              ANDS     r0,r0,r2
000098  0c00              LSRS     r0,r0,#16
00009a  1c41              ADDS     r1,r0,#1
00009c  482a              LDR      r0,|L1.328|
00009e  6800              LDR      r0,[r0,#0]  ; core_clk_khz
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  4929              LDR      r1,|L1.332|
0000a6  6008              STR      r0,[r1,#0]  ; periph_clk_khz
;;;138            
;;;139    #ifdef USE_ABORT_BUTTON
;;;140            /* Enable pin interrupt for the abort button - PTA4 */
;;;141            /* This pin could also be used as the NMI interrupt, but since the NMI
;;;142             * is level sensitive each button press will cause multiple interrupts.
;;;143             * Using the GPIO interrupt instead means we can configure for an edge
;;;144             * sensitive interrupt instead = one interrupt per button press.
;;;145             */
;;;146           // enable_abort_button();
;;;147    #endif
;;;148            
;;;149            
;;;150            /*
;;;151             * Configure the UART terminal port pins.  These definitions are 
;;;152             * defined in the platform header file.
;;;153             */
;;;154            
;;;155            PORT_PCR_REG(TERM_PIN_PORT, TERM_RX_PIN) = PORT_PCR_MUX(TERM_MUX_ALT);
0000a8  2001              MOVS     r0,#1
0000aa  0240              LSLS     r0,r0,#9
0000ac  4928              LDR      r1,|L1.336|
0000ae  6048              STR      r0,[r1,#4]
;;;156            PORT_PCR_REG(TERM_PIN_PORT, TERM_TX_PIN) = PORT_PCR_MUX(TERM_MUX_ALT);
0000b0  6088              STR      r0,[r1,#8]
;;;157    				
;;;158    				PORT_PCR_REG(TERM_PIN_PORT1, TERM_RX_PIN1) = PORT_PCR_MUX(TERM_MUX_ALT1);
0000b2  2003              MOVS     r0,#3
0000b4  0200              LSLS     r0,r0,#8
0000b6  4927              LDR      r1,|L1.340|
0000b8  6048              STR      r0,[r1,#4]
;;;159            PORT_PCR_REG(TERM_PIN_PORT1, TERM_TX_PIN1) = PORT_PCR_MUX(TERM_MUX_ALT1);
0000ba  6008              STR      r0,[r1,#0]
;;;160    				
;;;161    				PORT_PCR_REG(TERM_PIN_PORT2, TERM_RX_PIN2) = PORT_PCR_MUX(TERM_MUX_ALT2);
0000bc  4926              LDR      r1,|L1.344|
0000be  6088              STR      r0,[r1,#8]
;;;162            PORT_PCR_REG(TERM_PIN_PORT2, TERM_TX_PIN2) = PORT_PCR_MUX(TERM_MUX_ALT2);
0000c0  60c8              STR      r0,[r1,#0xc]
;;;163            
;;;164      	/* UART0 is clocked asynchronously to the core clock, but all other UARTs are
;;;165             * clocked from the peripheral clock. So we have to determine which clock
;;;166             * to send to the UART_init function.
;;;167             */
;;;168    
;;;169                uart0_init (UART0_BASE_PTR, uart0_clk_khz, TERMINAL_BAUD);
0000c2  22e1              MOVS     r2,#0xe1
0000c4  0252              LSLS     r2,r2,#9
0000c6  481e              LDR      r0,|L1.320|
0000c8  6801              LDR      r1,[r0,#0]  ; uart0_clk_khz
0000ca  4824              LDR      r0,|L1.348|
0000cc  f7fffffe          BL       uart0_init
;;;170    
;;;171    						uart_init (UART1_BASE_PTR, periph_clk_khz, TERMINAL_BAUD1);
0000d0  22e1              MOVS     r2,#0xe1
0000d2  0252              LSLS     r2,r2,#9
0000d4  481d              LDR      r0,|L1.332|
0000d6  6801              LDR      r1,[r0,#0]  ; periph_clk_khz
0000d8  4821              LDR      r0,|L1.352|
0000da  f7fffffe          BL       uart_init
;;;172    
;;;173                uart_init (UART2_BASE_PTR, periph_clk_khz, TERMINAL_BAUD2);
0000de  224b              MOVS     r2,#0x4b
0000e0  01d2              LSLS     r2,r2,#7
0000e2  481a              LDR      r0,|L1.332|
0000e4  6801              LDR      r1,[r0,#0]  ; periph_clk_khz
0000e6  481f              LDR      r0,|L1.356|
0000e8  f7fffffe          BL       uart_init
;;;174    
;;;175    }
0000ec  bd10              POP      {r4,pc}
;;;176    /********************************************************************/
                          ENDP

                  enable_abort_button PROC
;;;177    void enable_abort_button(void)
0000ee  20ff              MOVS     r0,#0xff
;;;178    {
;;;179        /* Configure the PTA4 pin for its GPIO function */
;;;180        PORTA_PCR4 = PORT_PCR_MUX(0x1); // GPIO is alt1 function for this pin
0000f0  3001              ADDS     r0,#1
0000f2  4917              LDR      r1,|L1.336|
0000f4  6108              STR      r0,[r1,#0x10]
;;;181        
;;;182        /* Configure the PTA4 pin for rising edge interrupts */
;;;183        PORTA_PCR4 |= PORT_PCR_IRQC(0x9); 
0000f6  4608              MOV      r0,r1
0000f8  6900              LDR      r0,[r0,#0x10]
0000fa  2109              MOVS     r1,#9
0000fc  0409              LSLS     r1,r1,#16
0000fe  4308              ORRS     r0,r0,r1
000100  4913              LDR      r1,|L1.336|
000102  6108              STR      r0,[r1,#0x10]
;;;184        
;;;185    #ifdef CMSIS
;;;186        /* Enable the associated IRQ in the NVIC */
;;;187        enable_irq(PORTA_IRQn);      
000104  201e              MOVS     r0,#0x1e
000106  2800              CMP      r0,#0
000108  db05              BLT      |L1.278|
00010a  06c2              LSLS     r2,r0,#27
00010c  0ed2              LSRS     r2,r2,#27
00010e  2101              MOVS     r1,#1
000110  4091              LSLS     r1,r1,r2
000112  4a15              LDR      r2,|L1.360|
000114  6011              STR      r1,[r2,#0]
                  |L1.278|
000116  bf00              NOP      
;;;188    #else
;;;189    	  enable_irq(30); 
;;;190    #endif	
;;;191    }
000118  4770              BX       lr
;;;192    /********************************************************************/
                          ENDP

                  clk_out_init PROC
;;;194    /********************************************************************/
;;;195    void clk_out_init(void)
00011a  2005              MOVS     r0,#5
;;;196    {
;;;197    
;;;198        // If you are using UART1 for serial communications do not
;;;199        // initialize the clock out function or you may break the UART!
;;;200        if (TERM_PORT_NUM != 1)
;;;201        {
;;;202            /* Enable the CLKOUT function on PTC3 (alt5 function) */
;;;203    	PORTC_PCR3 = ( PORT_PCR_MUX(0x5));
00011c  0200              LSLS     r0,r0,#8
00011e  4913              LDR      r1,|L1.364|
000120  60c8              STR      r0,[r1,#0xc]
;;;204            
;;;205            /* Select the CLKOUT in the SMI_SOPT2 mux to be bus clk*/
;;;206            SIM_SOPT2 |= SIM_SOPT2_CLKOUTSEL(2);
000122  4803              LDR      r0,|L1.304|
000124  6840              LDR      r0,[r0,#4]
000126  2140              MOVS     r1,#0x40
000128  4308              ORRS     r0,r0,r1
00012a  4901              LDR      r1,|L1.304|
00012c  6048              STR      r0,[r1,#4]
;;;207        }
;;;208            
;;;209    }
00012e  4770              BX       lr
                          ENDP

                  |L1.304|
                          DCD      0x40048000
                  |L1.308|
                          DCD      0x4007d000
                  |L1.312|
                          DCD      SystemCoreClock
                  |L1.316|
                          DCD      mcg_clk_hz
                  |L1.320|
                          DCD      uart0_clk_khz
                  |L1.324|
                          DCD      mcg_clk_khz
                  |L1.328|
                          DCD      core_clk_khz
                  |L1.332|
                          DCD      periph_clk_khz
                  |L1.336|
                          DCD      0x40049000
                  |L1.340|
                          DCD      0x4004d000
                  |L1.344|
                          DCD      0x4004c000
                  |L1.348|
                          DCD      0x4006a000
                  |L1.352|
                          DCD      0x4006b000
                  |L1.356|
                          DCD      0x4006c000
                  |L1.360|
                          DCD      0xe000e100
                  |L1.364|
                          DCD      0x4004b000

                          AREA ||.data||, DATA, ALIGN=2

                  mcg_clk_hz
                          DCD      0x00000000
                  mcg_clk_khz
                          DCD      0x00000000
                  core_clk_khz
                          DCD      0x00000000
                  periph_clk_khz
                          DCD      0x00000000
                  pll_clk_khz
                          DCD      0x00000000
                  uart0_clk_khz
                          DCD      0x00000000
                  uart0_clk_hz
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\cpu\\sysinit.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_sysinit_c_sysinit____REV16|
#line 383 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.0-Beta4\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_sysinit_c_sysinit____REV16| PROC
#line 384

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_sysinit_c_sysinit____REVSH|
#line 397
|__asm___9_sysinit_c_sysinit____REVSH| PROC
#line 398

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
