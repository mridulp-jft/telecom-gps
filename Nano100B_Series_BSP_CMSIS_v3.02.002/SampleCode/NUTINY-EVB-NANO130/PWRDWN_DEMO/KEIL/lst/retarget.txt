; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\retarget.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\retarget.d --feedback=.\obj\PWRDWN_DEMO.fed --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\LCDLib\Include -I..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\retarget.crf ..\..\..\..\Library\StdDriver\src\retarget.c]
                          THUMB

                          AREA ||i.GetChar||, CODE, READONLY, ALIGN=2

                  GetChar PROC
;;;367    
;;;368    char GetChar(void)
000000  4803              LDR      r0,|L1.16|
                  |L1.2|
;;;369    {
;;;370    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;371    # if defined ( __CC_ARM   )
;;;372        int nRet;
;;;373        while(SH_DoCommand(0x101, 0, &nRet) != 0) {
;;;374            if(nRet != 0) {
;;;375                SH_DoCommand(0x07, 0, &nRet);
;;;376                return (char)nRet;
;;;377            }
;;;378        }
;;;379    # else
;;;380        int nRet;
;;;381        while(SH_DoCommand(0x7, 0, &nRet) != 0) {
;;;382            if(nRet != 0)
;;;383                return (char)nRet;
;;;384        }
;;;385    # endif
;;;386    #endif
;;;387    #ifndef DISABLE_UART
;;;388        while (1) {
;;;389            if(!(DEBUG_PORT->FSR & UART_FSR_RX_EMPTY_F_Msk)) {
000002  6981              LDR      r1,[r0,#0x18]
000004  0789              LSLS     r1,r1,#30
000006  d4fc              BMI      |L1.2|
;;;390                return (DEBUG_PORT->RBR);
000008  6800              LDR      r0,[r0,#0]
00000a  b2c0              UXTB     r0,r0
;;;391    
;;;392            }
;;;393        }
;;;394    #else
;;;395        return(0);
;;;396    #endif
;;;397    }
00000c  4770              BX       lr
;;;398    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40050000

                          AREA ||i.Hard_Fault_Handler||, CODE, READONLY, ALIGN=2

                  Hard_Fault_Handler PROC
                  ||__tagsym$$used||
;;;60     
;;;61     void Hard_Fault_Handler(uint32_t stack[])
000000  4604              MOV      r4,r0
;;;62     {     
;;;63         printf("In Hard Fault Handler\n");
000002  a00c              ADR      r0,|L2.52|
000004  f7fffffe          BL       __2printf
;;;64     
;;;65         stackDump(stack);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       stackDump
00000e  2159              MOVS     r1,#0x59
000010  2316              MOVS     r3,#0x16
000012  480e              LDR      r0,|L2.76|
000014  2288              MOVS     r2,#0x88
;;;66     	
;;;67     	//Chip Reset
;;;68     		SYS_UnlockReg();
000016  e002              B        |L2.30|
                  |L2.24|
000018  6001              STR      r1,[r0,#0]
00001a  6003              STR      r3,[r0,#0]
00001c  6002              STR      r2,[r0,#0]
                  |L2.30|
00001e  6804              LDR      r4,[r0,#0]
000020  2c01              CMP      r4,#1
000022  d1f9              BNE      |L2.24|
;;;69     		SYS->IPRST_CTL1 |= SYS_IPRST_CTL1_CHIP_RST_Msk;
000024  2005              MOVS     r0,#5
000026  0700              LSLS     r0,r0,#28
000028  6881              LDR      r1,[r0,#8]
00002a  2201              MOVS     r2,#1
00002c  4311              ORRS     r1,r1,r2
00002e  6081              STR      r1,[r0,#8]
                  |L2.48|
;;;70     
;;;71         while(1);
000030  e7fe              B        |L2.48|
;;;72     }
;;;73     
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
000034  496e2048          DCB      "In Hard Fault Handler\n",0
000038  61726420
00003c  4661756c
000040  74204861
000044  6e646c65
000048  720a00  
00004b  00                DCB      0
                  |L2.76|
                          DCD      0x50000100

                          AREA ||i.IsDebugFifoEmpty||, CODE, READONLY, ALIGN=2

                  IsDebugFifoEmpty PROC
;;;422      */
;;;423    int IsDebugFifoEmpty(void)
000000  4802              LDR      r0,|L3.12|
;;;424    {
;;;425    #ifndef DISABLE_UART
;;;426        return (DEBUG_PORT->FSR & UART_FSR_TE_F_Msk) ? 1 : 0;
000002  6980              LDR      r0,[r0,#0x18]
000004  0500              LSLS     r0,r0,#20
000006  0fc0              LSRS     r0,r0,#31
;;;427    #else
;;;428        return(1);
;;;429    #endif
;;;430    
;;;431    }
000008  4770              BX       lr
;;;432    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x40050000

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=1

                  SendChar PROC
;;;334    
;;;335    void SendChar(int ch)
000000  b500              PUSH     {lr}
;;;336    {
;;;337    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;338        g_buf[g_buf_len++] = ch;
;;;339        g_buf[g_buf_len] = '\0';
;;;340        if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0') {
;;;341    
;;;342            /* Send the char */
;;;343    
;;;344            if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0) {
;;;345                g_buf_len = 0;
;;;346                return;
;;;347            } else {
;;;348                int i;
;;;349    
;;;350                for(i=0; i<g_buf_len; i++)
;;;351                    SendChar_ToUART(g_buf[i]);
;;;352                g_buf_len = 0;
;;;353            }
;;;354        }
;;;355    #else
;;;356        SendChar_ToUART(ch);
000002  f7fffffe          BL       SendChar_ToUART
;;;357    #endif
;;;358    }
000006  bd00              POP      {pc}
;;;359    
                          ENDP


                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;315    
;;;316    void SendChar_ToUART(int ch)
000000  4906              LDR      r1,|L5.28|
                  |L5.2|
;;;317    {
;;;318    #ifndef DISABLE_UART
;;;319        while(DEBUG_PORT->FSR & UART_FSR_TX_FULL_F_Msk);
000002  698a              LDR      r2,[r1,#0x18]
000004  0552              LSLS     r2,r2,#21
000006  d4fc              BMI      |L5.2|
;;;320        DEBUG_PORT->THR = ch;
000008  6008              STR      r0,[r1,#0]
;;;321        if(ch == '\n') {
00000a  280a              CMP      r0,#0xa
00000c  d104              BNE      |L5.24|
                  |L5.14|
;;;322            while(DEBUG_PORT->FSR & UART_FSR_TX_FULL_F_Msk);
00000e  6988              LDR      r0,[r1,#0x18]
000010  0540              LSLS     r0,r0,#21
000012  d4fc              BMI      |L5.14|
;;;323            DEBUG_PORT->THR = '\r';
000014  200d              MOVS     r0,#0xd
000016  6008              STR      r0,[r1,#0]
                  |L5.24|
;;;324        }
;;;325    #endif
;;;326    }
000018  4770              BX       lr
;;;327    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40050000

                          AREA ||i._ttywrch||, CODE, READONLY, ALIGN=1

                  _ttywrch PROC
;;;435    /*---------------------------------------------------------------------------------------------------------*/
;;;436    void _ttywrch(int ch)
000000  b500              PUSH     {lr}
000002  f7fffffe          BL       SendChar_ToUART
;;;437    {
;;;438        SendChar(ch);
;;;439        return;
;;;440    }
000006  bd00              POP      {pc}
;;;441    
                          ENDP


                          AREA ||i.ferror||, CODE, READONLY, ALIGN=1

                  ferror PROC
;;;453    
;;;454    int ferror(FILE *f)
000000  2000              MOVS     r0,#0
;;;455    {
;;;456        return EOF;
000002  43c0              MVNS     r0,r0
;;;457    }
000004  4770              BX       lr
;;;458    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;447    
;;;448    int fgetc(FILE *f)
000000  b500              PUSH     {lr}
;;;449    {
;;;450        return (GetChar());
000002  f7fffffe          BL       GetChar
;;;451    }
000006  bd00              POP      {pc}
;;;452    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;441    
;;;442    int fputc(int ch, FILE *f)
000000  b500              PUSH     {lr}
;;;443    {
000002  4603              MOV      r3,r0
000004  f7fffffe          BL       SendChar_ToUART
;;;444        SendChar(ch);
;;;445        return ch;
000008  4618              MOV      r0,r3
;;;446    }
00000a  bd00              POP      {pc}
;;;447    
                          ENDP


                          AREA ||i.kbhit||, CODE, READONLY, ALIGN=2

                  kbhit PROC
;;;406      */
;;;407    int kbhit(void)
000000  4802              LDR      r0,|L10.12|
;;;408    {
;;;409    #ifndef DISABLE_UART
;;;410        return !(DEBUG_PORT->FSR & UART_FSR_RX_EMPTY_F_Msk);
000002  6980              LDR      r0,[r0,#0x18]
000004  0780              LSLS     r0,r0,#30
000006  17c0              ASRS     r0,r0,#31
000008  1c40              ADDS     r0,r0,#1
;;;411    #else
;;;412        return(0);
;;;413    #endif
;;;414    }
00000a  4770              BX       lr
;;;415    
                          ENDP

                  |L10.12|
                          DCD      0x40050000

                          AREA ||i.stackDump||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  stackDump PROC
;;;48     
;;;49     void stackDump(uint32_t stack[])
000000  b510              PUSH     {r4,lr}
;;;50     {
000002  4604              MOV      r4,r0
;;;51     	printf("r0  = 0x%x\n", stack[r0]);
000004  6801              LDR      r1,[r0,#0]
000006  a010              ADR      r0,|L11.72|
000008  f7fffffe          BL       __2printf
;;;52     	printf("r1  = 0x%x\n", stack[r1]);
00000c  a011              ADR      r0,|L11.84|
00000e  6861              LDR      r1,[r4,#4]
000010  f7fffffe          BL       __2printf
;;;53     	printf("r2  = 0x%x\n", stack[r2]);
000014  a012              ADR      r0,|L11.96|
000016  68a1              LDR      r1,[r4,#8]
000018  f7fffffe          BL       __2printf
;;;54     	printf("r3  = 0x%x\n", stack[r3]);
00001c  a013              ADR      r0,|L11.108|
00001e  68e1              LDR      r1,[r4,#0xc]
000020  f7fffffe          BL       __2printf
;;;55     	printf("r12 = 0x%x\n", stack[r12]);
000024  a014              ADR      r0,|L11.120|
000026  6921              LDR      r1,[r4,#0x10]
000028  f7fffffe          BL       __2printf
;;;56     	printf("lr  = 0x%x\n", stack[lr]);
00002c  a015              ADR      r0,|L11.132|
00002e  6961              LDR      r1,[r4,#0x14]
000030  f7fffffe          BL       __2printf
;;;57     	printf("pc  = 0x%x\n", stack[pc]);
000034  a016              ADR      r0,|L11.144|
000036  69a1              LDR      r1,[r4,#0x18]
000038  f7fffffe          BL       __2printf
;;;58     	printf("psr = 0x%x\n", stack[psr]);
00003c  a017              ADR      r0,|L11.156|
00003e  69e1              LDR      r1,[r4,#0x1c]
000040  f7fffffe          BL       __2printf
;;;59     } 
000044  bd10              POP      {r4,pc}
;;;60     
                          ENDP

000046  0000              DCW      0x0000
                  |L11.72|
000048  72302020          DCB      "r0  = 0x%x\n",0
00004c  3d203078
000050  25780a00
                  |L11.84|
000054  72312020          DCB      "r1  = 0x%x\n",0
000058  3d203078
00005c  25780a00
                  |L11.96|
000060  72322020          DCB      "r2  = 0x%x\n",0
000064  3d203078
000068  25780a00
                  |L11.108|
00006c  72332020          DCB      "r3  = 0x%x\n",0
000070  3d203078
000074  25780a00
                  |L11.120|
000078  72313220          DCB      "r12 = 0x%x\n",0
00007c  3d203078
000080  25780a00
                  |L11.132|
000084  6c722020          DCB      "lr  = 0x%x\n",0
000088  3d203078
00008c  25780a00
                  |L11.144|
000090  70632020          DCB      "pc  = 0x%x\n",0
000094  3d203078
000098  25780a00
                  |L11.156|
00009c  70737220          DCB      "psr = 0x%x\n",0
0000a0  3d203078
0000a4  25780a00

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  __stdin
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\retarget.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_8c64092a____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_retarget_c_8c64092a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_retarget_c_8c64092a____REVSH|
#line 402
|__asm___10_retarget_c_8c64092a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |HardFault_Handler|
#line 289 "..\\..\\..\\..\\Library\\StdDriver\\src\\retarget.c"
|HardFault_Handler| PROC
#line 290

 MOVS r0, #4 
 MOV r1, LR 
 TST r0, r1 
 BEQ Stack_Use_MSP 
 MRS R0, PSP 
 B Get_LR_and_Branch 
Stack_Use_MSP 
 MRS R0, MSP 
Get_LR_and_Branch 
 MOV R1, LR 
 LDR R2,= |Hard_Fault_Handler| 
 BX R2 
	ENDP

;*** End   embedded assembler ***
