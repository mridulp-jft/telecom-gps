; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --feedback=.\obj\PWRDWN_CHECK.fed --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\Device\Nuvoton\Nano100Series\Include -I..\..\..\Library\StdDriver\inc -I..\..\..\Library\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;30       */
;;;31     void CLK_DisableCKO(void)
000000  4802              LDR      r0,|L1.12|
;;;32     {
;;;33         /* Disable CKO0 clock source */
;;;34         CLK->APBCLK &= (~CLK_APBCLK_FDIV_EN_Msk);
000002  6881              LDR      r1,[r0,#8]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;35     }
00000a  4770              BX       lr
;;;36     
                          ENDP

                  |L1.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;472      */
;;;473    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  0fc1              LSRS     r1,r0,#31
;;;474    {
;;;475        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  &= ~(1<<MODULE_IP_EN_Pos(u32ModuleIdx));
000002  008a              LSLS     r2,r1,#2
000004  4904              LDR      r1,|L2.24|
000006  1851              ADDS     r1,r2,r1
000008  684a              LDR      r2,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2001              MOVS     r0,#1
000010  4098              LSLS     r0,r0,r3
000012  4382              BICS     r2,r2,r0
000014  604a              STR      r2,[r1,#4]
;;;476    }
000016  4770              BX       lr
;;;477    
                          ENDP

                  |L2.24|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;535      */
;;;536    void CLK_DisablePLL(void)
000000  4802              LDR      r0,|L3.12|
;;;537    {
;;;538        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000002  6a41              LDR      r1,[r0,#0x24]
000004  01c2              LSLS     r2,r0,#7
000006  4311              ORRS     r1,r1,r2
000008  6241              STR      r1,[r0,#0x24]
;;;539    }
00000a  4770              BX       lr
;;;540    
                          ENDP

                  |L3.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;587      */
;;;588    void CLK_DisableSysTick(void)
000000  4901              LDR      r1,|L4.8|
;;;589    {
;;;590        SysTick->CTRL = 0;    /* Set System Tick counter disabled */
000002  2000              MOVS     r0,#0
000004  6108              STR      r0,[r1,#0x10]
;;;591    }
000006  4770              BX       lr
;;;592    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;388      */
;;;389    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;390    {
;;;391        CLK->PWRCTL &= ~u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;392    }
000008  4770              BX       lr
;;;393    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;53       */
;;;54     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  2210              MOVS     r2,#0x10
;;;55     {
;;;56         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;57         CLK->FRQDIV = CLK_FRQDIV_FDIV_EN_Msk | u32ClkDiv ;
000002  4311              ORRS     r1,r1,r2
000004  4a05              LDR      r2,|L6.28|
000006  6291              STR      r1,[r2,#0x28]
;;;58     
;;;59         /* Enable CKO clock source */
;;;60         CLK->APBCLK |= CLK_APBCLK_FDIV_EN_Msk;
000008  6891              LDR      r1,[r2,#8]
00000a  2340              MOVS     r3,#0x40
00000c  4319              ORRS     r1,r1,r3
00000e  6091              STR      r1,[r2,#8]
;;;61     
;;;62         /* Select CKO clock source */
;;;63         CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_FRQDIV_S_Msk)) | u32ClkSrc;
000010  6991              LDR      r1,[r2,#0x18]
000012  230c              MOVS     r3,#0xc
000014  4399              BICS     r1,r1,r3
000016  4301              ORRS     r1,r1,r0
000018  6191              STR      r1,[r2,#0x18]
;;;64     }
00001a  4770              BX       lr
;;;65     
                          ENDP

                  |L6.28|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;430      */
;;;431    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  0fc1              LSRS     r1,r0,#31
;;;432    {
;;;433        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  |= 1<<MODULE_IP_EN_Pos(u32ModuleIdx);
000002  008a              LSLS     r2,r1,#2
000004  4904              LDR      r1,|L7.24|
000006  1851              ADDS     r1,r2,r1
000008  684a              LDR      r2,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2001              MOVS     r0,#1
000010  4098              LSLS     r0,r0,r3
000012  4302              ORRS     r2,r2,r0
000014  604a              STR      r2,[r1,#4]
;;;434    }
000016  4770              BX       lr
;;;435    
                          ENDP

                  |L7.24|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;485      */
;;;486    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b57f              PUSH     {r0-r6,lr}
;;;487    {
;;;488        uint32_t u32ClkSrc,u32NR, u32NF,u32Register;
;;;489        uint32_t u32NRTable[4]= {2,4,8,16};
000002  4a1d              LDR      r2,|L8.120|
000004  460b              MOV      r3,r1                 ;487
000006  ca36              LDM      r2,{r1,r2,r4,r5}
000008  466e              MOV      r6,sp
00000a  c636              STM      r6!,{r1,r2,r4,r5}
;;;490        int32_t i32NRVal;
;;;491        if ( u32PllFreq < FREQ_48MHZ)
00000c  491b              LDR      r1,|L8.124|
00000e  428b              CMP      r3,r1
000010  d302              BCC      |L8.24|
;;;492            u32PllFreq=FREQ_48MHZ;
;;;493        else if(u32PllFreq > FREQ_120MHZ)
000012  491b              LDR      r1,|L8.128|
000014  428b              CMP      r3,r1
000016  d900              BLS      |L8.26|
                  |L8.24|
;;;494            u32PllFreq=FREQ_120MHZ;
000018  460b              MOV      r3,r1
                  |L8.26|
;;;495    
;;;496        if(u32PllClkSrc!=CLK_PLLCTL_PLL_SRC_HIRC) {
00001a  2401              MOVS     r4,#1
00001c  0464              LSLS     r4,r4,#17
00001e  42a0              CMP      r0,r4
000020  d000              BEQ      |L8.36|
;;;497            /* PLL source clock from HXT */
;;;498            u32Register = (0x0UL<<CLK_PLLCTL_PLL_SRC_Pos);
000022  2400              MOVS     r4,#0
                  |L8.36|
;;;499            u32ClkSrc = __HXT;
;;;500        } else {
;;;501            /* PLL source clock from HIRC */
;;;502            u32Register = (0x1UL<<CLK_PLLCTL_PLL_SRC_Pos);
;;;503            u32ClkSrc =__HIRC12M;
;;;504        }
;;;505    
;;;506        u32NF = u32PllFreq / 1000000;
000024  4917              LDR      r1,|L8.132|
000026  4618              MOV      r0,r3
000028  f7fffffe          BL       __aeabi_uidivmod
;;;507        u32NR = u32ClkSrc / 1000000;
;;;508        if(u32ClkSrc%12==0) {
;;;509            u32NF=(u32NF/3)*4;
00002c  2103              MOVS     r1,#3
00002e  f7fffffe          BL       __aeabi_uidivmod
000032  0082              LSLS     r2,r0,#2
;;;510            u32NR=(u32NR/3)*4;
000034  2010              MOVS     r0,#0x10
000036  e003              B        |L8.64|
                  |L8.56|
;;;511        }
;;;512    
;;;513        while( u32NR>16 || u32NF>(0x3F+32) ) {
;;;514            u32NR = u32NR>>1;
000038  0840              LSRS     r0,r0,#1
;;;515            u32NF = u32NF>>1;
00003a  0852              LSRS     r2,r2,#1
00003c  2810              CMP      r0,#0x10              ;513
00003e  d8fb              BHI      |L8.56|
                  |L8.64|
000040  2a5f              CMP      r2,#0x5f              ;513
000042  d8f9              BHI      |L8.56|
;;;516        }
;;;517    
;;;518        for(i32NRVal=3; i32NRVal>=0; i32NRVal--)
000044  2103              MOVS     r1,#3
000046  466b              MOV      r3,sp                 ;489
                  |L8.72|
;;;519            if(u32NR==u32NRTable[i32NRVal]) break;
000048  008d              LSLS     r5,r1,#2
00004a  595d              LDR      r5,[r3,r5]
00004c  4285              CMP      r5,r0
00004e  d001              BEQ      |L8.84|
000050  1e49              SUBS     r1,r1,#1
000052  d5f9              BPL      |L8.72|
                  |L8.84|
;;;520    
;;;521        CLK->PLLCTL = u32Register | (i32NRVal<<8) | (u32NF - 32) ;
000054  0209              LSLS     r1,r1,#8
000056  4321              ORRS     r1,r1,r4
000058  3a20              SUBS     r2,r2,#0x20
00005a  480b              LDR      r0,|L8.136|
00005c  4311              ORRS     r1,r1,r2
00005e  6241              STR      r1,[r0,#0x24]
;;;522    
;;;523        CLK->PLLCTL &= ~CLK_PLLCTL_PD_Msk;
000060  6a41              LDR      r1,[r0,#0x24]
000062  01c2              LSLS     r2,r0,#7
000064  4391              BICS     r1,r1,r2
000066  6241              STR      r1,[r0,#0x24]
;;;524    
;;;525        CLK_WaitClockReady(CLK_CLKSTATUS_PLL_STB_Msk);
000068  2004              MOVS     r0,#4
00006a  f7fffffe          BL       CLK_WaitClockReady
;;;526    
;;;527        return CLK_GetPLLClockFreq();
00006e  f7fffffe          BL       CLK_GetPLLClockFreq
;;;528    
;;;529    }
000072  b004              ADD      sp,sp,#0x10
000074  bd70              POP      {r4-r6,pc}
;;;530    
                          ENDP

000076  0000              DCW      0x0000
                  |L8.120|
                          DCD      ||.constdata||
                  |L8.124|
                          DCD      0x02dc6c00
                  |L8.128|
                          DCD      0x07270e00
                  |L8.132|
                          DCD      0x000f4240
                  |L8.136|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;569      */
;;;570    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b510              PUSH     {r4,lr}
;;;571    {
;;;572        SysTick->CTRL=0;
000002  4a09              LDR      r2,|L9.40|
000004  2300              MOVS     r3,#0
000006  6113              STR      r3,[r2,#0x10]
;;;573        if( u32ClkSrc== CLK_CLKSEL0_STCLKSEL_HCLK )    /* Set System Tick clock source */
;;;574            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
000008  2404              MOVS     r4,#4
00000a  2801              CMP      r0,#1                 ;573
;;;575        else {
;;;576            SysTick->CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk;
00000c  6910              LDR      r0,[r2,#0x10]
00000e  d008              BEQ      |L9.34|
000010  43a0              BICS     r0,r0,r4
                  |L9.18|
000012  6110              STR      r0,[r2,#0x10]
;;;577        }
;;;578        SysTick->LOAD  = u32Count;                /* Set System Tick reload value */
000014  6151              STR      r1,[r2,#0x14]
;;;579        SysTick->VAL = 0;                         /* Clear System Tick current value and counter flag  */
000016  6193              STR      r3,[r2,#0x18]
;;;580        SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk; /* Set System Tick counter enabled */
000018  6910              LDR      r0,[r2,#0x10]
00001a  2101              MOVS     r1,#1
00001c  4308              ORRS     r0,r0,r1
00001e  6110              STR      r0,[r2,#0x10]
;;;581    }
000020  bd10              POP      {r4,pc}
                  |L9.34|
000022  4320              ORRS     r0,r0,r4              ;574
000024  e7f5              B        |L9.18|
;;;582    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0xe000e000

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;363      */
;;;364    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;365    {
000002  4604              MOV      r4,r0
;;;366        CLK->PWRCTL |= u32ClkMask;
000004  480c              LDR      r0,|L10.56|
000006  6801              LDR      r1,[r0,#0]
000008  4321              ORRS     r1,r1,r4
00000a  6001              STR      r1,[r0,#0]
;;;367        if(u32ClkMask & CLK_PWRCTL_HXT_EN_Msk)
00000c  07e0              LSLS     r0,r4,#31
00000e  d002              BEQ      |L10.22|
;;;368            CLK_WaitClockReady(CLK_CLKSTATUS_HXT_STB_Msk);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       CLK_WaitClockReady
                  |L10.22|
;;;369    
;;;370        if(u32ClkMask & CLK_PWRCTL_LXT_EN_Msk)
000016  07a0              LSLS     r0,r4,#30
000018  d502              BPL      |L10.32|
;;;371            CLK_WaitClockReady(CLK_CLKSTATUS_LXT_STB_Msk);
00001a  2002              MOVS     r0,#2
00001c  f7fffffe          BL       CLK_WaitClockReady
                  |L10.32|
;;;372    
;;;373        if(u32ClkMask & CLK_PWRCTL_HIRC_EN_Msk)
000020  0760              LSLS     r0,r4,#29
000022  d502              BPL      |L10.42|
;;;374            CLK_WaitClockReady(CLK_CLKSTATUS_HIRC_STB_Msk);
000024  2010              MOVS     r0,#0x10
000026  f7fffffe          BL       CLK_WaitClockReady
                  |L10.42|
;;;375    
;;;376        if(u32ClkMask & CLK_PWRCTL_LIRC_EN_Msk)
00002a  0720              LSLS     r0,r4,#28
00002c  d502              BPL      |L10.52|
;;;377            CLK_WaitClockReady(CLK_CLKSTATUS_LIRC_STB_Msk);
00002e  2008              MOVS     r0,#8
000030  f7fffffe          BL       CLK_WaitClockReady
                  |L10.52|
;;;378    }
000034  bd10              POP      {r4,pc}
;;;379    
                          ENDP

000036  0000              DCW      0x0000
                  |L10.56|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;129      */
;;;130    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;131    {
;;;132        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;133        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;134    }
00000a  bd10              POP      {r4,pc}
;;;135    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;117      */
;;;118    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;121        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;122    }
00000a  bd10              POP      {r4,pc}
;;;123    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;92       */
;;;93     uint32_t CLK_GetHXTFreq(void)
000000  4802              LDR      r0,|L13.12|
;;;94     {
;;;95         if(CLK->PWRCTL & CLK_PWRCTL_HXT_EN )
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d000              BEQ      |L13.10|
;;;96             return __HXT;
000008  4801              LDR      r0,|L13.16|
                  |L13.10|
;;;97         else
;;;98             return 0;
;;;99     }
00000a  4770              BX       lr
;;;100    
                          ENDP

                  |L13.12|
                          DCD      0x50000200
                  |L13.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;104      */
;;;105    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;106    {
;;;107        if(CLK->PWRCTL & CLK_PWRCTL_LXT_EN )
000002  6800              LDR      r0,[r0,#0]
000004  0780              LSLS     r0,r0,#30
000006  d502              BPL      |L14.14|
;;;108            return __LXT;
000008  2001              MOVS     r0,#1
00000a  03c0              LSLS     r0,r0,#15
;;;109        else
;;;110            return 0;
;;;111    }
00000c  4770              BX       lr
                  |L14.14|
00000e  2000              MOVS     r0,#0                 ;110
000010  4770              BX       lr
;;;112    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;140      */
;;;141    uint32_t CLK_GetPLLClockFreq(void)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143        uint32_t u32Freq =0, u32PLLSrc;
;;;144        uint32_t u32NO, u32NR, u32IN_DV, u32PllReg;
;;;145    
;;;146        u32PllReg = CLK->PLLCTL;
000002  4812              LDR      r0,|L15.76|
000004  6a40              LDR      r0,[r0,#0x24]
;;;147    
;;;148        if (u32PllReg & CLK_PLLCTL_PD)
000006  03c1              LSLS     r1,r0,#15
000008  d501              BPL      |L15.14|
;;;149            return 0;  /* PLL is in power down mode */
00000a  2000              MOVS     r0,#0
;;;150    
;;;151        if (u32PllReg & CLK_PLLCTL_PLL_SRC_Msk)
;;;152            u32PLLSrc = __HIRC12M;
;;;153        else
;;;154            u32PLLSrc = __HXT;
;;;155    
;;;156        u32NO = (u32PllReg & CLK_PLLCTL_OUT_DV) ? 2: 1;
;;;157    
;;;158        u32IN_DV = (u32PllReg & CLK_PLLCTL_IN_DV_Msk) >> 8;
;;;159        if (u32IN_DV == 0)
;;;160            u32NR = 2;
;;;161        else if (u32IN_DV == 1)
;;;162            u32NR = 4;
;;;163        else if (u32IN_DV == 2)
;;;164            u32NR = 8;
;;;165        else
;;;166            u32NR = 16;
;;;167        u32Freq = u32PLLSrc * ((u32PllReg & CLK_PLLCTL_FB_DV_Msk) +32) / u32NR / u32NO;
;;;168        return u32Freq;
;;;169    }
00000c  bd10              POP      {r4,pc}
                  |L15.14|
00000e  04c1              LSLS     r1,r0,#19             ;156
000010  d501              BPL      |L15.22|
000012  2402              MOVS     r4,#2                 ;156
000014  e000              B        |L15.24|
                  |L15.22|
000016  2401              MOVS     r4,#1                 ;156
                  |L15.24|
000018  0581              LSLS     r1,r0,#22             ;158
00001a  0f89              LSRS     r1,r1,#30             ;158
00001c  d00f              BEQ      |L15.62|
00001e  2901              CMP      r1,#1                 ;161
000020  d00f              BEQ      |L15.66|
000022  2902              CMP      r1,#2                 ;163
000024  d00f              BEQ      |L15.70|
000026  2110              MOVS     r1,#0x10              ;166
                  |L15.40|
000028  0680              LSLS     r0,r0,#26             ;167
00002a  0e80              LSRS     r0,r0,#26             ;167
00002c  4a08              LDR      r2,|L15.80|
00002e  3020              ADDS     r0,r0,#0x20           ;167
000030  4350              MULS     r0,r2,r0              ;167
000032  f7fffffe          BL       __aeabi_uidivmod
000036  4621              MOV      r1,r4                 ;167
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  bd10              POP      {r4,pc}
                  |L15.62|
00003e  2102              MOVS     r1,#2                 ;160
000040  e7f2              B        |L15.40|
                  |L15.66|
000042  2104              MOVS     r1,#4                 ;162
000044  e7f0              B        |L15.40|
                  |L15.70|
000046  2108              MOVS     r1,#8                 ;164
000048  e7ee              B        |L15.40|
;;;170    
                          ENDP

00004a  0000              DCW      0x0000
                  |L15.76|
                          DCD      0x50000200
                  |L15.80|
                          DCD      0x00b71b00

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;81       */
;;;82     void CLK_Idle(void)
000000  4803              LDR      r0,|L16.16|
;;;83     {
;;;84         CLK->PWRCTL &= ~(CLK_PWRCTL_PD_EN_Msk );
000002  6801              LDR      r1,[r0,#0]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;85         __WFI();
00000a  bf30              WFI      
;;;86     }
00000c  4770              BX       lr
;;;87     
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;70       */
;;;71     void CLK_PowerDown(void)
000000  4904              LDR      r1,|L17.20|
;;;72     {
;;;73         SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
000002  2004              MOVS     r0,#4
000004  6108              STR      r0,[r1,#0x10]
;;;74         CLK->PWRCTL |= (CLK_PWRCTL_PD_EN_Msk | CLK_PWRCTL_WK_DLY_Msk );
000006  4804              LDR      r0,|L17.24|
000008  6801              LDR      r1,[r0,#0]
00000a  2250              MOVS     r2,#0x50
00000c  4311              ORRS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;75         __WFI();
000010  bf30              WFI      
;;;76     }
000012  4770              BX       lr
;;;77     
                          ENDP

                  |L17.20|
                          DCD      0xe000ed00
                  |L17.24|
                          DCD      0x50000200

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;175      */
;;;176    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b5f8              PUSH     {r3-r7,lr}
;;;177    {
;;;178        uint32_t u32HIRCSTB;
;;;179        /* Read HIRC clock source stable flag */
;;;180        u32HIRCSTB = CLK->CLKSTATUS & CLK_CLKSTATUS_HIRC_STB_Msk;
000002  4d19              LDR      r5,|L18.104|
000004  68ec              LDR      r4,[r5,#0xc]
000006  2610              MOVS     r6,#0x10
;;;181    
;;;182        if(u32Hclk==__HIRC12M) {
000008  4918              LDR      r1,|L18.108|
00000a  4034              ANDS     r4,r4,r6              ;180
;;;183            CLK_EnableXtalRC(CLK_PWRCTL_HIRC_EN_Msk);
;;;184            CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_HIRC,CLK_HCLK_CLK_DIVIDER(1));
;;;185            return SystemCoreClock;
00000c  4f18              LDR      r7,|L18.112|
00000e  4288              CMP      r0,r1                 ;182
000010  d107              BNE      |L18.34|
000012  2004              MOVS     r0,#4                 ;183
000014  f7fffffe          BL       CLK_EnableXtalRC
000018  2100              MOVS     r1,#0                 ;184
00001a  2007              MOVS     r0,#7                 ;184
00001c  f7fffffe          BL       CLK_SetHCLK
000020  e01f              B        |L18.98|
                  |L18.34|
;;;186        }
;;;187    
;;;188        if(u32Hclk<FREQ_24MHZ) u32Hclk=FREQ_24MHZ;
000022  4914              LDR      r1,|L18.116|
000024  4288              CMP      r0,r1
000026  d302              BCC      |L18.46|
;;;189        if(u32Hclk>FREQ_42MHZ) u32Hclk=FREQ_42MHZ;
000028  4913              LDR      r1,|L18.120|
00002a  4288              CMP      r0,r1
00002c  d900              BLS      |L18.48|
                  |L18.46|
00002e  4608              MOV      r0,r1                 ;188
                  |L18.48|
;;;190    
;;;191        if(CLK->PWRCTL & CLK_PWRCTL_HXT_EN)
000030  6829              LDR      r1,[r5,#0]
000032  07c9              LSLS     r1,r1,#31
000034  d004              BEQ      |L18.64|
;;;192            CLK_EnablePLL(CLK_PLLCTL_PLL_SRC_HXT,u32Hclk*2);
000036  0041              LSLS     r1,r0,#1
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       CLK_EnablePLL
00003e  e006              B        |L18.78|
                  |L18.64|
;;;193        else {
;;;194            CLK_EnablePLL(CLK_PLLCTL_PLL_SRC_HIRC,u32Hclk*2);
000040  0041              LSLS     r1,r0,#1
000042  2001              MOVS     r0,#1
000044  0440              LSLS     r0,r0,#17
000046  f7fffffe          BL       CLK_EnablePLL
;;;195    
;;;196            /* Read HIRC clock source stable flag */
;;;197            u32HIRCSTB = CLK->CLKSTATUS & CLK_CLKSTATUS_HIRC_STB_Msk;
00004a  68ec              LDR      r4,[r5,#0xc]
00004c  4034              ANDS     r4,r4,r6
                  |L18.78|
;;;198        }
;;;199        CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_PLL,CLK_HCLK_CLK_DIVIDER(2));
00004e  2101              MOVS     r1,#1
000050  2002              MOVS     r0,#2
000052  f7fffffe          BL       CLK_SetHCLK
;;;200    
;;;201        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;202        if(u32HIRCSTB == 0)
000056  2c00              CMP      r4,#0
000058  d103              BNE      |L18.98|
;;;203            CLK->PWRCTL &= ~CLK_PWRCTL_HIRC_EN_Msk;
00005a  6828              LDR      r0,[r5,#0]
00005c  2104              MOVS     r1,#4
00005e  4388              BICS     r0,r0,r1
000060  6028              STR      r0,[r5,#0]
                  |L18.98|
;;;204    
;;;205        return SystemCoreClock;
000062  6838              LDR      r0,[r7,#0]  ; SystemCoreClock
;;;206    }
000064  bdf8              POP      {r3-r7,pc}
;;;207    
                          ENDP

000066  0000              DCW      0x0000
                  |L18.104|
                          DCD      0x50000200
                  |L18.108|
                          DCD      0x00b71b00
                  |L18.112|
                          DCD      SystemCoreClock
                  |L18.116|
                          DCD      0x016e3600
                  |L18.120|
                          DCD      0x0280de80

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;219      */
;;;220    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;221    {
;;;222        uint32_t u32HIRCSTB;
;;;223    
;;;224        /* Read HIRC clock source stable flag */
;;;225        u32HIRCSTB = CLK->CLKSTATUS & CLK_CLKSTATUS_HIRC_STB_Msk;
000002  4c11              LDR      r4,|L19.72|
000004  b081              SUB      sp,sp,#4              ;221
000006  68e5              LDR      r5,[r4,#0xc]
000008  460f              MOV      r7,r1                 ;221
00000a  2610              MOVS     r6,#0x10
;;;226    
;;;227        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;228        CLK->PWRCTL |= CLK_PWRCTL_HIRC_EN_Msk;
00000c  6820              LDR      r0,[r4,#0]
00000e  4035              ANDS     r5,r5,r6              ;225
000010  2104              MOVS     r1,#4
000012  4308              ORRS     r0,r0,r1
000014  6020              STR      r0,[r4,#0]
;;;229        CLK_WaitClockReady(CLK_CLKSTATUS_HIRC_STB_Msk);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       CLK_WaitClockReady
;;;230        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLK_S_Msk)) | CLK_CLKSEL0_HCLK_S_HIRC;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  2107              MOVS     r1,#7
000020  4308              ORRS     r0,r0,r1
000022  6120              STR      r0,[r4,#0x10]
;;;231    
;;;232        CLK->CLKDIV0 = (CLK->CLKDIV0 & ~CLK_CLKDIV0_HCLK_N_Msk) | u32ClkDiv;
000024  69e0              LDR      r0,[r4,#0x1c]
000026  0900              LSRS     r0,r0,#4
000028  0100              LSLS     r0,r0,#4
00002a  4338              ORRS     r0,r0,r7
00002c  61e0              STR      r0,[r4,#0x1c]
;;;233        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_HCLK_S_Msk) | u32ClkSrc;
00002e  6920              LDR      r0,[r4,#0x10]
000030  4388              BICS     r0,r0,r1
000032  9901              LDR      r1,[sp,#4]
000034  4308              ORRS     r0,r0,r1
000036  6120              STR      r0,[r4,#0x10]
;;;234        SystemCoreClockUpdate();
000038  f7fffffe          BL       SystemCoreClockUpdate
;;;235    
;;;236        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;237        if(u32HIRCSTB == 0)
00003c  2d00              CMP      r5,#0
00003e  d102              BNE      |L19.70|
;;;238            CLK->PWRCTL &= ~CLK_CLKSTATUS_HIRC_STB_Msk;
000040  6820              LDR      r0,[r4,#0]
000042  43b0              BICS     r0,r0,r6
000044  6020              STR      r0,[r4,#0]
                  |L19.70|
;;;239    }
000046  bdfe              POP      {r1-r7,pc}
;;;240    
                          ENDP

                  |L19.72|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;335    
;;;336    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;337    {
;;;338        uint32_t u32tmp=0,u32sel=0,u32div=0;
;;;339    
;;;340        if(MODULE_CLKDIV_Msk(u32ModuleIdx)!=MODULE_NoMsk) {
000002  0a84              LSRS     r4,r0,#10
000004  0623              LSLS     r3,r4,#24
000006  0e1b              LSRS     r3,r3,#24
000008  d00c              BEQ      |L20.36|
;;;341            u32div =(uint32_t)&CLK->CLKDIV0+((MODULE_CLKDIV(u32ModuleIdx))*4);
00000a  0303              LSLS     r3,r0,#12
00000c  0f9b              LSRS     r3,r3,#30
00000e  4d0f              LDR      r5,|L20.76|
000010  009b              LSLS     r3,r3,#2
000012  195b              ADDS     r3,r3,r5
;;;342            u32tmp = *(volatile uint32_t *)(u32div);
000014  681d              LDR      r5,[r3,#0]
;;;343            u32tmp = ( u32tmp & ~(MODULE_CLKDIV_Msk(u32ModuleIdx)<<MODULE_CLKDIV_Pos(u32ModuleIdx)) ) | u32ClkDiv;
000016  0586              LSLS     r6,r0,#22
000018  b2e4              UXTB     r4,r4
00001a  0ef6              LSRS     r6,r6,#27
00001c  40b4              LSLS     r4,r4,r6
00001e  43a5              BICS     r5,r5,r4
000020  4315              ORRS     r5,r5,r2
;;;344            *(volatile uint32_t *)(u32div) = u32tmp;
000022  601d              STR      r5,[r3,#0]
                  |L20.36|
;;;345        }
;;;346    
;;;347        if(MODULE_CLKSEL_Msk(u32ModuleIdx)!=MODULE_NoMsk) {
000024  0e42              LSRS     r2,r0,#25
000026  0712              LSLS     r2,r2,#28
000028  d00e              BEQ      |L20.72|
;;;348            u32sel = (uint32_t)&CLK->CLKSEL0+((MODULE_CLKSEL(u32ModuleIdx))*4);
00002a  0042              LSLS     r2,r0,#1
00002c  4b07              LDR      r3,|L20.76|
00002e  0f92              LSRS     r2,r2,#30
000030  0092              LSLS     r2,r2,#2
000032  3b0c              SUBS     r3,r3,#0xc
000034  18d2              ADDS     r2,r2,r3
;;;349            u32tmp = *(volatile uint32_t *)(u32sel);
000036  6813              LDR      r3,[r2,#0]
;;;350            u32tmp = ( u32tmp & ~(MODULE_CLKSEL_Msk(u32ModuleIdx)<<MODULE_CLKSEL_Pos(u32ModuleIdx)) ) | u32ClkSrc;
000038  00c4              LSLS     r4,r0,#3
00003a  0f24              LSRS     r4,r4,#28
00003c  01c0              LSLS     r0,r0,#7
00003e  0ec0              LSRS     r0,r0,#27
000040  4084              LSLS     r4,r4,r0
000042  43a3              BICS     r3,r3,r4
000044  430b              ORRS     r3,r3,r1
;;;351            *(volatile uint32_t *)(u32sel) = u32tmp;
000046  6013              STR      r3,[r2,#0]
                  |L20.72|
;;;352        }
;;;353    }
000048  bd70              POP      {r4-r6,pc}
;;;354    
                          ENDP

00004a  0000              DCW      0x0000
                  |L20.76|
                          DCD      0x5000021c

                          AREA ||i.CLK_SysTickDelay||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;548      */
;;;549    void CLK_SysTickDelay(uint32_t us)
000000  4906              LDR      r1,|L21.28|
;;;550    {
;;;551        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4348              MULS     r0,r1,r0
000006  4906              LDR      r1,|L21.32|
000008  6148              STR      r0,[r1,#0x14]
;;;552        SysTick->VAL  =  (0x00);
00000a  2200              MOVS     r2,#0
00000c  618a              STR      r2,[r1,#0x18]
;;;553        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00000e  2005              MOVS     r0,#5
000010  6108              STR      r0,[r1,#0x10]
                  |L21.18|
;;;554    
;;;555        /* Waiting for down-count to zero */
;;;556        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
000012  6908              LDR      r0,[r1,#0x10]
000014  03c0              LSLS     r0,r0,#15
000016  d5fc              BPL      |L21.18|
;;;557        SysTick->CTRL = 0;
000018  610a              STR      r2,[r1,#0x10]
;;;558    }
00001a  4770              BX       lr
;;;559    
                          ENDP

                  |L21.28|
                          DCD      CyclesPerUs
                  |L21.32|
                          DCD      0xe000e000

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;606      */
;;;607    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;608    {
000002  4604              MOV      r4,r0
;;;609        int32_t i32TimeOutCnt;
;;;610    
;;;611        i32TimeOutCnt = __HSI / 200; /* About 5ms */
000004  4907              LDR      r1,|L22.36|
;;;612    
;;;613        while((CLK->CLKSTATUS & u32ClkMask) != u32ClkMask) {
000006  4b08              LDR      r3,|L22.40|
000008  e005              B        |L22.22|
                  |L22.10|
;;;614            if(i32TimeOutCnt-- <= 0)
00000a  460a              MOV      r2,r1
00000c  1e49              SUBS     r1,r1,#1
00000e  2a00              CMP      r2,#0
000010  dc01              BGT      |L22.22|
;;;615                return 0;
000012  2000              MOVS     r0,#0
;;;616        }
;;;617        return 1;
;;;618    }
000014  bd10              POP      {r4,pc}
                  |L22.22|
000016  68da              LDR      r2,[r3,#0xc]          ;613
000018  4620              MOV      r0,r4                 ;613
00001a  4390              BICS     r0,r0,r2              ;613
00001c  d1f5              BNE      |L22.10|
00001e  2001              MOVS     r0,#1                 ;617
000020  bd10              POP      {r4,pc}
;;;619    
                          ENDP

000022  0000              DCW      0x0000
                  |L22.36|
                          DCD      0x0000ea60
                  |L22.40|
                          DCD      0x50000200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
