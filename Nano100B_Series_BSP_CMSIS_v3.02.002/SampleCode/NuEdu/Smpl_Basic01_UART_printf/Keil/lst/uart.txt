; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --feedback=.\obj\UART_printf.fed --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\NuEdu\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DDEBUG_PORT=UART1 --omf_browse=.\obj\uart.crf ..\..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  UART_ClearIntFlag PROC
;;;39      */
;;;40     void UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag)
000000  074a              LSLS     r2,r1,#29
;;;41     {
000002  d507              BPL      |L1.20|
;;;42     
;;;43         if(u32InterruptFlag & UART_ISR_RLS_IS_Msk) { /* clear Receive Line Status Interrupt */
;;;44             uart->FSR |= UART_FSR_BI_F_Msk | UART_FSR_FE_F_Msk | UART_FSR_FE_F_Msk;
000004  6982              LDR      r2,[r0,#0x18]
000006  2360              MOVS     r3,#0x60
000008  431a              ORRS     r2,r2,r3
00000a  6182              STR      r2,[r0,#0x18]
;;;45             uart->TRSR |= UART_TRSR_RS485_ADDET_F_Msk;
00000c  6942              LDR      r2,[r0,#0x14]
00000e  2301              MOVS     r3,#1
000010  431a              ORRS     r2,r2,r3
000012  6142              STR      r2,[r0,#0x14]
                  |L1.20|
;;;46         }
;;;47     
;;;48         if(u32InterruptFlag & UART_ISR_MODEM_IS_Msk)  /* clear Modem Interrupt */
000014  070a              LSLS     r2,r1,#28
000016  d504              BPL      |L1.34|
;;;49             uart->MCSR |= UART_MCSR_DCT_F_Msk;
000018  69c2              LDR      r2,[r0,#0x1c]
00001a  2301              MOVS     r3,#1
00001c  049b              LSLS     r3,r3,#18
00001e  431a              ORRS     r2,r2,r3
000020  61c2              STR      r2,[r0,#0x1c]
                  |L1.34|
;;;50     
;;;51         if(u32InterruptFlag & UART_ISR_BUF_ERR_IS_Msk) { /* clear Buffer Error Interrupt */
000022  068a              LSLS     r2,r1,#26
000024  d504              BPL      |L1.48|
;;;52             uart->FSR |= UART_FSR_RX_OVER_F_Msk | UART_FSR_TX_OVER_F_Msk;
000026  6982              LDR      r2,[r0,#0x18]
000028  23ff              MOVS     r3,#0xff
00002a  3302              ADDS     r3,#2
00002c  431a              ORRS     r2,r2,r3
00002e  6182              STR      r2,[r0,#0x18]
                  |L1.48|
;;;53         }
;;;54     
;;;55         if(u32InterruptFlag & UART_ISR_WAKE_IS_Msk) { /* clear wake up Interrupt */
000030  064a              LSLS     r2,r1,#25
000032  d503              BPL      |L1.60|
;;;56             uart->ISR |= UART_ISR_WAKE_IS_Msk;
000034  6902              LDR      r2,[r0,#0x10]
000036  2340              MOVS     r3,#0x40
000038  431a              ORRS     r2,r2,r3
00003a  6102              STR      r2,[r0,#0x10]
                  |L1.60|
;;;57         }
;;;58     
;;;59         if(u32InterruptFlag & UART_ISR_ABAUD_IS_Msk) { /* clear auto-baud rate Interrupt */
00003c  060a              LSLS     r2,r1,#24
00003e  d503              BPL      |L1.72|
;;;60             uart->TRSR |= UART_TRSR_ABAUD_TOUT_F_Msk | UART_TRSR_ABAUD_F_Msk;
000040  6942              LDR      r2,[r0,#0x14]
000042  2306              MOVS     r3,#6
000044  431a              ORRS     r2,r2,r3
000046  6142              STR      r2,[r0,#0x14]
                  |L1.72|
;;;61         }
;;;62     
;;;63         if(u32InterruptFlag & UART_ISR_LIN_IS_Msk) { /* clear LIN break Interrupt */
000048  05c9              LSLS     r1,r1,#23
00004a  d503              BPL      |L1.84|
;;;64             uart->TRSR |= UART_TRSR_LIN_TX_F_Msk | UART_TRSR_LIN_RX_F_Msk | UART_TRSR_BIT_ERR_F_Msk;
00004c  6941              LDR      r1,[r0,#0x14]
00004e  2238              MOVS     r2,#0x38
000050  4311              ORRS     r1,r1,r2
000052  6141              STR      r1,[r0,#0x14]
                  |L1.84|
;;;65         }
;;;66     
;;;67     }
000054  4770              BX       lr
;;;68     
                          ENDP


                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;76      */
;;;77     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;78     {
;;;79         uart->IER = 0;
000002  60c1              STR      r1,[r0,#0xc]
;;;80     }
000004  4770              BX       lr
;;;81     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;89      */
;;;90     void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;91     {
;;;92         uart->CTL &= ~(UART_CTL_AUTO_RTS_EN_Msk | UART_CTL_AUTO_CTS_EN_Msk);
000002  2230              MOVS     r2,#0x30
000004  4391              BICS     r1,r1,r2
000006  6041              STR      r1,[r0,#4]
;;;93     }
000008  4770              BX       lr
;;;94     
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;113     */
;;;114    void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  68c2              LDR      r2,[r0,#0xc]
;;;115    {
;;;116        uart->IER &= ~ u32InterruptFlag;
000002  438a              BICS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;117    }
000006  4770              BX       lr
;;;118    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=2

                  UART_EnableFlowCtrl PROC
;;;127     */
;;;128    void UART_EnableFlowCtrl(UART_T* uart )
000000  69c1              LDR      r1,[r0,#0x1c]
;;;129    {
;;;130        uart->MCSR |= UART_MCSR_LEV_RTS_Msk | UART_MCSR_LEV_CTS_Msk;
000002  4a04              LDR      r2,|L5.20|
000004  4311              ORRS     r1,r1,r2
000006  61c1              STR      r1,[r0,#0x1c]
;;;131        uart->CTL |= UART_CTL_AUTO_RTS_EN_Msk | UART_CTL_AUTO_CTS_EN_Msk;
000008  6841              LDR      r1,[r0,#4]
00000a  2230              MOVS     r2,#0x30
00000c  4311              ORRS     r1,r1,r2
00000e  6041              STR      r1,[r0,#4]
;;;132    }
000010  4770              BX       lr
;;;133    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x00010001

                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;152     */
;;;153    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  68c2              LDR      r2,[r0,#0xc]
;;;154    {
;;;155        uart->IER |= u32InterruptFlag;
000002  430a              ORRS     r2,r2,r1
000004  60c2              STR      r2,[r0,#0xc]
;;;156    }
000006  4770              BX       lr
;;;157    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;166     */
;;;167    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  b57f              PUSH     {r0-r6,lr}
;;;168    {
;;;169        uint8_t u8UartClkSrcSel;
;;;170        uint32_t u32ClkTbl[4] = {__HXT, __LXT, 0, __HIRC12M};
000002  4a19              LDR      r2,|L7.104|
000004  460e              MOV      r6,r1                 ;168
000006  4604              MOV      r4,r0                 ;168
000008  ca0f              LDM      r2,{r0-r3}
00000a  466d              MOV      r5,sp
00000c  c50f              STM      r5!,{r0-r3}
;;;171        uint32_t u32Baud_Div;
;;;172        uint32_t u32SrcFreq;
;;;173        uint32_t u32SrcFreqDiv;
;;;174    
;;;175        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART_S_Msk) >> CLK_CLKSEL1_UART_S_Pos;
00000e  4917              LDR      r1,|L7.108|
000010  6948              LDR      r0,[r1,#0x14]
;;;176    
;;;177        u32SrcFreq = u32ClkTbl[u8UartClkSrcSel];
000012  466a              MOV      r2,sp
000014  0780              LSLS     r0,r0,#30             ;175
000016  0f00              LSRS     r0,r0,#28
000018  5810              LDR      r0,[r2,r0]
;;;178    
;;;179        u32SrcFreqDiv = (((CLK->CLKDIV0 & CLK_CLKDIV0_UART_N_Msk) >> CLK_CLKDIV0_UART_N_Pos) + 1);
00001a  69c9              LDR      r1,[r1,#0x1c]
;;;180    
;;;181        if(u32SrcFreq == 0) {
;;;182            u32SrcFreq = SysGet_PLLClockFreq() / u32SrcFreqDiv;
;;;183        } else {
;;;184            u32SrcFreq = u32SrcFreq / u32SrcFreqDiv;
;;;185        }
;;;186    
;;;187        uart->FUN_SEL = UART_FUNC_SEL_UART;
;;;188        uart->TLCTL = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1 |
;;;189                      UART_TLCTL_RFITL_1BYTE | UART_TLCTL_RTS_TRI_LEV_1BYTE;
;;;190    
;;;191        if(u32baudrate != 0) {
;;;192            u32Baud_Div = UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32baudrate);
;;;193    
;;;194            if(u32Baud_Div > 0xFFFF)
;;;195                uart->BAUD = (UART_BAUD_MODE1 | UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32baudrate));
;;;196            else
;;;197                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
;;;198        }
;;;199    }
00001c  0509              LSLS     r1,r1,#20
00001e  0f0d              LSRS     r5,r1,#28
000020  1c6d              ADDS     r5,r5,#1
000022  2800              CMP      r0,#0                 ;181
000024  d101              BNE      |L7.42|
000026  f7fffffe          BL       SysGet_PLLClockFreq
                  |L7.42|
00002a  4629              MOV      r1,r5                 ;184
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  4605              MOV      r5,r0                 ;184
000032  2000              MOVS     r0,#0                 ;187
000034  63a0              STR      r0,[r4,#0x38]         ;187
000036  2003              MOVS     r0,#3                 ;188
000038  60a0              STR      r0,[r4,#8]            ;188
00003a  2e00              CMP      r6,#0                 ;191
00003c  d013              BEQ      |L7.102|
00003e  0870              LSRS     r0,r6,#1              ;192
000040  1940              ADDS     r0,r0,r5              ;192
000042  4631              MOV      r1,r6                 ;192
000044  f7fffffe          BL       __aeabi_uidivmod
000048  4909              LDR      r1,|L7.112|
00004a  1e40              SUBS     r0,r0,#1              ;194
00004c  4288              CMP      r0,r1                 ;194
00004e  d909              BLS      |L7.100|
000050  00f0              LSLS     r0,r6,#3              ;195
000052  1940              ADDS     r0,r0,r5              ;195
000054  4631              MOV      r1,r6                 ;195
000056  f7fffffe          BL       __aeabi_uidivmod
00005a  2101              MOVS     r1,#1                 ;195
00005c  0900              LSRS     r0,r0,#4              ;195
00005e  07c9              LSLS     r1,r1,#31             ;195
000060  1e40              SUBS     r0,r0,#1              ;195
000062  4308              ORRS     r0,r0,r1              ;195
                  |L7.100|
000064  6260              STR      r0,[r4,#0x24]         ;197
                  |L7.102|
000066  bd7f              POP      {r0-r6,pc}
;;;200    
                          ENDP

                  |L7.104|
                          DCD      ||.constdata||
                  |L7.108|
                          DCD      0x50000200
                  |L7.112|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;211     */
;;;212    uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;213    {
000002  4604              MOV      r4,r0
;;;214        uint32_t  u32Count, u32delayno;
;;;215    
;;;216        for(u32Count=0; u32Count < u32ReadBytes; u32Count++) {
000004  2000              MOVS     r0,#0
;;;217            u32delayno = 0;
;;;218    
;;;219            while(uart->FSR & UART_FSR_RX_EMPTY_F_Msk) { /* Check RX empty => failed */
;;;220                u32delayno++;
;;;221                if( u32delayno >= 0x40000000 )
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L8.38|
                  |L8.12|
00000c  2300              MOVS     r3,#0                 ;217
00000e  e004              B        |L8.26|
                  |L8.16|
000010  1c5b              ADDS     r3,r3,#1              ;219
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L8.26|
;;;222                    return FALSE;
000016  2000              MOVS     r0,#0
;;;223            }
;;;224            pu8RxBuf[u32Count] = uart->RBR;    /* Get Data from UART RX  */
;;;225        }
;;;226    
;;;227        return u32Count;
;;;228    
;;;229    }
000018  bd70              POP      {r4-r6,pc}
                  |L8.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;219
00001c  07b6              LSLS     r6,r6,#30             ;219
00001e  d4f7              BMI      |L8.16|
000020  6823              LDR      r3,[r4,#0]            ;224
000022  540b              STRB     r3,[r1,r0]            ;224
000024  1c40              ADDS     r0,r0,#1              ;224
                  |L8.38|
000026  4290              CMP      r0,r2                 ;216
000028  d3f0              BCC      |L8.12|
00002a  bd70              POP      {r4-r6,pc}
;;;230    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;300     */
;;;301    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f0              PUSH     {r4-r7,lr}
;;;302    {
000002  4604              MOV      r4,r0
;;;303        uint8_t u8UartClkSrcSel;
;;;304        uint32_t u32ClkTbl[4] = {__HXT, __LXT, 0, __HIRC12M};
000004  481a              LDR      r0,|L9.112|
000006  4615              MOV      r5,r2                 ;302
000008  460e              MOV      r6,r1                 ;302
00000a  c80f              LDM      r0,{r0-r3}
00000c  b085              SUB      sp,sp,#0x14           ;302
00000e  466f              MOV      r7,sp
000010  c70f              STM      r7!,{r0-r3}
;;;305        uint32_t u32SrcFreq;
;;;306        uint32_t u32SrcFreqDiv;
;;;307    
;;;308        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART_S_Msk) >> CLK_CLKSEL1_UART_S_Pos;
000012  4918              LDR      r1,|L9.116|
000014  6948              LDR      r0,[r1,#0x14]
;;;309    
;;;310        u32SrcFreq = u32ClkTbl[u8UartClkSrcSel];
000016  466a              MOV      r2,sp
000018  0780              LSLS     r0,r0,#30             ;308
00001a  0f00              LSRS     r0,r0,#28
00001c  5810              LDR      r0,[r2,r0]
;;;311    
;;;312        u32SrcFreqDiv = (((CLK->CLKDIV0 & CLK_CLKDIV0_UART_N_Msk) >> CLK_CLKDIV0_UART_N_Pos) + 1);
00001e  69c9              LDR      r1,[r1,#0x1c]
;;;313    
;;;314        if(u32SrcFreq == 0) {
;;;315            u32SrcFreq = SysGet_PLLClockFreq() / u32SrcFreqDiv;
;;;316        } else {
;;;317            u32SrcFreq = u32SrcFreq / u32SrcFreqDiv;
;;;318        }
;;;319    
;;;320        uart->BAUD = UART_BAUD_MODE1 | UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32Buadrate);
;;;321    
;;;322        uart->IRCR    &=  ~UART_IRCR_INV_TX_Msk;
;;;323        uart->IRCR |=     UART_IRCR_INV_RX_Msk;
;;;324        uart->IRCR    = u32Direction ? uart->IRCR | UART_IRCR_TX_SELECT_Msk : uart->IRCR &~ UART_IRCR_TX_SELECT_Msk;
;;;325        uart->FUN_SEL = (0x2 << UART_FUN_SEL_FUN_SEL_Pos);
;;;326    }
000020  0509              LSLS     r1,r1,#20
000022  0f0f              LSRS     r7,r1,#28
000024  1c7f              ADDS     r7,r7,#1
000026  2800              CMP      r0,#0                 ;314
000028  d101              BNE      |L9.46|
00002a  f7fffffe          BL       SysGet_PLLClockFreq
                  |L9.46|
00002e  4639              MOV      r1,r7                 ;317
000030  f7fffffe          BL       __aeabi_uidivmod
000034  00f1              LSLS     r1,r6,#3              ;320
000036  1808              ADDS     r0,r1,r0              ;320
000038  4631              MOV      r1,r6                 ;320
00003a  f7fffffe          BL       __aeabi_uidivmod
00003e  2101              MOVS     r1,#1                 ;320
000040  0900              LSRS     r0,r0,#4              ;320
000042  07c9              LSLS     r1,r1,#31             ;320
000044  1e40              SUBS     r0,r0,#1              ;320
000046  4308              ORRS     r0,r0,r1              ;320
000048  6260              STR      r0,[r4,#0x24]         ;320
00004a  6b20              LDR      r0,[r4,#0x30]         ;322
00004c  2120              MOVS     r1,#0x20              ;322
00004e  4388              BICS     r0,r0,r1              ;322
000050  6320              STR      r0,[r4,#0x30]         ;322
000052  6b20              LDR      r0,[r4,#0x30]         ;323
000054  2140              MOVS     r1,#0x40              ;323
000056  4308              ORRS     r0,r0,r1              ;323
000058  6320              STR      r0,[r4,#0x30]         ;323
00005a  2102              MOVS     r1,#2                 ;324
00005c  6b20              LDR      r0,[r4,#0x30]         ;324
00005e  2d00              CMP      r5,#0                 ;324
000060  d001              BEQ      |L9.102|
000062  4308              ORRS     r0,r0,r1              ;324
000064  e000              B        |L9.104|
                  |L9.102|
000066  4388              BICS     r0,r0,r1              ;324
                  |L9.104|
000068  6320              STR      r0,[r4,#0x30]         ;324
00006a  63a1              STR      r1,[r4,#0x38]         ;325
00006c  b005              ADD      sp,sp,#0x14
00006e  bdf0              POP      {r4-r7,pc}
;;;327    
                          ENDP

                  |L9.112|
                          DCD      ||.constdata||+0x20
                  |L9.116|
                          DCD      0x50000200

                          AREA ||i.UART_SelectLINMode||, CODE, READONLY, ALIGN=1

                  UART_SelectLINMode PROC
;;;358     */
;;;359    void UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength)
000000  b510              PUSH     {r4,lr}
;;;360    {
;;;361        /* Select LIN function mode */
;;;362        uart->FUN_SEL = UART_FUNC_SEL_LIN;
000002  2301              MOVS     r3,#1
000004  6383              STR      r3,[r0,#0x38]
;;;363    
;;;364        /* Select LIN function setting : Tx enable, Rx enable and break field length */
;;;365        uart->FUN_SEL = UART_FUNC_SEL_LIN;
000006  6383              STR      r3,[r0,#0x38]
;;;366        uart->ALT_CTL &= ~(UART_ALT_CTL_LIN_TX_BCNT_Msk | UART_ALT_CTL_LIN_RX_EN_Msk | UART_ALT_CTL_LIN_TX_EN_Msk);
000008  6b43              LDR      r3,[r0,#0x34]
00000a  24c7              MOVS     r4,#0xc7
00000c  43a3              BICS     r3,r3,r4
00000e  6343              STR      r3,[r0,#0x34]
;;;367        uart->ALT_CTL |= u32BreakLength & UART_ALT_CTL_LIN_TX_BCNT_Msk;
000010  6b43              LDR      r3,[r0,#0x34]
000012  0752              LSLS     r2,r2,#29
000014  0f52              LSRS     r2,r2,#29
000016  4313              ORRS     r3,r3,r2
000018  6343              STR      r3,[r0,#0x34]
;;;368        uart->ALT_CTL |= u32Mode;
00001a  6b42              LDR      r2,[r0,#0x34]
00001c  430a              ORRS     r2,r2,r1
00001e  6342              STR      r2,[r0,#0x34]
;;;369    }
000020  bd10              POP      {r4,pc}
;;;370    
                          ENDP


                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=1

                  UART_SelectRS485Mode PROC
;;;337     */
;;;338    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  2303              MOVS     r3,#3
;;;339    {
;;;340        uart->FUN_SEL = UART_FUNC_SEL_RS485;
000002  6383              STR      r3,[r0,#0x38]
;;;341        uart->ALT_CTL = 0;
000004  2300              MOVS     r3,#0
000006  6343              STR      r3,[r0,#0x34]
;;;342        uart->ALT_CTL |= u32Mode | (u32Addr << UART_ALT_CTL_ADDR_PID_MATCH_Pos);
000008  6b43              LDR      r3,[r0,#0x34]
00000a  0612              LSLS     r2,r2,#24
00000c  430a              ORRS     r2,r2,r1
00000e  4313              ORRS     r3,r3,r2
000010  6343              STR      r3,[r0,#0x34]
;;;343    }
000012  4770              BX       lr
;;;344    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;243     */
;;;244    void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;245    {
;;;246        uint8_t u8UartClkSrcSel;
;;;247        uint32_t u32ClkTbl[4] = {__HXT, __LXT, 0, __HIRC12M};
000002  4b1b              LDR      r3,|L12.112|
000004  4616              MOV      r6,r2                 ;245
000006  460c              MOV      r4,r1                 ;245
000008  4605              MOV      r5,r0                 ;245
00000a  cb0f              LDM      r3,{r0-r3}
00000c  b085              SUB      sp,sp,#0x14           ;245
00000e  466f              MOV      r7,sp
000010  c70f              STM      r7!,{r0-r3}
;;;248        uint32_t u32Baud_Div = 0;
;;;249        uint32_t u32SrcFreq;
;;;250        uint32_t u32SrcFreqDiv;
;;;251    
;;;252        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART_S_Msk) >> CLK_CLKSEL1_UART_S_Pos;
000012  4918              LDR      r1,|L12.116|
000014  6948              LDR      r0,[r1,#0x14]
;;;253    
;;;254        u32SrcFreq = u32ClkTbl[u8UartClkSrcSel];
000016  466a              MOV      r2,sp
000018  0780              LSLS     r0,r0,#30             ;252
00001a  0f00              LSRS     r0,r0,#28
00001c  5810              LDR      r0,[r2,r0]
;;;255    
;;;256        u32SrcFreqDiv = (((CLK->CLKDIV0 & CLK_CLKDIV0_UART_N_Msk) >> CLK_CLKDIV0_UART_N_Pos) + 1);
00001e  69c9              LDR      r1,[r1,#0x1c]
;;;257    
;;;258        if(u32SrcFreq == 0) {
;;;259            u32SrcFreq = SysGet_PLLClockFreq() / u32SrcFreqDiv;
;;;260        } else {
;;;261            u32SrcFreq = u32SrcFreq / u32SrcFreqDiv;
;;;262        }
;;;263    
;;;264        if(u32baudrate != 0) {
;;;265            u32Baud_Div = UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32baudrate);
;;;266    
;;;267            if(u32Baud_Div > 0xFFFF)
;;;268                uart->BAUD = (UART_BAUD_MODE1 | UART_BAUD_MODE1_DIVIDER(u32SrcFreq, u32baudrate));
;;;269            else
;;;270                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
;;;271        }
;;;272    
;;;273        uart->TLCTL = u32data_width | u32parity | u32stop_bits;
;;;274    }
000020  0509              LSLS     r1,r1,#20
000022  0f0f              LSRS     r7,r1,#28
000024  1c7f              ADDS     r7,r7,#1
000026  2800              CMP      r0,#0                 ;258
000028  d101              BNE      |L12.46|
00002a  f7fffffe          BL       SysGet_PLLClockFreq
                  |L12.46|
00002e  4639              MOV      r1,r7                 ;261
000030  f7fffffe          BL       __aeabi_uidivmod
000034  4607              MOV      r7,r0                 ;261
000036  2c00              CMP      r4,#0                 ;264
000038  d013              BEQ      |L12.98|
00003a  0860              LSRS     r0,r4,#1              ;265
00003c  19c0              ADDS     r0,r0,r7              ;265
00003e  4621              MOV      r1,r4                 ;265
000040  f7fffffe          BL       __aeabi_uidivmod
000044  490c              LDR      r1,|L12.120|
000046  1e40              SUBS     r0,r0,#1              ;267
000048  4288              CMP      r0,r1                 ;267
00004a  d909              BLS      |L12.96|
00004c  00e0              LSLS     r0,r4,#3              ;268
00004e  19c0              ADDS     r0,r0,r7              ;268
000050  4621              MOV      r1,r4                 ;268
000052  f7fffffe          BL       __aeabi_uidivmod
000056  2101              MOVS     r1,#1                 ;268
000058  0900              LSRS     r0,r0,#4              ;268
00005a  07c9              LSLS     r1,r1,#31             ;268
00005c  1e40              SUBS     r0,r0,#1              ;268
00005e  4308              ORRS     r0,r0,r1              ;268
                  |L12.96|
000060  6268              STR      r0,[r5,#0x24]         ;270
                  |L12.98|
000062  9808              LDR      r0,[sp,#0x20]         ;273
000064  4306              ORRS     r6,r6,r0              ;273
000066  980e              LDR      r0,[sp,#0x38]         ;273
000068  4306              ORRS     r6,r6,r0              ;273
00006a  60ae              STR      r6,[r5,#8]            ;273
00006c  b009              ADD      sp,sp,#0x24
00006e  bdf0              POP      {r4-r7,pc}
;;;275    
                          ENDP

                  |L12.112|
                          DCD      ||.constdata||+0x10
                  |L12.116|
                          DCD      0x50000200
                  |L12.120|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;284     */
;;;285    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;286    {
;;;287        uart->TMCTL = (uart->TMCTL & ~UART_TMCTL_TOIC_Msk)| (u32TOC);
000002  0a52              LSRS     r2,r2,#9
000004  0252              LSLS     r2,r2,#9
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;288        uart->IER |= UART_IER_RTO_IE_Msk;
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  2210              MOVS     r2,#0x10
00000e  4311              ORRS     r1,r1,r2
000010  60c1              STR      r1,[r0,#0xc]
;;;289    }
000012  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;379     */
;;;380    uint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;381    {
000002  4604              MOV      r4,r0
;;;382        uint32_t  u32Count, u32delayno;
;;;383    
;;;384        for(u32Count=0; u32Count != u32WriteBytes; u32Count++) {
000004  2000              MOVS     r0,#0
;;;385            u32delayno = 0;
;;;386            while((uart->FSR & UART_FSR_TX_EMPTY_F_Msk) == 0) { /* Wait Tx empty and Time-out manner */
;;;387                u32delayno++;
;;;388                if( u32delayno >= 0x40000000 )
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L14.38|
                  |L14.12|
00000c  2300              MOVS     r3,#0                 ;385
00000e  e004              B        |L14.26|
                  |L14.16|
000010  1c5b              ADDS     r3,r3,#1              ;386
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L14.26|
;;;389                    return FALSE;
000016  2000              MOVS     r0,#0
;;;390            }
;;;391            uart->THR = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
;;;392        }
;;;393    
;;;394        return u32Count;
;;;395    
;;;396    }
000018  bd70              POP      {r4-r6,pc}
                  |L14.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;386
00001c  05b6              LSLS     r6,r6,#22             ;386
00001e  d5f7              BPL      |L14.16|
000020  5c0b              LDRB     r3,[r1,r0]            ;391
000022  6023              STR      r3,[r4,#0]            ;391
000024  1c40              ADDS     r0,r0,#1              ;391
                  |L14.38|
000026  4290              CMP      r0,r2                 ;384
000028  d1f0              BNE      |L14.12|
00002a  bd70              POP      {r4-r6,pc}
;;;397    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00b71b00
                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x00b71b00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
