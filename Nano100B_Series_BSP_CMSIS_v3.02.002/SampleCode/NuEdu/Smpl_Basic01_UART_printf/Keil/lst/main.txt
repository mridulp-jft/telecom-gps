; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --feedback=.\obj\UART_printf.fed --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\NuEdu\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DDEBUG_PORT=UART1 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;18     
;;;19     void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  2116              MOVS     r1,#0x16
000006  4c11              LDR      r4,|L1.76|
000008  2288              MOVS     r2,#0x88
00000a  e002              B        |L1.18|
                  |L1.12|
00000c  6020              STR      r0,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6022              STR      r2,[r4,#0]
                  |L1.18|
000012  6823              LDR      r3,[r4,#0]
000014  2b01              CMP      r3,#1
000016  d1f9              BNE      |L1.12|
;;;20     {
;;;21         /*---------------------------------------------------------------------------------------------------------*/
;;;22         /* Init System Clock                                                                                       */
;;;23         /*---------------------------------------------------------------------------------------------------------*/
;;;24         /* Unlock protected registers */
;;;25         SYS_UnlockReg();
;;;26     
;;;27         /* Set HCLK source form HXT and HCLK source divide 1  */
;;;28         CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_HXT,CLK_HCLK_CLK_DIVIDER(1));
000018  2100              MOVS     r1,#0
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       CLK_SetHCLK
;;;29     
;;;30         /*  Set HCLK frequency 42MHz */
;;;31         CLK_SetCoreClock(42000000);
000020  480b              LDR      r0,|L1.80|
000022  f7fffffe          BL       CLK_SetCoreClock
;;;32     
;;;33         /* Select IP clock source */
;;;34         CLK_SetModuleClock(UART1_MODULE, CLK_CLKSEL1_UART_S_HIRC, CLK_UART_CLK_DIVIDER(1));
000026  4d0b              LDR      r5,|L1.84|
000028  2200              MOVS     r2,#0
00002a  2103              MOVS     r1,#3
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       CLK_SetModuleClock
;;;35     
;;;36         /* Enable IP clock */
;;;37         CLK_EnableModuleClock(UART1_MODULE);
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       CLK_EnableModuleClock
;;;38     
;;;39         /* Update System Core Clock */
;;;40         /* User can use SystemCoreClockUpdate() to calculate PllClock, SystemCoreClock and CycylesPerUs automatically. */
;;;41         SystemCoreClockUpdate();
000038  f7fffffe          BL       SystemCoreClockUpdate
;;;42     
;;;43         /*---------------------------------------------------------------------------------------------------------*/
;;;44         /* Init I/O Multi-function                                                                                 */
;;;45         /*---------------------------------------------------------------------------------------------------------*/
;;;46     
;;;47         /* Set PC.10 and PC.11 multi-function pins for UART1 RXD, UART0 TXD */
;;;48     		
;;;49         SYS->PC_H_MFP = (SYS_PB_L_MFP_PB4_MFP_UART1_RX | SYS_PB_L_MFP_PB5_MFP_UART1_TX);
00003c  2011              MOVS     r0,#0x11
00003e  4903              LDR      r1,|L1.76|
000040  0400              LSLS     r0,r0,#16
000042  39c0              SUBS     r1,r1,#0xc0
000044  6048              STR      r0,[r1,#4]
000046  2000              MOVS     r0,#0
000048  6020              STR      r0,[r4,#0]
;;;50     
;;;51         /* Lock protected registers */
;;;52         SYS_LockReg();
;;;53     }
00004a  bd70              POP      {r4-r6,pc}
;;;54     
                          ENDP

                  |L1.76|
                          DCD      0x50000100
                  |L1.80|
                          DCD      0x0280de80
                  |L1.84|
                          DCD      0xa6003d11

                          AREA ||i.delay||, CODE, READONLY, ALIGN=2

                  delay PROC
;;;116    
;;;117    void delay(int ms)
000000  4a04              LDR      r2,|L2.20|
;;;118    {int32_t delus=0;
000002  e004              B        |L2.14|
                  |L2.4|
;;;119    	for(ms;ms>0;ms--)
;;;120    	{
;;;121    		for(delus=0;delus<100000;delus++)
000004  2100              MOVS     r1,#0
                  |L2.6|
000006  1c49              ADDS     r1,r1,#1
000008  4291              CMP      r1,r2
00000a  dbfc              BLT      |L2.6|
00000c  1e40              SUBS     r0,r0,#1
                  |L2.14|
00000e  2800              CMP      r0,#0                 ;119
000010  dcf8              BGT      |L2.4|
;;;122    		{
;;;123    		
;;;124    		}
;;;125    	}
;;;126    	
;;;127    	
;;;128    }
000012  4770              BX       lr
;;;129    
                          ENDP

                  |L2.20|
                          DCD      0x000186a0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;132    /*---------------------------------------------------------------------------------------------------------*/
;;;133    int main()
000000  f7fffffe          BL       SYS_Init
;;;134    {
;;;135        uint32_t u32Key,i=0;
;;;136        /* Init System, IP clock and multi-function I/O */
;;;137        SYS_Init();
;;;138    
;;;139        /* Init Key and LED GPIO type */
;;;140     //   GPIO_SetMode(PB, BIT14, GPIO_PMD_INPUT);
;;;141    //    Initial_KEY_INPUT();
;;;142    //    initial_led();
;;;143    
;;;144        /* Init UART to 115200-8n1 for print message */
;;;145        UART_Open(UART1, 9600);
000004  214b              MOVS     r1,#0x4b
000006  01c9              LSLS     r1,r1,#7
000008  4806              LDR      r0,|L3.36|
00000a  f7fffffe          BL       UART_Open
                  |L3.14|
;;;146    
;;;147    
;;;148    //    printf("+-----------------------------------------+\n");
;;;149    //    printf("|    Nano100 Series UART Sample Code      |\n");
;;;150    //    printf("+-----------------------------------------+\n");
;;;151    
;;;152        while(1) {
;;;153    //        /* Detect Key status */
;;;154    //        u32Key = Get_KEY_INPUT();
;;;155    //        if(PB14==0) {
;;;156    //            LED_on(i);
;;;157                printf("\r\nAT\r\n");
00000e  a006              ADR      r0,|L3.40|
000010  f7fffffe          BL       __2printf
;;;158    						printf_UART("\r\nAT\r\n");
000014  a004              ADR      r0,|L3.40|
000016  f7fffffe          BL       printf_UART
;;;159    						delay(10);
00001a  200a              MOVS     r0,#0xa
00001c  f7fffffe          BL       delay
000020  e7f5              B        |L3.14|
;;;160    						
;;;161    //            printf("|    Standare printf function:%d   |\n",i++);
;;;162    //            printf("+----------------------------------+\n");
;;;163    //        }
;;;164    //        if((u32Key & 0x01)==0) {
;;;165    //            LED_on(i);
;;;166    //            printf_UART("+------------------------------+\n");
;;;167    //            printf_UART("|  Simple printf function:%d   |\n",i--);
;;;168    //            printf_UART("+------------------------------+\n");
;;;169            }
;;;170    //    }
;;;171    }
;;;172    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      0x40150000
                  |L3.40|
000028  0d0a4154          DCB      "\r\nAT\r\n",0
00002c  0d0a00  
00002f  00                DCB      0

                          AREA ||i.printHex||, CODE, READONLY, ALIGN=1

                  printHex PROC
;;;78     }
;;;79     void printHex(uint32_t u32Temp)
000000  b51f              PUSH     {r0-r4,lr}
;;;80     {
;;;81         uint8_t print_buf[16];
;;;82         uint32_t i=15;
000002  210f              MOVS     r1,#0xf
;;;83         uint32_t temp;
;;;84     
;;;85         *(print_buf+i) = '\0';
000004  2200              MOVS     r2,#0
000006  466b              MOV      r3,sp
000008  73da              STRB     r2,[r3,#0xf]
                  |L4.10|
;;;86         do {
;;;87             i--;
;;;88             temp = u32Temp%16;
00000a  0702              LSLS     r2,r0,#28
00000c  0f12              LSRS     r2,r2,#28
00000e  1e49              SUBS     r1,r1,#1
;;;89             if(temp < 10)
000010  2a0a              CMP      r2,#0xa
000012  d201              BCS      |L4.24|
000014  3230              ADDS     r2,r2,#0x30
;;;90                 *(print_buf+i) = '0'+temp;
000016  e000              B        |L4.26|
                  |L4.24|
000018  3257              ADDS     r2,r2,#0x57
                  |L4.26|
;;;91             else
;;;92                 *(print_buf+i) = 'a'+(temp-10) ;
00001a  545a              STRB     r2,[r3,r1]
;;;93             u32Temp = u32Temp/16;
00001c  0900              LSRS     r0,r0,#4
00001e  d1f4              BNE      |L4.10|
;;;94         } while (u32Temp != 0);
;;;95         printf_UART(print_buf+i);
000020  1858              ADDS     r0,r3,r1
000022  f7fffffe          BL       printf_UART
;;;96     }
000026  bd1f              POP      {r0-r4,pc}
;;;97     void printf_UART(uint8_t *str,...)
                          ENDP


                          AREA ||i.printInteger||, CODE, READONLY, ALIGN=1

                  printInteger PROC
;;;58     void printf_UART(uint8_t *str,...);
;;;59     void printInteger(uint32_t u32Temp)
000000  b57f              PUSH     {r0-r6,lr}
;;;60     {
;;;61         uint8_t print_buf[16];
;;;62         uint32_t i=15,j;
;;;63     
;;;64         *(print_buf+i) = '\0';
000002  2100              MOVS     r1,#0
000004  240f              MOVS     r4,#0xf               ;62
000006  466e              MOV      r6,sp
000008  73f1              STRB     r1,[r6,#0xf]
;;;65         j = u32Temp >> 31;
00000a  0fc5              LSRS     r5,r0,#31
00000c  d001              BEQ      |L5.18|
;;;66         if(j)
;;;67             u32Temp = ~u32Temp+1;
00000e  43c0              MVNS     r0,r0
000010  1c40              ADDS     r0,r0,#1
                  |L5.18|
;;;68         do {
;;;69             i--;
;;;70             *(print_buf+i) = '0'+u32Temp%10;
000012  210a              MOVS     r1,#0xa
000014  1e64              SUBS     r4,r4,#1
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  3130              ADDS     r1,r1,#0x30
00001c  5531              STRB     r1,[r6,r4]
;;;71             u32Temp = u32Temp /10;
;;;72         } while (u32Temp != 0);
00001e  2800              CMP      r0,#0
000020  d1f7              BNE      |L5.18|
;;;73         if(j) {
000022  2d00              CMP      r5,#0
000024  d002              BEQ      |L5.44|
;;;74             i--;
;;;75             *(print_buf+i) = '-';
000026  202d              MOVS     r0,#0x2d
000028  1e64              SUBS     r4,r4,#1
00002a  5530              STRB     r0,[r6,r4]
                  |L5.44|
;;;76         }
;;;77         printf_UART(print_buf+i);
00002c  1930              ADDS     r0,r6,r4
00002e  f7fffffe          BL       printf_UART
;;;78     }
000032  bd7f              POP      {r0-r6,pc}
;;;79     void printHex(uint32_t u32Temp)
                          ENDP


                          AREA ||i.printf_UART||, CODE, READONLY, ALIGN=1

                  printf_UART PROC
;;;96     }
;;;97     void printf_UART(uint8_t *str,...)
000000  b40f              PUSH     {r0-r3}
;;;98     {
000002  b510              PUSH     {r4,lr}
;;;99         va_list args;
;;;100        va_start( args, str );
000004  ac03              ADD      r4,sp,#0xc
000006  e01c              B        |L6.66|
                  |L6.8|
;;;101        while (*str != '\0') {
;;;102            if(*str == '%') {
000008  2925              CMP      r1,#0x25
00000a  d114              BNE      |L6.54|
00000c  1c40              ADDS     r0,r0,#1
;;;103                str++;
;;;104                if (*str == '\0') return;
00000e  9002              STR      r0,[sp,#8]
000010  7801              LDRB     r1,[r0,#0]
000012  2900              CMP      r1,#0
000014  d019              BEQ      |L6.74|
;;;105                if( *str == 'd' ) {
000016  2964              CMP      r1,#0x64
000018  d002              BEQ      |L6.32|
;;;106                    str++;
;;;107                    printInteger(va_arg( args, int ));
;;;108                } else if( *str == 'x' ) {
00001a  2978              CMP      r1,#0x78
00001c  d006              BEQ      |L6.44|
00001e  e00a              B        |L6.54|
                  |L6.32|
000020  1c40              ADDS     r0,r0,#1
000022  9002              STR      r0,[sp,#8]            ;107
000024  cc01              LDM      r4!,{r0}              ;107
000026  f7fffffe          BL       printInteger
00002a  e004              B        |L6.54|
                  |L6.44|
00002c  1c40              ADDS     r0,r0,#1              ;107
;;;109                    str++;
;;;110                    printHex(va_arg( args, int ));
00002e  9002              STR      r0,[sp,#8]
000030  cc01              LDM      r4!,{r0}
000032  f7fffffe          BL       printHex
                  |L6.54|
;;;111                }
;;;112            }
;;;113            SendChar_ToUART(*str++);
000036  9902              LDR      r1,[sp,#8]
000038  7808              LDRB     r0,[r1,#0]
00003a  1c49              ADDS     r1,r1,#1
00003c  9102              STR      r1,[sp,#8]
00003e  f7fffffe          BL       SendChar_ToUART
                  |L6.66|
000042  9802              LDR      r0,[sp,#8]            ;101
000044  7801              LDRB     r1,[r0,#0]            ;101
000046  2900              CMP      r1,#0                 ;101
000048  d1de              BNE      |L6.8|
                  |L6.74|
;;;114        }
;;;115    }
00004a  bc10              POP      {r4}
00004c  bc08              POP      {r3}
00004e  b004              ADD      sp,sp,#0x10
000050  4718              BX       r3
;;;116    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_SYS_Init____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_SYS_Init____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_SYS_Init____REVSH|
#line 402
|__asm___6_main_c_SYS_Init____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
