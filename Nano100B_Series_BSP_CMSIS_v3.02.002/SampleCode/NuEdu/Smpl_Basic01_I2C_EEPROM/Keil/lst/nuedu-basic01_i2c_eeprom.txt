; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\nuedu-basic01_i2c_eeprom.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\nuedu-basic01_i2c_eeprom.d --feedback=.\obj\Smpl_Basic01_I2C_EEPROM.fed --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\..\Library\CMSIS\Include -I..\..\..\..\Library\Device\Nuvoton\Nano100Series\Include -I..\..\..\..\Library\StdDriver\inc -I..\..\..\..\Library\NuEdu\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=518 -DDEBUG_PORT=UART1 --omf_browse=.\obj\nuedu-basic01_i2c_eeprom.crf ..\..\..\..\Library\NuEdu\src\NuEdu-Basic01_I2C_EEPROM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C1_IRQHandler PROC
;;;69      */
;;;70     void I2C1_IRQHandler(void)
000000  4964              LDR      r1,|L1.404|
;;;71     {
;;;72         uint32_t u32Status;
;;;73     
;;;74         // clear interrupt flag
;;;75         I2C1->INTSTS = I2C_INTSTS_INTSTS_Msk;
000002  2001              MOVS     r0,#1
000004  6048              STR      r0,[r1,#4]
;;;76     
;;;77         u32Status = I2C_EEPROM->STATUS;
000006  6888              LDR      r0,[r1,#8]
;;;78     
;;;79         if (I2C_EEPROM->INTSTS & I2C_INTSTS_TIF_Msk) {
000008  684a              LDR      r2,[r1,#4]
00000a  0792              LSLS     r2,r2,#30
00000c  d502              BPL      |L1.20|
;;;80             /* Clear I2C Timeout Flag */
;;;81             I2C_EEPROM->INTSTS = I2C_INTSTS_TIF_Msk;
00000e  2002              MOVS     r0,#2
000010  6048              STR      r0,[r1,#4]
                  |L1.18|
;;;82         } else {
;;;83             if (s_I2CHandlerFn != NULL)
;;;84                 s_I2CHandlerFn(u32Status);
;;;85         }
;;;86     }
000012  4770              BX       lr
                  |L1.20|
000014  4960              LDR      r1,|L1.408|
000016  6889              LDR      r1,[r1,#8]            ;83  ; s_I2CHandlerFn
000018  2900              CMP      r1,#0                 ;83
00001a  d0fa              BEQ      |L1.18|
00001c  4708              BX       r1                    ;84
;;;87     
                          ENDP

                  I2C_EEPROM_Init PROC
;;;94      */
;;;95     void I2C_EEPROM_Init(uint8_t u8Divider)
00001e  b510              PUSH     {r4,lr}
000020  2105              MOVS     r1,#5
000022  0709              LSLS     r1,r1,#28
000024  6b4a              LDR      r2,[r1,#0x34]
000026  2311              MOVS     r3,#0x11
000028  021b              LSLS     r3,r3,#8
00002a  431a              ORRS     r2,r2,r3
00002c  634a              STR      r2,[r1,#0x34]
00002e  4b5b              LDR      r3,|L1.412|
000030  689c              LDR      r4,[r3,#8]
000032  2201              MOVS     r2,#1
000034  0252              LSLS     r2,r2,#9
000036  4314              ORRS     r4,r4,r2
000038  609c              STR      r4,[r3,#8]
00003a  68cb              LDR      r3,[r1,#0xc]
00003c  4313              ORRS     r3,r3,r2
00003e  60cb              STR      r3,[r1,#0xc]
000040  68cb              LDR      r3,[r1,#0xc]
000042  4393              BICS     r3,r3,r2
000044  60cb              STR      r3,[r1,#0xc]
;;;96     {
;;;97         I2C_PIN_Init();
;;;98         /* Enable I2C Controller */
;;;99         I2C_EEPROM->CON |= I2C_CON_IPEN_Msk;
000046  4953              LDR      r1,|L1.404|
000048  680a              LDR      r2,[r1,#0]
00004a  2301              MOVS     r3,#1
00004c  431a              ORRS     r2,r2,r3
00004e  600a              STR      r2,[r1,#0]
;;;100    
;;;101        /* I2C clock divider, I2C Bus Clock = PCLK / (4*120) = 100kHz */
;;;102        I2C_EEPROM->DIV = u8Divider;
000050  60c8              STR      r0,[r1,#0xc]
;;;103    
;;;104        /* Enable I2C interrupt and set corresponding NVIC bit */
;;;105        I2C_EEPROM->CON |= I2C_CON_INTEN_Msk;
000052  6808              LDR      r0,[r1,#0]
000054  2280              MOVS     r2,#0x80
000056  4310              ORRS     r0,r0,r2
000058  6008              STR      r0,[r1,#0]
00005a  4951              LDR      r1,|L1.416|
00005c  0310              LSLS     r0,r2,#12
00005e  6008              STR      r0,[r1,#0]
;;;106        NVIC_EnableIRQ(I2C_EEPROM_IRQn);
;;;107    }
000060  bd10              POP      {r4,pc}
;;;108    
                          ENDP

                  I2C_MasterRx PROC
;;;116     */
;;;117    void I2C_MasterRx(uint32_t u32Status)
000062  b5f0              PUSH     {r4-r7,lr}
;;;118    {
;;;119        if (u32Status == 0x08) {                    /* START has been transmitted and prepare SLA+W */
;;;120            I2C_EEPROM->DATA = g_u8DeviceAddr << 1;     /* Write SLA+W to Register I2CDAT */
000064  4e4c              LDR      r6,|L1.408|
000066  494b              LDR      r1,|L1.404|
000068  7833              LDRB     r3,[r6,#0]
;;;121            I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_SI);
00006a  221e              MOVS     r2,#0x1e
00006c  005c              LSLS     r4,r3,#1              ;120
00006e  2808              CMP      r0,#8                 ;119
000070  d013              BEQ      |L1.154|
000072  4633              MOV      r3,r6                 ;120
;;;122        } else if (u32Status == 0x18) {             /* SLA+W has been transmitted and ACK has been received */
;;;123            I2C_EEPROM->DATA = g_au8TxData[g_u8DataLen++];
000074  78db              LDRB     r3,[r3,#3]
000076  1d37              ADDS     r7,r6,#4
000078  1c5d              ADDS     r5,r3,#1
00007a  b2ed              UXTB     r5,r5
00007c  2818              CMP      r0,#0x18              ;122
00007e  d00e              BEQ      |L1.158|
;;;124            I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_SI);
;;;125        } else if (u32Status == 0x20) {             /* SLA+W has been transmitted and NACK has been received */
000080  2820              CMP      r0,#0x20
000082  d014              BEQ      |L1.174|
;;;126            I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_STA | I2C_STO | I2C_SI);
;;;127        } else if (u32Status == 0x28) {             /* DATA has been transmitted and ACK has been received */
000084  2828              CMP      r0,#0x28
000086  d018              BEQ      |L1.186|
;;;128            if (g_u8DataLen != 2) {
;;;129                I2C_EEPROM->DATA = g_au8TxData[g_u8DataLen++];
;;;130                I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_SI);
;;;131            } else {
;;;132                I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_STA | I2C_SI);
;;;133            }
;;;134        } else if (u32Status == 0x10) {             /* Repeat START has been transmitted and prepare SLA+R */
000088  2810              CMP      r0,#0x10
00008a  d01c              BEQ      |L1.198|
;;;135            I2C_EEPROM->DATA = ((g_u8DeviceAddr << 1) | 0x01);   /* Write SLA+R to Register I2CDAT */
;;;136            I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_SI);
;;;137        } else if (u32Status == 0x40) {             /* SLA+R has been transmitted and ACK has been received */
00008c  2840              CMP      r0,#0x40
00008e  d009              BEQ      |L1.164|
;;;138            I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_SI);
;;;139        } else if (u32Status == 0x58) {             /* DATA has been received and NACK has been returned */
000090  2858              CMP      r0,#0x58
000092  d01a              BEQ      |L1.202|
;;;140            g_u8RxData = I2C_EEPROM->DATA;
;;;141            I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_STO | I2C_SI);
;;;142            g_u8EndFlag = 1;
;;;143        } else if (u32Status == 0xF8) { /*I2C wave keeps going*/
000094  28f8              CMP      r0,#0xf8
000096  d009              BEQ      |L1.172|
                  |L1.152|
;;;144    
;;;145        } else {
;;;146            /* TO DO */
;;;147            //printf("Status 0x%x is NOT processed\n", u32Status);
;;;148            while(1);
000098  e7fe              B        |L1.152|
                  |L1.154|
00009a  614c              STR      r4,[r1,#0x14]         ;120
00009c  e002              B        |L1.164|
                  |L1.158|
00009e  5cf8              LDRB     r0,[r7,r3]            ;123
0000a0  6148              STR      r0,[r1,#0x14]         ;123
0000a2  70f5              STRB     r5,[r6,#3]            ;123
                  |L1.164|
0000a4  6808              LDR      r0,[r1,#0]            ;138
0000a6  4390              BICS     r0,r0,r2              ;138
0000a8  3010              ADDS     r0,r0,#0x10           ;138
                  |L1.170|
0000aa  6008              STR      r0,[r1,#0]            ;121
                  |L1.172|
;;;149        }
;;;150    }
0000ac  bdf0              POP      {r4-r7,pc}
                  |L1.174|
0000ae  6808              LDR      r0,[r1,#0]            ;126
0000b0  4390              BICS     r0,r0,r2              ;126
0000b2  2214              MOVS     r2,#0x14              ;126
0000b4  3008              ADDS     r0,r0,#8              ;126
0000b6  4310              ORRS     r0,r0,r2              ;126
0000b8  e7f7              B        |L1.170|
                  |L1.186|
0000ba  2b02              CMP      r3,#2                 ;128
0000bc  d1ef              BNE      |L1.158|
0000be  6808              LDR      r0,[r1,#0]            ;132
0000c0  4390              BICS     r0,r0,r2              ;132
0000c2  3018              ADDS     r0,r0,#0x18           ;132
0000c4  e7f1              B        |L1.170|
                  |L1.198|
0000c6  1c64              ADDS     r4,r4,#1              ;132
0000c8  e7e7              B        |L1.154|
                  |L1.202|
0000ca  6948              LDR      r0,[r1,#0x14]         ;140
0000cc  70b0              STRB     r0,[r6,#2]            ;140
0000ce  6808              LDR      r0,[r1,#0]            ;141
0000d0  4390              BICS     r0,r0,r2              ;141
0000d2  3014              ADDS     r0,r0,#0x14           ;141
0000d4  6008              STR      r0,[r1,#0]            ;141
0000d6  2001              MOVS     r0,#1                 ;142
0000d8  7070              STRB     r0,[r6,#1]            ;142
0000da  bdf0              POP      {r4-r7,pc}
;;;151    
                          ENDP

                  I2C_MasterTx PROC
;;;159     */
;;;160    void I2C_MasterTx(uint32_t u32Status)
0000dc  b570              PUSH     {r4-r6,lr}
;;;161    {
;;;162        if (u32Status == 0x08) {                    /* START has been transmitted */
;;;163            I2C_EEPROM->DATA = g_u8DeviceAddr << 1;     /* Write SLA+W to Register I2CDAT */
0000de  4a2d              LDR      r2,|L1.404|
;;;164            I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_SI);
0000e0  231e              MOVS     r3,#0x1e
0000e2  4d2d              LDR      r5,|L1.408|
0000e4  2808              CMP      r0,#8                 ;162
0000e6  d00d              BEQ      |L1.260|
0000e8  4629              MOV      r1,r5                 ;163
;;;165        } else if (u32Status == 0x18) {             /* SLA+W has been transmitted and ACK has been received */
;;;166            I2C_EEPROM->DATA = g_au8TxData[g_u8DataLen++];
0000ea  78c9              LDRB     r1,[r1,#3]
0000ec  1d2e              ADDS     r6,r5,#4
0000ee  1c4c              ADDS     r4,r1,#1
0000f0  b2e4              UXTB     r4,r4
0000f2  2818              CMP      r0,#0x18              ;165
0000f4  d016              BEQ      |L1.292|
;;;167            I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_SI);
;;;168        } else if (u32Status == 0x20) {             /* SLA+W has been transmitted and NACK has been received */
0000f6  2820              CMP      r0,#0x20
0000f8  d00c              BEQ      |L1.276|
;;;169            I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_STA | I2C_STO | I2C_SI);
;;;170        } else if (u32Status == 0x28) {             /* DATA has been transmitted and ACK has been received */
0000fa  2828              CMP      r0,#0x28
0000fc  d010              BEQ      |L1.288|
;;;171            if (g_u8DataLen != 3) {
;;;172                I2C_EEPROM->DATA = g_au8TxData[g_u8DataLen++];
;;;173                I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_SI);
;;;174            } else {
;;;175                I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_STO | I2C_SI);
;;;176                g_u8EndFlag = 1;
;;;177            }
;;;178        } else if (u32Status == 0xF8) { /*I2C wave keeps going*/
0000fe  28f8              CMP      r0,#0xf8
000100  d007              BEQ      |L1.274|
                  |L1.258|
;;;179    
;;;180        } else {
;;;181            /* TO DO */
;;;182            //printf("Status 0x%x is NOT processed\n", u32Status);
;;;183            while(1);
000102  e7fe              B        |L1.258|
                  |L1.260|
000104  7828              LDRB     r0,[r5,#0]            ;163  ; g_u8DeviceAddr
000106  0040              LSLS     r0,r0,#1              ;163
000108  6150              STR      r0,[r2,#0x14]         ;163
                  |L1.266|
00010a  6810              LDR      r0,[r2,#0]            ;164
00010c  4398              BICS     r0,r0,r3              ;164
00010e  3010              ADDS     r0,r0,#0x10           ;164
                  |L1.272|
000110  6010              STR      r0,[r2,#0]            ;164
                  |L1.274|
;;;184        }
;;;185    }
000112  bd70              POP      {r4-r6,pc}
                  |L1.276|
000114  6810              LDR      r0,[r2,#0]            ;169
000116  2114              MOVS     r1,#0x14              ;169
000118  4398              BICS     r0,r0,r3              ;169
00011a  3008              ADDS     r0,r0,#8              ;169
00011c  4308              ORRS     r0,r0,r1              ;169
00011e  e7f7              B        |L1.272|
                  |L1.288|
000120  2903              CMP      r1,#3                 ;171
000122  d003              BEQ      |L1.300|
                  |L1.292|
000124  5c70              LDRB     r0,[r6,r1]            ;172
000126  6150              STR      r0,[r2,#0x14]         ;172
000128  70ec              STRB     r4,[r5,#3]            ;172
00012a  e7ee              B        |L1.266|
                  |L1.300|
00012c  6810              LDR      r0,[r2,#0]            ;175
00012e  4398              BICS     r0,r0,r3              ;175
000130  3014              ADDS     r0,r0,#0x14           ;175
000132  6010              STR      r0,[r2,#0]            ;175
000134  2001              MOVS     r0,#1                 ;176
000136  7068              STRB     r0,[r5,#1]            ;176
000138  bd70              POP      {r4-r6,pc}
;;;186    
                          ENDP

                  I2C_EEPROM_Write PROC
;;;195     */
;;;196    void I2C_EEPROM_Write(uint16_t u16Address, uint8_t u8Data)
00013a  4a17              LDR      r2,|L1.408|
;;;197    {
;;;198        g_au8TxData[0] = u16Address >> 8;
00013c  0a03              LSRS     r3,r0,#8
00013e  1d12              ADDS     r2,r2,#4
000140  7013              STRB     r3,[r2,#0]
;;;199        g_au8TxData[1] = u16Address & 0xFF;
000142  7050              STRB     r0,[r2,#1]
;;;200        g_au8TxData[2] = u8Data;
000144  7091              STRB     r1,[r2,#2]
;;;201    
;;;202        g_u8DataLen = 0;
000146  2100              MOVS     r1,#0
000148  1f10              SUBS     r0,r2,#4
00014a  70c1              STRB     r1,[r0,#3]
;;;203        g_u8EndFlag = 0;
00014c  7041              STRB     r1,[r0,#1]
;;;204    
;;;205        /* I2C function to write data to slave */
;;;206        s_I2CHandlerFn = (I2C_FUNC)I2C_MasterTx;
00014e  4915              LDR      r1,|L1.420|
;;;207    
;;;208        /* I2C as master sends START signal */
;;;209        I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_STA);
000150  4a10              LDR      r2,|L1.404|
000152  6081              STR      r1,[r0,#8]  ; s_I2CHandlerFn
000154  6811              LDR      r1,[r2,#0]
000156  231e              MOVS     r3,#0x1e
000158  4399              BICS     r1,r1,r3
00015a  3108              ADDS     r1,r1,#8
00015c  6011              STR      r1,[r2,#0]
                  |L1.350|
;;;210    
;;;211        /* Wait I2C Tx Finish */
;;;212        while (g_u8EndFlag == 0);
00015e  7841              LDRB     r1,[r0,#1]  ; g_u8EndFlag
000160  2900              CMP      r1,#0
000162  d0fc              BEQ      |L1.350|
;;;213    }
000164  4770              BX       lr
;;;214    
                          ENDP

                  I2C_EEPROM_Read PROC
;;;221     */
;;;222    uint8_t I2C_EEPROM_Read(uint16_t u16Address)
000166  490c              LDR      r1,|L1.408|
;;;223    {
;;;224        g_au8TxData[0] = u16Address >> 8;
000168  0a02              LSRS     r2,r0,#8
00016a  1d09              ADDS     r1,r1,#4
00016c  700a              STRB     r2,[r1,#0]
;;;225        g_au8TxData[1] = u16Address & 0xFF;
00016e  7048              STRB     r0,[r1,#1]
;;;226    
;;;227        g_u8DataLen = 0;
000170  4809              LDR      r0,|L1.408|
000172  2100              MOVS     r1,#0
000174  70c1              STRB     r1,[r0,#3]
;;;228        g_u8EndFlag = 0;
000176  7041              STRB     r1,[r0,#1]
;;;229    
;;;230        /* I2C function to write data to slave */
;;;231        s_I2CHandlerFn = (I2C_FUNC)I2C_MasterRx;
000178  490b              LDR      r1,|L1.424|
;;;232    
;;;233        /* I2C as master sends START signal */
;;;234        I2C_SET_CONTROL_REG(I2C_EEPROM, I2C_STA);
00017a  4a06              LDR      r2,|L1.404|
00017c  6081              STR      r1,[r0,#8]  ; s_I2CHandlerFn
00017e  6811              LDR      r1,[r2,#0]
000180  231e              MOVS     r3,#0x1e
000182  4399              BICS     r1,r1,r3
000184  3108              ADDS     r1,r1,#8
000186  6011              STR      r1,[r2,#0]
                  |L1.392|
;;;235    
;;;236        /* Wait I2C Tx Finish */
;;;237        while (g_u8EndFlag == 0);
000188  7841              LDRB     r1,[r0,#1]  ; g_u8EndFlag
00018a  2900              CMP      r1,#0
00018c  d0fc              BEQ      |L1.392|
;;;238    
;;;239        return g_u8RxData;
00018e  7880              LDRB     r0,[r0,#2]  ; g_u8RxData
;;;240    }
000190  4770              BX       lr
;;;241    
                          ENDP

000192  0000              DCW      0x0000
                  |L1.404|
                          DCD      0x40120000
                  |L1.408|
                          DCD      ||.data||
                  |L1.412|
                          DCD      0x50000200
                  |L1.416|
                          DCD      0xe000e100
                  |L1.420|
                          DCD      I2C_MasterTx
                  |L1.424|
                          DCD      I2C_MasterRx

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8DeviceAddr
000000  50                DCB      0x50
                  g_u8EndFlag
000001  00                DCB      0x00
                  g_u8RxData
000002  00                DCB      0x00
                  g_u8DataLen
000003  00                DCB      0x00
                  g_au8TxData
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  s_I2CHandlerFn
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\Library\\NuEdu\\src\\NuEdu-Basic01_I2C_EEPROM.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___26_NuEdu_Basic01_I2C_EEPROM_c_c1fb7719____REV16|
#line 388 "..\\..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___26_NuEdu_Basic01_I2C_EEPROM_c_c1fb7719____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___26_NuEdu_Basic01_I2C_EEPROM_c_c1fb7719____REVSH|
#line 402
|__asm___26_NuEdu_Basic01_I2C_EEPROM_c_c1fb7719____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
