; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\system_mkl26z4.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\system_mkl26z4.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -I..\..\..\..\inc -I..\vts_ver3_rev1 -I"E:\BITBUCK_JFT\gpstrackr\vts-ver18 - RUDRA_J01\build\keil\vts_ver3_rev1\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.13.0\Device\Include -D__UVISION_VERSION=518 -D_RTE_ -DMKL26Z256xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\system_mkl26z4.crf ..\..\..\src\cpu\CMSIS\Source\system_MKL26Z4.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;126    
;;;127    void SystemInit (void) {
000000  2000              MOVS     r0,#0
;;;128        SIM->COPC = 0x00;
000002  4976              LDR      r1,|L1.476|
000004  6008              STR      r0,[r1,#0]
;;;129    	
;;;130    	
;;;131    #if (DISABLE_WDOG)
;;;132      /* Disable the WDOG module */
;;;133      /* SIM_COPC: COPT=0,COPCLKS=0,COPW=0 */
;;;134      SIM->COPC = (uint32_t)0x00u;
000006  6008              STR      r0,[r1,#0]
;;;135    #endif /* (DISABLE_WDOG) */
;;;136    #if (CLOCK_SETUP == 0)
;;;137      /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=2,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;138      SIM->CLKDIV1 = (uint32_t)0x00020000UL; /* Update system prescalers */
;;;139      /* Switch to FEI Mode */
;;;140      /* MCG->C1: CLKS=0,FRDIV=0,IREFS=1,IRCLKEN=1,IREFSTEN=0 */
;;;141      MCG->C1 = (uint8_t)0x06U;
;;;142      /* MCG_C2: LOCRE0=0,RANGE0=0,HGO0=0,EREFS0=0,LP=0,IRCS=0 */
;;;143      MCG->C2 &= (uint8_t)~(uint8_t)0xBFU;
;;;144      /* MCG->C4: DMX32=0,DRST_DRS=1 */
;;;145      MCG->C4 = (uint8_t)((MCG->C4 & (uint8_t)~(uint8_t)0xC0U) | (uint8_t)0x20U);
;;;146      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
;;;147      OSC0->CR = (uint8_t)0x80U;
;;;148      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;149      MCG->C5 = (uint8_t)0x00U;
;;;150      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;151      MCG->C6 = (uint8_t)0x00U;
;;;152      while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
;;;153      }
;;;154      while((MCG->S & 0x0CU) != 0x00U) {    /* Wait until output of the FLL is selected */
;;;155      }
;;;156    #elif (CLOCK_SETUP == 1)
;;;157      /* SIM->SCGC5: PORTA=1 */
;;;158                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
000008  4875              LDR      r0,|L1.480|
00000a  6b80              LDR      r0,[r0,#0x38]
00000c  1549              ASRS     r1,r1,#21
00000e  4308              ORRS     r0,r0,r1
000010  4973              LDR      r1,|L1.480|
000012  6388              STR      r0,[r1,#0x38]
;;;159      /* SIM->CLKDIV1: OUTDIV1=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;160      SIM->CLKDIV1 = (uint32_t)0x10000000UL; /* Update system prescalers */
000014  2001              MOVS     r0,#1
000016  0700              LSLS     r0,r0,#28
000018  4971              LDR      r1,|L1.480|
00001a  3140              ADDS     r1,r1,#0x40
00001c  6048              STR      r0,[r1,#4]
;;;161      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;162      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
00001e  4871              LDR      r0,|L1.484|
000020  6880              LDR      r0,[r0,#8]
000022  4971              LDR      r1,|L1.488|
000024  4008              ANDS     r0,r0,r1
000026  496f              LDR      r1,|L1.484|
000028  6088              STR      r0,[r1,#8]
;;;163      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;164      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
00002a  4608              MOV      r0,r1
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  496e              LDR      r1,|L1.488|
000030  4008              ANDS     r0,r0,r1
000032  496c              LDR      r1,|L1.484|
000034  60c8              STR      r0,[r1,#0xc]
;;;165      /* Switch to FBE Mode */
;;;166      /* MCG_C2: LOCRE0=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;167               MCG->C2 = (uint8_t)((MCG->C2 & (uint8_t)~(uint8_t)0x9BU) | (uint8_t)0x24U);
000036  486d              LDR      r0,|L1.492|
000038  7840              LDRB     r0,[r0,#1]
00003a  2164              MOVS     r1,#0x64
00003c  4008              ANDS     r0,r0,r1
00003e  2124              MOVS     r1,#0x24
000040  4308              ORRS     r0,r0,r1
000042  496a              LDR      r1,|L1.492|
000044  7048              STRB     r0,[r1,#1]
;;;168      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=0 */
;;;169      OSC0->CR = (uint8_t)0x80U;
000046  2080              MOVS     r0,#0x80
000048  4969              LDR      r1,|L1.496|
00004a  7008              STRB     r0,[r1,#0]
;;;170      /* MCG_C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;171    
;;;172      MCG->C1 = (uint8_t)0x9AU;
00004c  209a              MOVS     r0,#0x9a
00004e  4967              LDR      r1,|L1.492|
000050  7008              STRB     r0,[r1,#0]
;;;173      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;174      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
000052  4608              MOV      r0,r1
000054  78c0              LDRB     r0,[r0,#3]
000056  06c0              LSLS     r0,r0,#27
000058  0ec0              LSRS     r0,r0,#27
00005a  70c8              STRB     r0,[r1,#3]
;;;175      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=1 */
;;;176      MCG->C5 = (uint8_t)0x03U;
00005c  2003              MOVS     r0,#3
00005e  7108              STRB     r0,[r1,#4]
;;;177      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;178      MCG->C6 = (uint8_t)0x00U;
000060  2000              MOVS     r0,#0
000062  7148              STRB     r0,[r1,#5]
;;;179      //while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */}
;;;180     // while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */}
;;;181      /* Switch to PBE Mode */
;;;182      /* MCG->C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
;;;183      MCG->C6 = (uint8_t)0x40U;
000064  2040              MOVS     r0,#0x40
000066  7148              STRB     r0,[r1,#5]
;;;184      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
000068  bf00              NOP      
                  |L1.106|
00006a  4860              LDR      r0,|L1.492|
00006c  7980              LDRB     r0,[r0,#6]
00006e  210c              MOVS     r1,#0xc
000070  4008              ANDS     r0,r0,r1
000072  2808              CMP      r0,#8
000074  d1f9              BNE      |L1.106|
;;;185      }
;;;186      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
000076  bf00              NOP      
                  |L1.120|
000078  485c              LDR      r0,|L1.492|
00007a  7980              LDRB     r0,[r0,#6]
00007c  2140              MOVS     r1,#0x40
00007e  4008              ANDS     r0,r0,r1
000080  2800              CMP      r0,#0
000082  d0f9              BEQ      |L1.120|
;;;187      }
;;;188      /* Switch to PEE Mode */
;;;189      /* MCG->C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;190      MCG->C1 = (uint8_t)0x1AU;
000084  201a              MOVS     r0,#0x1a
000086  4959              LDR      r1,|L1.492|
000088  7008              STRB     r0,[r1,#0]
;;;191      while((MCG->S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */
00008a  bf00              NOP      
                  |L1.140|
00008c  4857              LDR      r0,|L1.492|
00008e  7980              LDRB     r0,[r0,#6]
000090  210c              MOVS     r1,#0xc
000092  4008              ANDS     r0,r0,r1
000094  280c              CMP      r0,#0xc
000096  d1f9              BNE      |L1.140|
;;;192      }
;;;193    #elif (CLOCK_SETUP == 2)
;;;194      /* SIM->SCGC5: PORTA=1 */
;;;195      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
;;;196      /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;197      SIM->CLKDIV1 = (uint32_t)0x00000000UL; /* Update system prescalers */
;;;198      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;199      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
;;;200      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;201      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
;;;202      /* Switch to FBE Mode */
;;;203      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;204      MCG->C2 = (uint8_t)0x24U;
;;;205      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=0 */
;;;206      OSC0->CR = (uint8_t)0x80U;
;;;207      /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;208      MCG->C1 = (uint8_t)0x9AU;
;;;209      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;210      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
;;;211      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;212      MCG->C5 = (uint8_t)0x00U;
;;;213      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;214      MCG->C6 = (uint8_t)0x00U;
;;;215      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
;;;216      }
;;;217      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;218      }
;;;219      /* Switch to BLPE Mode */
;;;220      /* MCG_C2: LOCRE0=0,RANGE0=2,HGO0=0,EREFS0=1,LP=1,IRCS=0 */
;;;221      MCG->C2 = (uint8_t)((MCG->C2 & (uint8_t)~(uint8_t)0x99U) | (uint8_t)0x26U);
;;;222      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;223      }
;;;224    #elif (CLOCK_SETUP == 3)
;;;225    	// CLOCK_SETUP == 3 yields the default startup configuration
;;;226    #elif (CLOCK_SETUP == 4)
;;;227    	
;;;228    	// Use this configuration for USB operation!!
;;;229    	
;;;230    	/* SIM->SCGC5: PORTA=1 */
;;;231      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
;;;232      /* SIM->CLKDIV1: OUTDIV1=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;233      SIM->CLKDIV1 = (uint32_t)0x10010000UL; /* Update system prescalers */
;;;234      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;235      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
;;;236      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;237      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
;;;238      /* Switch to FBE Mode */
;;;239      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=1 */
;;;240      OSC0->CR = (uint8_t)0x89U;
;;;241      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;242      MCG->C2 = (uint8_t)0x24U;
;;;243      /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;244      MCG->C1 = (uint8_t)0x9AU;
;;;245      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;246      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
;;;247      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=1 */
;;;248      MCG->C5 = (uint8_t)0x03U;
;;;249      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;250      MCG->C6 = (uint8_t)0x18U;
;;;251      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
;;;252      }
;;;253      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;254      }
;;;255      /* Switch to PBE Mode */
;;;256      /* MCG->C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
;;;257      MCG->C6 = (uint8_t)0x58U;
;;;258      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;259      }
;;;260      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
;;;261      }
;;;262      /* Switch to PEE Mode */
;;;263      /* MCG->C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;264      MCG->C1 = (uint8_t)0x1AU;
;;;265      while((MCG->S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */
;;;266      }
;;;267      SystemCoreClock = DEFAULT_SYSTEM_CLOCK;
;;;268    #endif /* (CLOCK_SETUP == 4) */
;;;269    }
000098  4770              BX       lr
;;;270    
                          ENDP

                  SystemCoreClockUpdate PROC
;;;274    
;;;275    void SystemCoreClockUpdate (void) {
00009a  b570              PUSH     {r4-r6,lr}
;;;276      uint32_t MCGOUTClock;                                                        /* Variable to store output clock frequency of the MCG module */
;;;277      uint8_t Divider;
;;;278    
;;;279      if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x0u) {
00009c  4853              LDR      r0,|L1.492|
00009e  7800              LDRB     r0,[r0,#0]
0000a0  21c0              MOVS     r1,#0xc0
0000a2  4008              ANDS     r0,r0,r1
0000a4  2800              CMP      r0,#0
0000a6  d168              BNE      |L1.378|
;;;280        /* Output of FLL or PLL is selected */
;;;281        if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u) {
0000a8  4850              LDR      r0,|L1.492|
0000aa  7940              LDRB     r0,[r0,#5]
0000ac  2140              MOVS     r1,#0x40
0000ae  4008              ANDS     r0,r0,r1
0000b0  2800              CMP      r0,#0
0000b2  d14e              BNE      |L1.338|
;;;282          /* FLL is selected */
;;;283          if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u) {
0000b4  484d              LDR      r0,|L1.492|
0000b6  7800              LDRB     r0,[r0,#0]
0000b8  2104              MOVS     r1,#4
0000ba  4008              ANDS     r0,r0,r1
0000bc  2800              CMP      r0,#0
0000be  d115              BNE      |L1.236|
;;;284            /* External reference clock is selected */
;;;285            MCGOUTClock = CPU_XTAL_CLK_HZ;                                       /* System oscillator drives MCG clock */
0000c0  4c4c              LDR      r4,|L1.500|
;;;286            Divider = (uint8_t)(1u << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
0000c2  484a              LDR      r0,|L1.492|
0000c4  7800              LDRB     r0,[r0,#0]
0000c6  2138              MOVS     r1,#0x38
0000c8  4008              ANDS     r0,r0,r1
0000ca  08c1              LSRS     r1,r0,#3
0000cc  2001              MOVS     r0,#1
0000ce  4088              LSLS     r0,r0,r1
0000d0  b2c5              UXTB     r5,r0
;;;287            MCGOUTClock = (MCGOUTClock / Divider);  /* Calculate the divided FLL reference clock */
0000d2  4629              MOV      r1,r5
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       __aeabi_uidivmod
0000da  4604              MOV      r4,r0
;;;288            if ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) {
0000dc  4843              LDR      r0,|L1.492|
0000de  7840              LDRB     r0,[r0,#1]
0000e0  2130              MOVS     r1,#0x30
0000e2  4008              ANDS     r0,r0,r1
0000e4  2800              CMP      r0,#0
0000e6  d003              BEQ      |L1.240|
;;;289              MCGOUTClock /= 32u;                                                  /* If high range is enabled, additional 32 divider is active */
0000e8  0964              LSRS     r4,r4,#5
0000ea  e001              B        |L1.240|
                  |L1.236|
;;;290            } /* ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) */
;;;291          } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;292            MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                     /* The slow internal reference clock is selected */
0000ec  2401              MOVS     r4,#1
0000ee  03e4              LSLS     r4,r4,#15
                  |L1.240|
;;;293          } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;294          /* Select correct multiplier to calculate the MCG output clock  */
;;;295          switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
0000f0  483e              LDR      r0,|L1.492|
0000f2  78c0              LDRB     r0,[r0,#3]
0000f4  21e0              MOVS     r1,#0xe0
0000f6  4008              ANDS     r0,r0,r1
0000f8  06c1              LSLS     r1,r0,#27
0000fa  0ec9              LSRS     r1,r1,#27
0000fc  2900              CMP      r1,#0
0000fe  d126              BNE      |L1.334|
000100  1140              ASRS     r0,r0,#5
000102  0003              MOVS     r3,r0
000104  f7fffffe          BL       __ARM_common_switch8
000108  0805090d          DCB      0x08,0x05,0x09,0x0d
00010c  1115191d          DCB      0x11,0x15,0x19,0x1d
000110  2023              DCB      0x20,0x23
;;;296            case 0x0u:
;;;297              MCGOUTClock *= 640u;
000112  2005              MOVS     r0,#5
000114  01c0              LSLS     r0,r0,#7
000116  4344              MULS     r4,r0,r4
;;;298              break;
000118  e01a              B        |L1.336|
;;;299            case 0x20u:
;;;300              MCGOUTClock *= 1280u;
00011a  2005              MOVS     r0,#5
00011c  0200              LSLS     r0,r0,#8
00011e  4344              MULS     r4,r0,r4
;;;301              break;
000120  e016              B        |L1.336|
;;;302            case 0x40u:
;;;303              MCGOUTClock *= 1920u;
000122  200f              MOVS     r0,#0xf
000124  01c0              LSLS     r0,r0,#7
000126  4344              MULS     r4,r0,r4
;;;304              break;
000128  e012              B        |L1.336|
;;;305            case 0x60u:
;;;306              MCGOUTClock *= 2560u;
00012a  2005              MOVS     r0,#5
00012c  0240              LSLS     r0,r0,#9
00012e  4344              MULS     r4,r0,r4
;;;307              break;
000130  e00e              B        |L1.336|
;;;308            case 0x80u:
;;;309              MCGOUTClock *= 732u;
000132  20b7              MOVS     r0,#0xb7
000134  0080              LSLS     r0,r0,#2
000136  4344              MULS     r4,r0,r4
;;;310              break;
000138  e00a              B        |L1.336|
;;;311            case 0xA0u:
;;;312              MCGOUTClock *= 1464u;
00013a  20b7              MOVS     r0,#0xb7
00013c  00c0              LSLS     r0,r0,#3
00013e  4344              MULS     r4,r0,r4
;;;313              break;
000140  e006              B        |L1.336|
;;;314            case 0xC0u:
;;;315              MCGOUTClock *= 2197u;
000142  482d              LDR      r0,|L1.504|
000144  4344              MULS     r4,r0,r4
;;;316              break;
000146  e003              B        |L1.336|
;;;317            case 0xE0u:
;;;318              MCGOUTClock *= 2929u;
000148  482c              LDR      r0,|L1.508|
00014a  4344              MULS     r4,r0,r4
;;;319              break;
00014c  e000              B        |L1.336|
                  |L1.334|
;;;320            default:
;;;321              break;
00014e  bf00              NOP      
                  |L1.336|
000150  e038              B        |L1.452|
                  |L1.338|
;;;322          }
;;;323        } else { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;324          /* PLL is selected */
;;;325          Divider = (1u + (MCG->C5 & MCG_C5_PRDIV0_MASK));
000152  4826              LDR      r0,|L1.492|
000154  7900              LDRB     r0,[r0,#4]
000156  06c0              LSLS     r0,r0,#27
000158  0ec0              LSRS     r0,r0,#27
00015a  1c45              ADDS     r5,r0,#1
;;;326          MCGOUTClock = (uint32_t)(CPU_XTAL_CLK_HZ / Divider);                     /* Calculate the PLL reference clock */
00015c  4629              MOV      r1,r5
00015e  4825              LDR      r0,|L1.500|
000160  f7fffffe          BL       __aeabi_uidivmod
000164  4604              MOV      r4,r0
;;;327          Divider = ((MCG->C6 & MCG_C6_VDIV0_MASK) + 24u);
000166  4821              LDR      r0,|L1.492|
000168  7940              LDRB     r0,[r0,#5]
00016a  06c0              LSLS     r0,r0,#27
00016c  0ec0              LSRS     r0,r0,#27
00016e  4605              MOV      r5,r0
000170  3518              ADDS     r5,r5,#0x18
;;;328          MCGOUTClock *= Divider;                       /* Calculate the MCG output clock */
000172  4620              MOV      r0,r4
000174  4368              MULS     r0,r5,r0
000176  4604              MOV      r4,r0
000178  e024              B        |L1.452|
                  |L1.378|
;;;329        } /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;330      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40u) {
00017a  481c              LDR      r0,|L1.492|
00017c  7800              LDRB     r0,[r0,#0]
00017e  21c0              MOVS     r1,#0xc0
000180  4008              ANDS     r0,r0,r1
000182  2840              CMP      r0,#0x40
000184  d115              BNE      |L1.434|
;;;331        /* Internal reference clock is selected */
;;;332        if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u) {
000186  4819              LDR      r0,|L1.492|
000188  7840              LDRB     r0,[r0,#1]
00018a  07c0              LSLS     r0,r0,#31
00018c  0fc0              LSRS     r0,r0,#31
00018e  2800              CMP      r0,#0
000190  d102              BNE      |L1.408|
;;;333          MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                       /* Slow internal reference clock selected */
000192  2401              MOVS     r4,#1
000194  03e4              LSLS     r4,r4,#15
000196  e015              B        |L1.452|
                  |L1.408|
;;;334        } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;335          MCGOUTClock = CPU_INT_FAST_CLK_HZ / (1 << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));  /* Fast internal reference clock selected */
000198  4814              LDR      r0,|L1.492|
00019a  7a00              LDRB     r0,[r0,#8]
00019c  220e              MOVS     r2,#0xe
00019e  4010              ANDS     r0,r0,r2
0001a0  0842              LSRS     r2,r0,#1
0001a2  2001              MOVS     r0,#1
0001a4  4090              LSLS     r0,r0,r2
0001a6  4601              MOV      r1,r0
0001a8  4815              LDR      r0,|L1.512|
0001aa  f7fffffe          BL       __aeabi_uidivmod
0001ae  4604              MOV      r4,r0
0001b0  e008              B        |L1.452|
                  |L1.434|
;;;336        } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;337      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u) {
0001b2  480e              LDR      r0,|L1.492|
0001b4  7800              LDRB     r0,[r0,#0]
0001b6  21c0              MOVS     r1,#0xc0
0001b8  4008              ANDS     r0,r0,r1
0001ba  2880              CMP      r0,#0x80
0001bc  d101              BNE      |L1.450|
;;;338        /* External reference clock is selected */
;;;339        MCGOUTClock = CPU_XTAL_CLK_HZ;                                           /* System oscillator drives MCG clock */
0001be  4c0d              LDR      r4,|L1.500|
0001c0  e000              B        |L1.452|
                  |L1.450|
;;;340      } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;341        /* Reserved value */
;;;342        return;
;;;343      } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;344      SystemCoreClock = (MCGOUTClock / (1u + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
;;;345    }
0001c2  bd70              POP      {r4-r6,pc}
                  |L1.452|
0001c4  4806              LDR      r0,|L1.480|
0001c6  3040              ADDS     r0,r0,#0x40           ;344
0001c8  6840              LDR      r0,[r0,#4]            ;344
0001ca  0f00              LSRS     r0,r0,#28             ;344
0001cc  1c41              ADDS     r1,r0,#1              ;344
0001ce  4620              MOV      r0,r4                 ;344
0001d0  f7fffffe          BL       __aeabi_uidivmod
0001d4  490b              LDR      r1,|L1.516|
0001d6  6008              STR      r0,[r1,#0]            ;344  ; SystemCoreClock
0001d8  bf00              NOP      
0001da  e7f2              B        |L1.450|
                          ENDP

                  |L1.476|
                          DCD      0x40048100
                  |L1.480|
                          DCD      0x40048000
                  |L1.484|
                          DCD      0x40049040
                  |L1.488|
                          DCD      0xfefff8ff
                  |L1.492|
                          DCD      0x40064000
                  |L1.496|
                          DCD      0x40065000
                  |L1.500|
                          DCD      0x007a1200
                  |L1.504|
                          DCD      0x00000895
                  |L1.508|
                          DCD      0x00000b71
                  |L1.512|
                          DCD      0x003d0900
                  |L1.516|
                          DCD      SystemCoreClock

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x02dc6c00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L16.24|
                  |L16.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L16.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L16.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\cpu\\CMSIS\\Source\\system_MKL26Z4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL26Z4_c_5d646a67____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_system_MKL26Z4_c_5d646a67____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL26Z4_c_5d646a67____REVSH|
#line 462
|__asm___16_system_MKL26Z4_c_5d646a67____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
