; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\alloc.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\alloc.d --cpu=Cortex-M0+ --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -I..\..\..\..\inc -I..\vts_ver3_rev1 -IE:\bitbuck\gps-trackr\Software\vtsOBD-ver1\build\keil\vts_ver3_rev1\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.12.0\Device\Include -D__UVISION_VERSION=518 -D_RTE_ -DMKL26Z256xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\alloc.crf ..\..\..\src\common\alloc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  free PROC
;;;38     void
;;;39     free (void *ap)
000000  b510              PUSH     {r4,lr}
;;;40     {
000002  4602              MOV      r2,r0
;;;41         ALLOC_HDR *bp, *p;
;;;42     
;;;43         bp = (ALLOC_HDR *)ap - 1;   /* point to block header */
000004  4611              MOV      r1,r2
000006  3910              SUBS     r1,r1,#0x10
;;;44         for (p = freep; !((bp > p) && (bp < p->s.ptr)) ; p = p->s.ptr)
000008  4b36              LDR      r3,|L1.228|
00000a  6818              LDR      r0,[r3,#0]  ; freep
00000c  e009              B        |L1.34|
                  |L1.14|
;;;45         {
;;;46             if ((p >= p->s.ptr) && ((bp > p) || (bp < p->s.ptr)))
00000e  6803              LDR      r3,[r0,#0]
000010  4283              CMP      r3,r0
000012  d805              BHI      |L1.32|
000014  4281              CMP      r1,r0
000016  d802              BHI      |L1.30|
000018  6803              LDR      r3,[r0,#0]
00001a  428b              CMP      r3,r1
00001c  d900              BLS      |L1.32|
                  |L1.30|
;;;47             {
;;;48                 break; /* freed block at start or end of arena */
00001e  e005              B        |L1.44|
                  |L1.32|
000020  6800              LDR      r0,[r0,#0]            ;44
                  |L1.34|
000022  4281              CMP      r1,r0                 ;44
000024  d9f3              BLS      |L1.14|
000026  6803              LDR      r3,[r0,#0]            ;44
000028  428b              CMP      r3,r1                 ;44
00002a  d9f0              BLS      |L1.14|
                  |L1.44|
00002c  bf00              NOP      
;;;49             }
;;;50         }
;;;51     
;;;52         if ((bp + bp->s.size) == p->s.ptr)
00002e  684b              LDR      r3,[r1,#4]
000030  011b              LSLS     r3,r3,#4
000032  185b              ADDS     r3,r3,r1
000034  6804              LDR      r4,[r0,#0]
000036  42a3              CMP      r3,r4
000038  d108              BNE      |L1.76|
;;;53         {
;;;54             bp->s.size += p->s.ptr->s.size;
00003a  684b              LDR      r3,[r1,#4]
00003c  6804              LDR      r4,[r0,#0]
00003e  6864              LDR      r4,[r4,#4]
000040  191b              ADDS     r3,r3,r4
000042  604b              STR      r3,[r1,#4]
;;;55             bp->s.ptr = p->s.ptr->s.ptr;
000044  6803              LDR      r3,[r0,#0]
000046  681b              LDR      r3,[r3,#0]
000048  600b              STR      r3,[r1,#0]
00004a  e001              B        |L1.80|
                  |L1.76|
;;;56         }
;;;57         else
;;;58         {
;;;59             bp->s.ptr = p->s.ptr;
00004c  6803              LDR      r3,[r0,#0]
00004e  600b              STR      r3,[r1,#0]
                  |L1.80|
;;;60         }
;;;61     
;;;62         if ((p + p->s.size) == bp)
000050  6843              LDR      r3,[r0,#4]
000052  011b              LSLS     r3,r3,#4
000054  181b              ADDS     r3,r3,r0
000056  428b              CMP      r3,r1
000058  d106              BNE      |L1.104|
;;;63         {
;;;64             p->s.size += bp->s.size;
00005a  6843              LDR      r3,[r0,#4]
00005c  684c              LDR      r4,[r1,#4]
00005e  191b              ADDS     r3,r3,r4
000060  6043              STR      r3,[r0,#4]
;;;65             p->s.ptr = bp->s.ptr;
000062  680b              LDR      r3,[r1,#0]
000064  6003              STR      r3,[r0,#0]
000066  e000              B        |L1.106|
                  |L1.104|
;;;66         }
;;;67         else
;;;68         {
;;;69             p->s.ptr = bp;
000068  6001              STR      r1,[r0,#0]
                  |L1.106|
;;;70         }
;;;71     
;;;72         freep = p;
00006a  4b1e              LDR      r3,|L1.228|
00006c  6018              STR      r0,[r3,#0]  ; freep
;;;73     }
00006e  bd10              POP      {r4,pc}
;;;74     
                          ENDP

                  malloc PROC
;;;76     void *
;;;77     malloc (unsigned nbytes)
000070  b5f0              PUSH     {r4-r7,lr}
;;;78     {
000072  4605              MOV      r5,r0
;;;79         /* Get addresses for the HEAP start and end */
;;;80         #if defined(CW)  
;;;81           extern char __HEAP_START[];
;;;82           extern char __HEAP_END[];
;;;83         #elif defined(IAR)
;;;84           char* __HEAP_START = __section_begin("HEAP");
;;;85           char* __HEAP_END = __section_end("HEAP");
;;;86         #elif defined(KEIL)
;;;87     	  extern uint32_t HEAP$$Base;
;;;88     	  extern uint32_t HEAP$$Limit;
;;;89     	  uint32_t __HEAP_START = (uint32_t)&HEAP$$Base;
000074  4a1c              LDR      r2,|L1.232|
;;;90     	  uint32_t __HEAP_END = (uint32_t)&HEAP$$Limit;
000076  4e1d              LDR      r6,|L1.236|
;;;91         #endif
;;;92        
;;;93         ALLOC_HDR *p, *prevp;
;;;94         unsigned nunits;
;;;95     
;;;96         nunits = ((nbytes+sizeof(ALLOC_HDR)-1) / sizeof(ALLOC_HDR)) + 1;
000078  4628              MOV      r0,r5
00007a  300f              ADDS     r0,r0,#0xf
00007c  0900              LSRS     r0,r0,#4
00007e  1c44              ADDS     r4,r0,#1
;;;97     
;;;98         if ((prevp = freep) == NULL)
000080  4818              LDR      r0,|L1.228|
000082  6800              LDR      r0,[r0,#0]  ; freep
000084  1e03              SUBS     r3,r0,#0
000086  d10d              BNE      |L1.164|
;;;99         {
;;;100            p = (ALLOC_HDR *)__HEAP_START;
000088  4611              MOV      r1,r2
;;;101            p->s.size = ( ((uint32)__HEAP_END - (uint32)__HEAP_START)
00008a  1ab0              SUBS     r0,r6,r2
00008c  0900              LSRS     r0,r0,#4
00008e  6048              STR      r0,[r1,#4]
;;;102                / sizeof(ALLOC_HDR) );
;;;103            p->s.ptr = &base;
000090  4817              LDR      r0,|L1.240|
000092  6008              STR      r0,[r1,#0]
;;;104            base.s.ptr = p;
000094  6001              STR      r1,[r0,#0]  ; base
;;;105            base.s.size = 0;
000096  2000              MOVS     r0,#0
000098  4f15              LDR      r7,|L1.240|
00009a  6078              STR      r0,[r7,#4]  ; base
;;;106            prevp = freep = &base;
00009c  4638              MOV      r0,r7
00009e  4f11              LDR      r7,|L1.228|
0000a0  4603              MOV      r3,r0
0000a2  6038              STR      r0,[r7,#0]  ; freep
                  |L1.164|
;;;107        }
;;;108    
;;;109        for (p = prevp->s.ptr; ; prevp = p, p = p->s.ptr)
0000a4  6819              LDR      r1,[r3,#0]
0000a6  bf00              NOP      
                  |L1.168|
;;;110        {
;;;111            if (p->s.size >= nunits)
0000a8  6848              LDR      r0,[r1,#4]
0000aa  42a0              CMP      r0,r4
0000ac  d311              BCC      |L1.210|
;;;112            {
;;;113                if (p->s.size == nunits)
0000ae  6848              LDR      r0,[r1,#4]
0000b0  42a0              CMP      r0,r4
0000b2  d102              BNE      |L1.186|
;;;114                {
;;;115                    prevp->s.ptr = p->s.ptr;
0000b4  6808              LDR      r0,[r1,#0]
0000b6  6018              STR      r0,[r3,#0]
0000b8  e006              B        |L1.200|
                  |L1.186|
;;;116                }
;;;117                else
;;;118                {
;;;119                    p->s.size -= nunits;
0000ba  6848              LDR      r0,[r1,#4]
0000bc  1b00              SUBS     r0,r0,r4
0000be  6048              STR      r0,[r1,#4]
;;;120                    p += p->s.size;
0000c0  6848              LDR      r0,[r1,#4]
0000c2  0100              LSLS     r0,r0,#4
0000c4  1809              ADDS     r1,r1,r0
;;;121                    p->s.size = nunits;
0000c6  604c              STR      r4,[r1,#4]
                  |L1.200|
;;;122                }
;;;123                freep = prevp;
0000c8  4806              LDR      r0,|L1.228|
0000ca  6003              STR      r3,[r0,#0]  ; freep
;;;124                return (void *)(p + 1);
0000cc  4608              MOV      r0,r1
0000ce  3010              ADDS     r0,r0,#0x10
                  |L1.208|
;;;125            }
;;;126    
;;;127            if (p == freep)
;;;128                return NULL;
;;;129        }
;;;130    }
0000d0  bdf0              POP      {r4-r7,pc}
                  |L1.210|
0000d2  4804              LDR      r0,|L1.228|
0000d4  6800              LDR      r0,[r0,#0]            ;127  ; freep
0000d6  4281              CMP      r1,r0                 ;127
0000d8  d101              BNE      |L1.222|
0000da  2000              MOVS     r0,#0                 ;128
0000dc  e7f8              B        |L1.208|
                  |L1.222|
0000de  460b              MOV      r3,r1                 ;109
0000e0  6809              LDR      r1,[r1,#0]            ;109
0000e2  e7e1              B        |L1.168|
;;;131    
                          ENDP

                  |L1.228|
                          DCD      freep
                  |L1.232|
                          DCD      ||HEAP$$Base||
                  |L1.236|
                          DCD      ||HEAP$$Limit||
                  |L1.240|
                          DCD      base

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  base
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  freep
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\common\\alloc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_alloc_c_free____REV16|
#line 441 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_alloc_c_free____REV16| PROC
#line 442

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_alloc_c_free____REVSH|
#line 456
|__asm___7_alloc_c_free____REVSH| PROC
#line 457

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
