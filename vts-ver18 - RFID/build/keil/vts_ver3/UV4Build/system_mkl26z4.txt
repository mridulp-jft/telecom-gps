; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\uv4build\system_mkl26z4.o --asm_dir=.\UV4Build\ --list_dir=.\UV4Build\ --depend=.\uv4build\system_mkl26z4.d --cpu=Cortex-M0+ --apcs=interwork -O0 -I..\..\..\src\projects\KEIL_MAG -I..\..\..\src\common -I..\..\..\src\cpu -I..\..\..\src\cpu\headers\CMSIS\MKL26Z4\Include -I..\..\..\src\drivers\llwu -I..\..\..\src\drivers\lptmr -I..\..\..\src\drivers\mcg -I..\..\..\src\drivers\pmc -I..\..\..\src\drivers\rcm -I..\..\..\src\drivers\rtc -I..\..\..\src\drivers\smc -I..\..\..\src\drivers\uart -I..\..\..\src\drivers\cmp -I..\..\..\src\platforms -I..\.. -I..\..\..\src\cpu\CMSIS\Source -I..\..\..\src\cpu\CMSIS\Source\arm -IC:\Keil_v5\ARM\RV31\Inc -IC:\Users\Mridul\Desktop\vts_ver4\build\keil\vts_ver3\RTE -IC:\Keil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.5.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__RTX -D__MICROLIB -DMKL26Z128xxx4 -DKEIL -DFREEDOM -DCMSIS --omf_browse=.\uv4build\system_mkl26z4.crf ..\..\..\src\cpu\CMSIS\Source\system_MKL26Z4.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;126    
;;;127    void SystemInit (void) {
000000  2000              MOVS     r0,#0
;;;128    #if (DISABLE_WDOG)
;;;129      /* Disable the WDOG module */
;;;130      /* SIM_COPC: COPT=0,COPCLKS=0,COPW=0 */
;;;131      SIM->COPC = (uint32_t)0x00u;
000002  497d              LDR      r1,|L1.504|
000004  6008              STR      r0,[r1,#0]
;;;132    #endif /* (DISABLE_WDOG) */
;;;133    #if (CLOCK_SETUP == 0)
;;;134      /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=2,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;135      SIM->CLKDIV1 = (uint32_t)0x00020000UL; /* Update system prescalers */
;;;136      /* Switch to FEI Mode */
;;;137      /* MCG->C1: CLKS=0,FRDIV=0,IREFS=1,IRCLKEN=1,IREFSTEN=0 */
;;;138      MCG->C1 = (uint8_t)0x06U;
;;;139      /* MCG_C2: LOCRE0=0,RANGE0=0,HGO0=0,EREFS0=0,LP=0,IRCS=0 */
;;;140      MCG->C2 &= (uint8_t)~(uint8_t)0xBFU;
;;;141      /* MCG->C4: DMX32=0,DRST_DRS=1 */
;;;142      MCG->C4 = (uint8_t)((MCG->C4 & (uint8_t)~(uint8_t)0xC0U) | (uint8_t)0x20U);
;;;143      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
;;;144      OSC0->CR = (uint8_t)0x80U;
;;;145      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;146      MCG->C5 = (uint8_t)0x00U;
;;;147      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;148      MCG->C6 = (uint8_t)0x00U;
;;;149      while((MCG->S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
;;;150      }
;;;151      while((MCG->S & 0x0CU) != 0x00U) {    /* Wait until output of the FLL is selected */
;;;152      }
;;;153    #elif (CLOCK_SETUP == 1)
;;;154      /* SIM->SCGC5: PORTA=1 */
;;;155      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
000006  487d              LDR      r0,|L1.508|
000008  6b80              LDR      r0,[r0,#0x38]
00000a  1549              ASRS     r1,r1,#21
00000c  4308              ORRS     r0,r0,r1
00000e  497b              LDR      r1,|L1.508|
000010  6388              STR      r0,[r1,#0x38]
;;;156      /* SIM->CLKDIV1: OUTDIV1=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;157      SIM->CLKDIV1 = (uint32_t)0x10000000UL; /* Update system prescalers */
000012  2001              MOVS     r0,#1
000014  0700              LSLS     r0,r0,#28
000016  4979              LDR      r1,|L1.508|
000018  3140              ADDS     r1,r1,#0x40
00001a  6048              STR      r0,[r1,#4]
;;;158      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;159      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
00001c  4878              LDR      r0,|L1.512|
00001e  6880              LDR      r0,[r0,#8]
000020  4978              LDR      r1,|L1.516|
000022  4008              ANDS     r0,r0,r1
000024  4976              LDR      r1,|L1.512|
000026  6088              STR      r0,[r1,#8]
;;;160      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;161      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
000028  4608              MOV      r0,r1
00002a  68c0              LDR      r0,[r0,#0xc]
00002c  4975              LDR      r1,|L1.516|
00002e  4008              ANDS     r0,r0,r1
000030  4973              LDR      r1,|L1.512|
000032  60c8              STR      r0,[r1,#0xc]
;;;162      /* Switch to FBE Mode */
;;;163      /* MCG_C2: LOCRE0=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;164      MCG->C2 = (uint8_t)((MCG->C2 & (uint8_t)~(uint8_t)0x9BU) | (uint8_t)0x24U);
000034  4874              LDR      r0,|L1.520|
000036  7840              LDRB     r0,[r0,#1]
000038  2164              MOVS     r1,#0x64
00003a  4008              ANDS     r0,r0,r1
00003c  2124              MOVS     r1,#0x24
00003e  4308              ORRS     r0,r0,r1
000040  4971              LDR      r1,|L1.520|
000042  7048              STRB     r0,[r1,#1]
;;;165      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=0 */
;;;166      OSC0->CR = (uint8_t)0x80U;
000044  2080              MOVS     r0,#0x80
000046  4971              LDR      r1,|L1.524|
000048  7008              STRB     r0,[r1,#0]
;;;167      /* MCG_C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;168      MCG->C1 = (uint8_t)0x9AU;
00004a  209a              MOVS     r0,#0x9a
00004c  496e              LDR      r1,|L1.520|
00004e  7008              STRB     r0,[r1,#0]
;;;169      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;170      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
000050  4608              MOV      r0,r1
000052  78c0              LDRB     r0,[r0,#3]
000054  06c0              LSLS     r0,r0,#27
000056  0ec0              LSRS     r0,r0,#27
000058  70c8              STRB     r0,[r1,#3]
;;;171      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=1 */
;;;172      MCG->C5 = (uint8_t)0x03U;
00005a  2003              MOVS     r0,#3
00005c  7108              STRB     r0,[r1,#4]
;;;173      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;174      MCG->C6 = (uint8_t)0x00U;
00005e  2000              MOVS     r0,#0
000060  7148              STRB     r0,[r1,#5]
;;;175      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
000062  bf00              NOP      
                  |L1.100|
000064  4868              LDR      r0,|L1.520|
000066  7980              LDRB     r0,[r0,#6]
000068  2110              MOVS     r1,#0x10
00006a  4008              ANDS     r0,r0,r1
00006c  2800              CMP      r0,#0
00006e  d1f9              BNE      |L1.100|
;;;176      }
;;;177      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
000070  bf00              NOP      
                  |L1.114|
000072  4865              LDR      r0,|L1.520|
000074  7980              LDRB     r0,[r0,#6]
000076  210c              MOVS     r1,#0xc
000078  4008              ANDS     r0,r0,r1
00007a  2808              CMP      r0,#8
00007c  d1f9              BNE      |L1.114|
;;;178      }
;;;179      /* Switch to PBE Mode */
;;;180      /* MCG->C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
;;;181      MCG->C6 = (uint8_t)0x40U;
00007e  2040              MOVS     r0,#0x40
000080  4961              LDR      r1,|L1.520|
000082  7148              STRB     r0,[r1,#5]
;;;182      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
000084  bf00              NOP      
                  |L1.134|
000086  4860              LDR      r0,|L1.520|
000088  7980              LDRB     r0,[r0,#6]
00008a  210c              MOVS     r1,#0xc
00008c  4008              ANDS     r0,r0,r1
00008e  2808              CMP      r0,#8
000090  d1f9              BNE      |L1.134|
;;;183      }
;;;184      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
000092  bf00              NOP      
                  |L1.148|
000094  485c              LDR      r0,|L1.520|
000096  7980              LDRB     r0,[r0,#6]
000098  2140              MOVS     r1,#0x40
00009a  4008              ANDS     r0,r0,r1
00009c  2800              CMP      r0,#0
00009e  d0f9              BEQ      |L1.148|
;;;185      }
;;;186      /* Switch to PEE Mode */
;;;187      /* MCG->C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;188      MCG->C1 = (uint8_t)0x1AU;
0000a0  201a              MOVS     r0,#0x1a
0000a2  4959              LDR      r1,|L1.520|
0000a4  7008              STRB     r0,[r1,#0]
;;;189      while((MCG->S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */
0000a6  bf00              NOP      
                  |L1.168|
0000a8  4857              LDR      r0,|L1.520|
0000aa  7980              LDRB     r0,[r0,#6]
0000ac  210c              MOVS     r1,#0xc
0000ae  4008              ANDS     r0,r0,r1
0000b0  280c              CMP      r0,#0xc
0000b2  d1f9              BNE      |L1.168|
;;;190      }
;;;191    #elif (CLOCK_SETUP == 2)
;;;192      /* SIM->SCGC5: PORTA=1 */
;;;193      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
;;;194      /* SIM->CLKDIV1: OUTDIV1=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;195      SIM->CLKDIV1 = (uint32_t)0x00000000UL; /* Update system prescalers */
;;;196      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;197      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
;;;198      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;199      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
;;;200      /* Switch to FBE Mode */
;;;201      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;202      MCG->C2 = (uint8_t)0x24U;
;;;203      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=0 */
;;;204      OSC0->CR = (uint8_t)0x80U;
;;;205      /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;206      MCG->C1 = (uint8_t)0x9AU;
;;;207      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;208      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
;;;209      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=0 */
;;;210      MCG->C5 = (uint8_t)0x00U;
;;;211      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;212      MCG->C6 = (uint8_t)0x00U;
;;;213      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
;;;214      }
;;;215      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;216      }
;;;217      /* Switch to BLPE Mode */
;;;218      /* MCG_C2: LOCRE0=0,RANGE0=2,HGO0=0,EREFS0=1,LP=1,IRCS=0 */
;;;219      MCG->C2 = (uint8_t)((MCG->C2 & (uint8_t)~(uint8_t)0x99U) | (uint8_t)0x26U);
;;;220      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;221      }
;;;222    #elif (CLOCK_SETUP == 3)
;;;223    	// CLOCK_SETUP == 3 yields the default startup configuration
;;;224    #elif (CLOCK_SETUP == 4)
;;;225    	
;;;226    	// Use this configuration for USB operation!!
;;;227    	
;;;228    	/* SIM->SCGC5: PORTA=1 */
;;;229      SIM->SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
;;;230      /* SIM->CLKDIV1: OUTDIV1=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,OUTDIV4=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
;;;231      SIM->CLKDIV1 = (uint32_t)0x10010000UL; /* Update system prescalers */
;;;232      /* PORTA->PCR18: ISF=0,MUX=0 */
;;;233      PORTA->PCR[18] &= (uint32_t)~0x01000700UL;
;;;234      /* PORTA->PCR19: ISF=0,MUX=0 */
;;;235      PORTA->PCR[19] &= (uint32_t)~0x01000700UL;
;;;236      /* Switch to FBE Mode */
;;;237      /* OSC0->CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=1,SC4P=0,SC8P=0,SC16P=1 */
;;;238      OSC0->CR = (uint8_t)0x89U;
;;;239      /* MCG->C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=1,LP=0,IRCS=0 */
;;;240      MCG->C2 = (uint8_t)0x24U;
;;;241      /* MCG->C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;242      MCG->C1 = (uint8_t)0x9AU;
;;;243      /* MCG->C4: DMX32=0,DRST_DRS=0 */
;;;244      MCG->C4 &= (uint8_t)~(uint8_t)0xE0U;
;;;245      /* MCG->C5: ??=0,PLLCLKEN0=0,PLLSTEN0=0,PRDIV0=1 */
;;;246      MCG->C5 = (uint8_t)0x03U;
;;;247      /* MCG->C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=0 */
;;;248      MCG->C6 = (uint8_t)0x18U;
;;;249      while((MCG->S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
;;;250      }
;;;251      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;252      }
;;;253      /* Switch to PBE Mode */
;;;254      /* MCG->C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
;;;255      MCG->C6 = (uint8_t)0x58U;
;;;256      while((MCG->S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
;;;257      }
;;;258      while((MCG->S & MCG_S_LOCK0_MASK) == 0x00U) { /* Wait until locked */
;;;259      }
;;;260      /* Switch to PEE Mode */
;;;261      /* MCG->C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
;;;262      MCG->C1 = (uint8_t)0x1AU;
;;;263      while((MCG->S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */
;;;264      }
;;;265      SystemCoreClock = DEFAULT_SYSTEM_CLOCK;
;;;266    #endif /* (CLOCK_SETUP == 4) */
;;;267    }
0000b4  4770              BX       lr
;;;268    
                          ENDP

                  SystemCoreClockUpdate PROC
;;;272    
;;;273    void SystemCoreClockUpdate (void) {
0000b6  b570              PUSH     {r4-r6,lr}
;;;274      uint32_t MCGOUTClock;                                                        /* Variable to store output clock frequency of the MCG module */
;;;275      uint8_t Divider;
;;;276    
;;;277      if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x0u) {
0000b8  4853              LDR      r0,|L1.520|
0000ba  7800              LDRB     r0,[r0,#0]
0000bc  21c0              MOVS     r1,#0xc0
0000be  4008              ANDS     r0,r0,r1
0000c0  2800              CMP      r0,#0
0000c2  d168              BNE      |L1.406|
;;;278        /* Output of FLL or PLL is selected */
;;;279        if ((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u) {
0000c4  4850              LDR      r0,|L1.520|
0000c6  7940              LDRB     r0,[r0,#5]
0000c8  2140              MOVS     r1,#0x40
0000ca  4008              ANDS     r0,r0,r1
0000cc  2800              CMP      r0,#0
0000ce  d14e              BNE      |L1.366|
;;;280          /* FLL is selected */
;;;281          if ((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u) {
0000d0  484d              LDR      r0,|L1.520|
0000d2  7800              LDRB     r0,[r0,#0]
0000d4  2104              MOVS     r1,#4
0000d6  4008              ANDS     r0,r0,r1
0000d8  2800              CMP      r0,#0
0000da  d115              BNE      |L1.264|
;;;282            /* External reference clock is selected */
;;;283            MCGOUTClock = CPU_XTAL_CLK_HZ;                                       /* System oscillator drives MCG clock */
0000dc  4c4c              LDR      r4,|L1.528|
;;;284            Divider = (uint8_t)(1u << ((MCG->C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT));
0000de  484a              LDR      r0,|L1.520|
0000e0  7800              LDRB     r0,[r0,#0]
0000e2  2138              MOVS     r1,#0x38
0000e4  4008              ANDS     r0,r0,r1
0000e6  08c1              LSRS     r1,r0,#3
0000e8  2001              MOVS     r0,#1
0000ea  4088              LSLS     r0,r0,r1
0000ec  b2c5              UXTB     r5,r0
;;;285            MCGOUTClock = (MCGOUTClock / Divider);  /* Calculate the divided FLL reference clock */
0000ee  4629              MOV      r1,r5
0000f0  4620              MOV      r0,r4
0000f2  f7fffffe          BL       __aeabi_uidivmod
0000f6  4604              MOV      r4,r0
;;;286            if ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) {
0000f8  4843              LDR      r0,|L1.520|
0000fa  7840              LDRB     r0,[r0,#1]
0000fc  2130              MOVS     r1,#0x30
0000fe  4008              ANDS     r0,r0,r1
000100  2800              CMP      r0,#0
000102  d003              BEQ      |L1.268|
;;;287              MCGOUTClock /= 32u;                                                  /* If high range is enabled, additional 32 divider is active */
000104  0964              LSRS     r4,r4,#5
000106  e001              B        |L1.268|
                  |L1.264|
;;;288            } /* ((MCG->C2 & MCG_C2_RANGE0_MASK) != 0x0u) */
;;;289          } else { /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;290            MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                     /* The slow internal reference clock is selected */
000108  2401              MOVS     r4,#1
00010a  03e4              LSLS     r4,r4,#15
                  |L1.268|
;;;291          } /* (!((MCG->C1 & MCG_C1_IREFS_MASK) == 0x0u)) */
;;;292          /* Select correct multiplier to calculate the MCG output clock  */
;;;293          switch (MCG->C4 & (MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS_MASK)) {
00010c  483e              LDR      r0,|L1.520|
00010e  78c0              LDRB     r0,[r0,#3]
000110  21e0              MOVS     r1,#0xe0
000112  4008              ANDS     r0,r0,r1
000114  06c1              LSLS     r1,r0,#27
000116  0ec9              LSRS     r1,r1,#27
000118  2900              CMP      r1,#0
00011a  d126              BNE      |L1.362|
00011c  1140              ASRS     r0,r0,#5
00011e  0003              MOVS     r3,r0
000120  f7fffffe          BL       __ARM_common_switch8
000124  0805090d          DCB      0x08,0x05,0x09,0x0d
000128  1115191d          DCB      0x11,0x15,0x19,0x1d
00012c  2023              DCB      0x20,0x23
;;;294            case 0x0u:
;;;295              MCGOUTClock *= 640u;
00012e  2005              MOVS     r0,#5
000130  01c0              LSLS     r0,r0,#7
000132  4344              MULS     r4,r0,r4
;;;296              break;
000134  e01a              B        |L1.364|
;;;297            case 0x20u:
;;;298              MCGOUTClock *= 1280u;
000136  2005              MOVS     r0,#5
000138  0200              LSLS     r0,r0,#8
00013a  4344              MULS     r4,r0,r4
;;;299              break;
00013c  e016              B        |L1.364|
;;;300            case 0x40u:
;;;301              MCGOUTClock *= 1920u;
00013e  200f              MOVS     r0,#0xf
000140  01c0              LSLS     r0,r0,#7
000142  4344              MULS     r4,r0,r4
;;;302              break;
000144  e012              B        |L1.364|
;;;303            case 0x60u:
;;;304              MCGOUTClock *= 2560u;
000146  2005              MOVS     r0,#5
000148  0240              LSLS     r0,r0,#9
00014a  4344              MULS     r4,r0,r4
;;;305              break;
00014c  e00e              B        |L1.364|
;;;306            case 0x80u:
;;;307              MCGOUTClock *= 732u;
00014e  20b7              MOVS     r0,#0xb7
000150  0080              LSLS     r0,r0,#2
000152  4344              MULS     r4,r0,r4
;;;308              break;
000154  e00a              B        |L1.364|
;;;309            case 0xA0u:
;;;310              MCGOUTClock *= 1464u;
000156  20b7              MOVS     r0,#0xb7
000158  00c0              LSLS     r0,r0,#3
00015a  4344              MULS     r4,r0,r4
;;;311              break;
00015c  e006              B        |L1.364|
;;;312            case 0xC0u:
;;;313              MCGOUTClock *= 2197u;
00015e  482d              LDR      r0,|L1.532|
000160  4344              MULS     r4,r0,r4
;;;314              break;
000162  e003              B        |L1.364|
;;;315            case 0xE0u:
;;;316              MCGOUTClock *= 2929u;
000164  482c              LDR      r0,|L1.536|
000166  4344              MULS     r4,r0,r4
;;;317              break;
000168  e000              B        |L1.364|
                  |L1.362|
;;;318            default:
;;;319              break;
00016a  bf00              NOP      
                  |L1.364|
00016c  e038              B        |L1.480|
                  |L1.366|
;;;320          }
;;;321        } else { /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;322          /* PLL is selected */
;;;323          Divider = (1u + (MCG->C5 & MCG_C5_PRDIV0_MASK));
00016e  4826              LDR      r0,|L1.520|
000170  7900              LDRB     r0,[r0,#4]
000172  06c0              LSLS     r0,r0,#27
000174  0ec0              LSRS     r0,r0,#27
000176  1c45              ADDS     r5,r0,#1
;;;324          MCGOUTClock = (uint32_t)(CPU_XTAL_CLK_HZ / Divider);                     /* Calculate the PLL reference clock */
000178  4629              MOV      r1,r5
00017a  4825              LDR      r0,|L1.528|
00017c  f7fffffe          BL       __aeabi_uidivmod
000180  4604              MOV      r4,r0
;;;325          Divider = ((MCG->C6 & MCG_C6_VDIV0_MASK) + 24u);
000182  4821              LDR      r0,|L1.520|
000184  7940              LDRB     r0,[r0,#5]
000186  06c0              LSLS     r0,r0,#27
000188  0ec0              LSRS     r0,r0,#27
00018a  4605              MOV      r5,r0
00018c  3518              ADDS     r5,r5,#0x18
;;;326          MCGOUTClock *= Divider;                       /* Calculate the MCG output clock */
00018e  4620              MOV      r0,r4
000190  4368              MULS     r0,r5,r0
000192  4604              MOV      r4,r0
000194  e024              B        |L1.480|
                  |L1.406|
;;;327        } /* (!((MCG->C6 & MCG_C6_PLLS_MASK) == 0x0u)) */
;;;328      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x40u) {
000196  481c              LDR      r0,|L1.520|
000198  7800              LDRB     r0,[r0,#0]
00019a  21c0              MOVS     r1,#0xc0
00019c  4008              ANDS     r0,r0,r1
00019e  2840              CMP      r0,#0x40
0001a0  d115              BNE      |L1.462|
;;;329        /* Internal reference clock is selected */
;;;330        if ((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u) {
0001a2  4819              LDR      r0,|L1.520|
0001a4  7840              LDRB     r0,[r0,#1]
0001a6  07c0              LSLS     r0,r0,#31
0001a8  0fc0              LSRS     r0,r0,#31
0001aa  2800              CMP      r0,#0
0001ac  d102              BNE      |L1.436|
;;;331          MCGOUTClock = CPU_INT_SLOW_CLK_HZ;                                       /* Slow internal reference clock selected */
0001ae  2401              MOVS     r4,#1
0001b0  03e4              LSLS     r4,r4,#15
0001b2  e015              B        |L1.480|
                  |L1.436|
;;;332        } else { /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;333          MCGOUTClock = CPU_INT_FAST_CLK_HZ / (1 << ((MCG->SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT));  /* Fast internal reference clock selected */
0001b4  4814              LDR      r0,|L1.520|
0001b6  7a00              LDRB     r0,[r0,#8]
0001b8  220e              MOVS     r2,#0xe
0001ba  4010              ANDS     r0,r0,r2
0001bc  0842              LSRS     r2,r0,#1
0001be  2001              MOVS     r0,#1
0001c0  4090              LSLS     r0,r0,r2
0001c2  4601              MOV      r1,r0
0001c4  4815              LDR      r0,|L1.540|
0001c6  f7fffffe          BL       __aeabi_uidivmod
0001ca  4604              MOV      r4,r0
0001cc  e008              B        |L1.480|
                  |L1.462|
;;;334        } /* (!((MCG->C2 & MCG_C2_IRCS_MASK) == 0x0u)) */
;;;335      } else if ((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u) {
0001ce  480e              LDR      r0,|L1.520|
0001d0  7800              LDRB     r0,[r0,#0]
0001d2  21c0              MOVS     r1,#0xc0
0001d4  4008              ANDS     r0,r0,r1
0001d6  2880              CMP      r0,#0x80
0001d8  d101              BNE      |L1.478|
;;;336        /* External reference clock is selected */
;;;337        MCGOUTClock = CPU_XTAL_CLK_HZ;                                           /* System oscillator drives MCG clock */
0001da  4c0d              LDR      r4,|L1.528|
0001dc  e000              B        |L1.480|
                  |L1.478|
;;;338      } else { /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;339        /* Reserved value */
;;;340        return;
;;;341      } /* (!((MCG->C1 & MCG_C1_CLKS_MASK) == 0x80u)) */
;;;342      SystemCoreClock = (MCGOUTClock / (1u + ((SIM->CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)));
;;;343    }
0001de  bd70              POP      {r4-r6,pc}
                  |L1.480|
0001e0  4806              LDR      r0,|L1.508|
0001e2  3040              ADDS     r0,r0,#0x40           ;342
0001e4  6840              LDR      r0,[r0,#4]            ;342
0001e6  0f00              LSRS     r0,r0,#28             ;342
0001e8  1c41              ADDS     r1,r0,#1              ;342
0001ea  4620              MOV      r0,r4                 ;342
0001ec  f7fffffe          BL       __aeabi_uidivmod
0001f0  490b              LDR      r1,|L1.544|
0001f2  6008              STR      r0,[r1,#0]            ;342  ; SystemCoreClock
0001f4  bf00              NOP      
0001f6  e7f2              B        |L1.478|
                          ENDP

                  |L1.504|
                          DCD      0x40048100
                  |L1.508|
                          DCD      0x40048000
                  |L1.512|
                          DCD      0x40049040
                  |L1.516|
                          DCD      0xfefff8ff
                  |L1.520|
                          DCD      0x40064000
                  |L1.524|
                          DCD      0x40065000
                  |L1.528|
                          DCD      0x007a1200
                  |L1.532|
                          DCD      0x00000895
                  |L1.536|
                          DCD      0x00000b71
                  |L1.540|
                          DCD      0x003d0900
                  |L1.544|
                          DCD      SystemCoreClock

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x02dc6c00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L16.24|
                  |L16.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L16.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L16.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\src\\cpu\\CMSIS\\Source\\system_MKL26Z4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL26Z4_c_5d646a67____REV16|
#line 129 "C:\\Keil_v5\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_system_MKL26Z4_c_5d646a67____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_system_MKL26Z4_c_5d646a67____REVSH|
#line 144
|__asm___16_system_MKL26Z4_c_5d646a67____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
